<html>
    <head>
<script>
	var MetaMaskSDK = (function () {
  'use strict';

  /**
   * Checks the doctype of the current document if it exists
   *
   * @returns {boolean} {@code true} if the doctype is html or if none exists
   */
  function doctypeCheck() {
      var doctype = window.document.doctype;
      if (doctype) {
          return doctype.name === 'html';
      }
      return true;
  }
  /**
   * Returns whether or not the extension (suffix) of the current document is prohibited
   *
   * This checks {@code window.location.pathname} against a set of file extensions
   * that we should not inject the provider into. This check is indifferent of
   * query parameters in the location.
   *
   * @returns {boolean} whether or not the extension of the current document is prohibited
   */
  function suffixCheck() {
      var prohibitedTypes = [/\.xml$/u, /\.pdf$/u];
      var currentUrl = window.location.pathname;
      for (var i = 0; i < prohibitedTypes.length; i++) {
          if (prohibitedTypes[i].test(currentUrl)) {
              return false;
          }
      }
      return true;
  }
  /**
   * Checks the documentElement of the current document
   *
   * @returns {boolean} {@code true} if the documentElement is an html node or if none exists
   */
  function documentElementCheck() {
      var documentElement = document.documentElement.nodeName;
      if (documentElement) {
          return documentElement.toLowerCase() === 'html';
      }
      return true;
  }
  /**
   * Checks if the current domain is blocked
   *
   * @returns {boolean} {@code true} if the current domain is blocked
   */
  function blockedDomainCheck() {
      var blockedDomains = [
          'uscourts.gov',
          'dropbox.com',
          'webbyawards.com',
          'cdn.shopify.com/s/javascripts/tricorder/xtld-read-only-frame.html',
          'adyen.com',
          'gravityforms.com',
          'harbourair.com',
          'ani.gamer.com.tw',
          'blueskybooking.com',
          'sharefile.com',
      ];
      var currentUrl = window.location.href;
      var currentRegex;
      for (var i = 0; i < blockedDomains.length; i++) {
          var blockedDomain = blockedDomains[i].replace('.', '\\.');
          currentRegex = new RegExp("(?:https?:\\/\\/)(?:(?!" + blockedDomain + ").)*$", 'u');
          if (!currentRegex.test(currentUrl)) {
              return true;
          }
      }
      return false;
  }
  var isProviderAlreadyInjected = function () { return Boolean(window.ethereum); };
  var shouldInjectProvider = function () {
      return (!isProviderAlreadyInjected() &&
          doctypeCheck() &&
          suffixCheck() &&
          documentElementCheck() &&
          !blockedDomainCheck());
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign$1.apply(this, arguments);
  };

  function __awaiter$2(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator$2(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function () {
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var dist$6 = {};

  var MetaMaskInpageProvider$1 = {};

  var dist$5 = {};

  var classes = {};

  var fastSafeStringify = stringify;
  stringify.default = stringify;
  stringify.stable = deterministicStringify;
  stringify.stableStringify = deterministicStringify;

  var LIMIT_REPLACE_NODE = '[...]';
  var CIRCULAR_REPLACE_NODE = '[Circular]';

  var arr = [];
  var replacerStack = [];

  function defaultOptions () {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    }
  }

  // Regular stringify
  function stringify (obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
      options = defaultOptions();
    }

    decirc(obj, '', 0, [], undefined, 0, options);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res
  }

  function setReplace (replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== undefined) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k, { value: replace });
        arr.push([parent, k, val, propertyDescriptor]);
      } else {
        replacerStack.push([val, k, replace]);
      }
    } else {
      parent[k] = replace;
      arr.push([parent, k, val]);
    }
  }

  function decirc (val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return
        }
      }

      if (
        typeof options.depthLimit !== 'undefined' &&
        depth > options.depthLimit
      ) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return
      }

      if (
        typeof options.edgesLimit !== 'undefined' &&
        edgeIndex + 1 > options.edgesLimit
      ) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return
      }

      stack.push(val);
      // Optimize for Arrays. Big arrays could kill the performance otherwise!
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          decirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        var keys = Object.keys(val);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          decirc(val[key], key, i, stack, val, depth, options);
        }
      }
      stack.pop();
    }
  }

  // Stable-stringify
  function compareFunction (a, b) {
    if (a < b) {
      return -1
    }
    if (a > b) {
      return 1
    }
    return 0
  }

  function deterministicStringify (obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
      options = defaultOptions();
    }

    var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(tmp, replacer, spacer);
      } else {
        res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
    } finally {
      // Ensure that we restore the object as it was.
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res
  }

  function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
      for (i = 0; i < stack.length; i++) {
        if (stack[i] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
          return
        }
      }
      try {
        if (typeof val.toJSON === 'function') {
          return
        }
      } catch (_) {
        return
      }

      if (
        typeof options.depthLimit !== 'undefined' &&
        depth > options.depthLimit
      ) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return
      }

      if (
        typeof options.edgesLimit !== 'undefined' &&
        edgeIndex + 1 > options.edgesLimit
      ) {
        setReplace(LIMIT_REPLACE_NODE, val, k, parent);
        return
      }

      stack.push(val);
      // Optimize for Arrays. Big arrays could kill the performance otherwise!
      if (Array.isArray(val)) {
        for (i = 0; i < val.length; i++) {
          deterministicDecirc(val[i], i, i, stack, val, depth, options);
        }
      } else {
        // Create a temporary object in the required way
        var tmp = {};
        var keys = Object.keys(val).sort(compareFunction);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          deterministicDecirc(val[key], key, i, stack, val, depth, options);
          tmp[key] = val[key];
        }
        if (typeof parent !== 'undefined') {
          arr.push([parent, k, val]);
          parent[k] = tmp;
        } else {
          return tmp
        }
      }
      stack.pop();
    }
  }

  // wraps replacer function to handle values we couldn't replace
  // and mark them as replaced value
  function replaceGetterValues (replacer) {
    replacer =
      typeof replacer !== 'undefined'
        ? replacer
        : function (k, v) {
          return v
        };
    return function (key, val) {
      if (replacerStack.length > 0) {
        for (var i = 0; i < replacerStack.length; i++) {
          var part = replacerStack[i];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i, 1);
            break
          }
        }
      }
      return replacer.call(this, key, val)
    }
  }

  Object.defineProperty(classes, "__esModule", { value: true });
  classes.EthereumProviderError = classes.EthereumRpcError = void 0;
  const fast_safe_stringify_1 = fastSafeStringify;
  /**
   * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
   * per EIP-1474.
   * Permits any integer error code.
   */
  class EthereumRpcError extends Error {
      constructor(code, message, data) {
          if (!Number.isInteger(code)) {
              throw new Error('"code" must be an integer.');
          }
          if (!message || typeof message !== 'string') {
              throw new Error('"message" must be a nonempty string.');
          }
          super(message);
          this.code = code;
          if (data !== undefined) {
              this.data = data;
          }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
          const serialized = {
              code: this.code,
              message: this.message,
          };
          if (this.data !== undefined) {
              serialized.data = this.data;
          }
          if (this.stack) {
              serialized.stack = this.stack;
          }
          return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
          return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
  }
  classes.EthereumRpcError = EthereumRpcError;
  /**
   * Error subclass implementing Ethereum Provider errors per EIP-1193.
   * Permits integer error codes in the [ 1000 <= 4999 ] range.
   */
  class EthereumProviderError extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code, message, data) {
          if (!isValidEthProviderCode(code)) {
              throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
          }
          super(code, message, data);
      }
  }
  classes.EthereumProviderError = EthereumProviderError;
  // Internal
  function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1000 && code <= 4999;
  }
  function stringifyReplacer(_, value) {
      if (value === '[Circular]') {
          return undefined;
      }
      return value;
  }

  var utils$1 = {};

  var errorConstants = {};

  Object.defineProperty(errorConstants, "__esModule", { value: true });
  errorConstants.errorValues = errorConstants.errorCodes = void 0;
  errorConstants.errorCodes = {
      rpc: {
          invalidInput: -32000,
          resourceNotFound: -32001,
          resourceUnavailable: -32002,
          transactionRejected: -32003,
          methodNotSupported: -32004,
          limitExceeded: -32005,
          parse: -32700,
          invalidRequest: -32600,
          methodNotFound: -32601,
          invalidParams: -32602,
          internal: -32603,
      },
      provider: {
          userRejectedRequest: 4001,
          unauthorized: 4100,
          unsupportedMethod: 4200,
          disconnected: 4900,
          chainDisconnected: 4901,
      },
  };
  errorConstants.errorValues = {
      '-32700': {
          standard: 'JSON RPC 2.0',
          message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
      },
      '-32600': {
          standard: 'JSON RPC 2.0',
          message: 'The JSON sent is not a valid Request object.',
      },
      '-32601': {
          standard: 'JSON RPC 2.0',
          message: 'The method does not exist / is not available.',
      },
      '-32602': {
          standard: 'JSON RPC 2.0',
          message: 'Invalid method parameter(s).',
      },
      '-32603': {
          standard: 'JSON RPC 2.0',
          message: 'Internal JSON-RPC error.',
      },
      '-32000': {
          standard: 'EIP-1474',
          message: 'Invalid input.',
      },
      '-32001': {
          standard: 'EIP-1474',
          message: 'Resource not found.',
      },
      '-32002': {
          standard: 'EIP-1474',
          message: 'Resource unavailable.',
      },
      '-32003': {
          standard: 'EIP-1474',
          message: 'Transaction rejected.',
      },
      '-32004': {
          standard: 'EIP-1474',
          message: 'Method not supported.',
      },
      '-32005': {
          standard: 'EIP-1474',
          message: 'Request limit exceeded.',
      },
      '4001': {
          standard: 'EIP-1193',
          message: 'User rejected the request.',
      },
      '4100': {
          standard: 'EIP-1193',
          message: 'The requested account and/or method has not been authorized by the user.',
      },
      '4200': {
          standard: 'EIP-1193',
          message: 'The requested method is not supported by this Ethereum provider.',
      },
      '4900': {
          standard: 'EIP-1193',
          message: 'The provider is disconnected from all chains.',
      },
      '4901': {
          standard: 'EIP-1193',
          message: 'The provider is disconnected from the specified chain.',
      },
  };

  (function (exports) {
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  	const error_constants_1 = errorConstants;
  	const classes_1 = classes;
  	const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
  	const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
  	const FALLBACK_ERROR = {
  	    code: FALLBACK_ERROR_CODE,
  	    message: getMessageFromCode(FALLBACK_ERROR_CODE),
  	};
  	exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
  	/**
  	 * Gets the message for a given code, or a fallback message if the code has
  	 * no corresponding message.
  	 */
  	function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  	    if (Number.isInteger(code)) {
  	        const codeString = code.toString();
  	        if (hasKey(error_constants_1.errorValues, codeString)) {
  	            return error_constants_1.errorValues[codeString].message;
  	        }
  	        if (isJsonRpcServerError(code)) {
  	            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
  	        }
  	    }
  	    return fallbackMessage;
  	}
  	exports.getMessageFromCode = getMessageFromCode;
  	/**
  	 * Returns whether the given code is valid.
  	 * A code is only valid if it has a message.
  	 */
  	function isValidCode(code) {
  	    if (!Number.isInteger(code)) {
  	        return false;
  	    }
  	    const codeString = code.toString();
  	    if (error_constants_1.errorValues[codeString]) {
  	        return true;
  	    }
  	    if (isJsonRpcServerError(code)) {
  	        return true;
  	    }
  	    return false;
  	}
  	exports.isValidCode = isValidCode;
  	/**
  	 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
  	 * Merely copies the given error's values if it is already compatible.
  	 * If the given error is not fully compatible, it will be preserved on the
  	 * returned object's data.originalError property.
  	 */
  	function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false, } = {}) {
  	    var _a, _b;
  	    if (!fallbackError ||
  	        !Number.isInteger(fallbackError.code) ||
  	        typeof fallbackError.message !== 'string') {
  	        throw new Error('Must provide fallback error with integer number code and string message.');
  	    }
  	    if (error instanceof classes_1.EthereumRpcError) {
  	        return error.serialize();
  	    }
  	    const serialized = {};
  	    if (error &&
  	        typeof error === 'object' &&
  	        !Array.isArray(error) &&
  	        hasKey(error, 'code') &&
  	        isValidCode(error.code)) {
  	        const _error = error;
  	        serialized.code = _error.code;
  	        if (_error.message && typeof _error.message === 'string') {
  	            serialized.message = _error.message;
  	            if (hasKey(_error, 'data')) {
  	                serialized.data = _error.data;
  	            }
  	        }
  	        else {
  	            serialized.message = getMessageFromCode(serialized.code);
  	            serialized.data = { originalError: assignOriginalError(error) };
  	        }
  	    }
  	    else {
  	        serialized.code = fallbackError.code;
  	        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
  	        serialized.message = (message && typeof message === 'string'
  	            ? message
  	            : fallbackError.message);
  	        serialized.data = { originalError: assignOriginalError(error) };
  	    }
  	    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
  	    if (shouldIncludeStack && error && stack && typeof stack === 'string') {
  	        serialized.stack = stack;
  	    }
  	    return serialized;
  	}
  	exports.serializeError = serializeError;
  	// Internal
  	function isJsonRpcServerError(code) {
  	    return code >= -32099 && code <= -32000;
  	}
  	function assignOriginalError(error) {
  	    if (error && typeof error === 'object' && !Array.isArray(error)) {
  	        return Object.assign({}, error);
  	    }
  	    return error;
  	}
  	function hasKey(obj, key) {
  	    return Object.prototype.hasOwnProperty.call(obj, key);
  	}
  	
  } (utils$1));

  var errors = {};

  Object.defineProperty(errors, "__esModule", { value: true });
  errors.ethErrors = void 0;
  const classes_1 = classes;
  const utils_1$3 = utils$1;
  const error_constants_1 = errorConstants;
  errors.ethErrors = {
      rpc: {
          /**
           * Get a JSON RPC 2.0 Parse (-32700) error.
           */
          parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
          /**
           * Get a JSON RPC 2.0 Invalid Request (-32600) error.
           */
          invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
          /**
           * Get a JSON RPC 2.0 Invalid Params (-32602) error.
           */
          invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
          /**
           * Get a JSON RPC 2.0 Method Not Found (-32601) error.
           */
          methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
          /**
           * Get a JSON RPC 2.0 Internal (-32603) error.
           */
          internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
          /**
           * Get a JSON RPC 2.0 Server error.
           * Permits integer error codes in the [ -32099 <= -32005 ] range.
           * Codes -32000 through -32004 are reserved by EIP-1474.
           */
          server: (opts) => {
              if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                  throw new Error('Ethereum RPC Server errors must provide single object argument.');
              }
              const { code } = opts;
              if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                  throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
              }
              return getEthJsonRpcError(code, opts);
          },
          /**
           * Get an Ethereum JSON RPC Invalid Input (-32000) error.
           */
          invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
          /**
           * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
           */
          resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
          /**
           * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
           */
          resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
          /**
           * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
           */
          transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
          /**
           * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
           */
          methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
          /**
           * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
           */
          limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),
      },
      provider: {
          /**
           * Get an Ethereum Provider User Rejected Request (4001) error.
           */
          userRejectedRequest: (arg) => {
              return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
          },
          /**
           * Get an Ethereum Provider Unauthorized (4100) error.
           */
          unauthorized: (arg) => {
              return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
          },
          /**
           * Get an Ethereum Provider Unsupported Method (4200) error.
           */
          unsupportedMethod: (arg) => {
              return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
          },
          /**
           * Get an Ethereum Provider Not Connected (4900) error.
           */
          disconnected: (arg) => {
              return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
          },
          /**
           * Get an Ethereum Provider Chain Not Connected (4901) error.
           */
          chainDisconnected: (arg) => {
              return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
          },
          /**
           * Get a custom Ethereum Provider error.
           */
          custom: (opts) => {
              if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                  throw new Error('Ethereum Provider custom errors must provide single object argument.');
              }
              const { code, message, data } = opts;
              if (!message || typeof message !== 'string') {
                  throw new Error('"message" must be a nonempty string');
              }
              return new classes_1.EthereumProviderError(code, message, data);
          },
      },
  };
  // Internal
  function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1$3.getMessageFromCode(code), data);
  }
  function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1$3.getMessageFromCode(code), data);
  }
  function parseOpts(arg) {
      if (arg) {
          if (typeof arg === 'string') {
              return [arg];
          }
          else if (typeof arg === 'object' && !Array.isArray(arg)) {
              const { message, data } = arg;
              if (message && typeof message !== 'string') {
                  throw new Error('Must specify string message.');
              }
              return [message || undefined, data];
          }
      }
      return [];
  }

  (function (exports) {
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
  	const classes_1 = classes;
  	Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function () { return classes_1.EthereumRpcError; } });
  	Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function () { return classes_1.EthereumProviderError; } });
  	const utils_1 = utils$1;
  	Object.defineProperty(exports, "serializeError", { enumerable: true, get: function () { return utils_1.serializeError; } });
  	Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function () { return utils_1.getMessageFromCode; } });
  	const errors_1 = errors;
  	Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function () { return errors_1.ethErrors; } });
  	const error_constants_1 = errorConstants;
  	Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function () { return error_constants_1.errorCodes; } });
  	
  } (dist$5));

  var siteMetadata = {};

  var messages$1 = {};

  Object.defineProperty(messages$1, "__esModule", { value: true });
  const messages = {
      errors: {
          disconnected: () => 'MetaMask: Disconnected from chain. Attempting to connect.',
          permanentlyDisconnected: () => 'MetaMask: Disconnected from MetaMask background. Page reload required.',
          sendSiteMetadata: () => `MetaMask: Failed to send site metadata. This is an internal error, please report this bug.`,
          unsupportedSync: (method) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
          invalidDuplexStream: () => 'Must provide a Node.js-style duplex stream.',
          invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
          invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
          invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
          invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
          invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`,
      },
      info: {
          connected: (chainId) => `MetaMask: Connected to chain with ID "${chainId}".`,
      },
      warnings: {
          // deprecated methods
          enableDeprecation: `MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102`,
          sendDeprecation: `MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193`,
          // deprecated events
          events: {
              close: `MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect`,
              data: `MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
              networkChanged: `MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged`,
              notification: `MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message`,
          },
          // misc
          experimentalMethods: `MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning.`,
      },
  };
  messages$1.default = messages;

  var utils = {};

  Object.defineProperty(utils, "__esModule", { value: true });
  utils.EMITTED_NOTIFICATIONS = utils.NOOP = utils.logStreamDisconnectWarning = utils.getRpcPromiseCallback = utils.createErrorMiddleware = void 0;
  const eth_rpc_errors_1$3 = dist$5;
  // utility functions
  /**
   * json-rpc-engine middleware that logs RPC errors and and validates req.method.
   *
   * @param log - The logging API to use.
   * @returns  json-rpc-engine middleware function
   */
  function createErrorMiddleware(log) {
      return (req, res, next) => {
          // json-rpc-engine will terminate the request when it notices this error
          if (typeof req.method !== 'string' || !req.method) {
              res.error = eth_rpc_errors_1$3.ethErrors.rpc.invalidRequest({
                  message: `The request 'method' must be a non-empty string.`,
                  data: req,
              });
          }
          next((done) => {
              const { error } = res;
              if (!error) {
                  return done();
              }
              log.error(`MetaMask - RPC Error: ${error.message}`, error);
              return done();
          });
      };
  }
  utils.createErrorMiddleware = createErrorMiddleware;
  // resolve response.result or response, reject errors
  const getRpcPromiseCallback = (resolve, reject, unwrapResult = true) => (error, response) => {
      if (error || response.error) {
          reject(error || response.error);
      }
      else {
          !unwrapResult || Array.isArray(response)
              ? resolve(response)
              : resolve(response.result);
      }
  };
  utils.getRpcPromiseCallback = getRpcPromiseCallback;
  /**
   * Logs a stream disconnection error. Emits an 'error' if given an
   * EventEmitter that has listeners for the 'error' event.
   *
   * @param log - The logging API to use.
   * @param remoteLabel - The label of the disconnected stream.
   * @param error - The associated error to log.
   * @param emitter - The logging API to use.
   */
  function logStreamDisconnectWarning$1(log, remoteLabel, error, emitter) {
      let warningMsg = `MetaMask: Lost connection to "${remoteLabel}".`;
      if (error === null || error === void 0 ? void 0 : error.stack) {
          warningMsg += `\n${error.stack}`;
      }
      log.warn(warningMsg);
      if (emitter && emitter.listenerCount('error') > 0) {
          emitter.emit('error', warningMsg);
      }
  }
  utils.logStreamDisconnectWarning = logStreamDisconnectWarning$1;
  const NOOP = () => undefined;
  utils.NOOP = NOOP;
  // constants
  utils.EMITTED_NOTIFICATIONS = [
      'eth_subscription', // per eth-json-rpc-filters/subscriptionManager
  ];

  var __importDefault$a = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(siteMetadata, "__esModule", { value: true });
  const messages_1$2 = __importDefault$a(messages$1);
  const utils_1$2 = utils;
  /**
   * Sends site metadata over an RPC request.
   *
   * @param engine - The JSON RPC Engine to send metadata over.
   * @param log - The logging API to use.
   */
  async function sendSiteMetadata(engine, log) {
      try {
          const domainMetadata = await getSiteMetadata();
          // call engine.handle directly to avoid normal RPC request handling
          engine.handle({
              jsonrpc: '2.0',
              id: 1,
              method: 'metamask_sendDomainMetadata',
              params: domainMetadata,
          }, utils_1$2.NOOP);
      }
      catch (error) {
          log.error({
              message: messages_1$2.default.errors.sendSiteMetadata(),
              originalError: error,
          });
      }
  }
  siteMetadata.default = sendSiteMetadata;
  /**
   * Gets site metadata and returns it
   *
   */
  async function getSiteMetadata() {
      return {
          name: getSiteName(window),
          icon: await getSiteIcon(window),
      };
  }
  /**
   * Extracts a name for the site from the DOM
   */
  function getSiteName(windowObject) {
      const { document } = windowObject;
      const siteName = document.querySelector('head > meta[property="og:site_name"]');
      if (siteName) {
          return siteName.content;
      }
      const metaTitle = document.querySelector('head > meta[name="title"]');
      if (metaTitle) {
          return metaTitle.content;
      }
      if (document.title && document.title.length > 0) {
          return document.title;
      }
      return window.location.hostname;
  }
  /**
   * Extracts an icon for the site from the DOM
   * @returns an icon URL
   */
  async function getSiteIcon(windowObject) {
      const { document } = windowObject;
      const icons = document.querySelectorAll('head > link[rel~="icon"]');
      for (const icon of icons) {
          if (icon && (await imgExists(icon.href))) {
              return icon.href;
          }
      }
      return null;
  }
  /**
   * Returns whether the given image URL exists
   * @param url - the url of the image
   * @returns Whether the image exists.
   */
  function imgExists(url) {
      return new Promise((resolve, reject) => {
          try {
              const img = document.createElement('img');
              img.onload = () => resolve(true);
              img.onerror = () => resolve(false);
              img.src = url;
          }
          catch (e) {
              reject(e);
          }
      });
  }

  var BaseProvider$1 = {};

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick$1(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser$3 = true;
  var env$1 = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop$5() {}

  var on = noop$5;
  var addListener = noop$5;
  var once$5 = noop$5;
  var off = noop$5;
  var removeListener = noop$5;
  var removeAllListeners = noop$5;
  var emit = noop$5;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1$1 = {
    nextTick: nextTick$1,
    title: title,
    browser: browser$3,
    env: env$1,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once$5,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var once$4 = {exports: {}};

  // Returns a wrapper function that returns a wrapped callback
  // The wrapper function should do some stuff, and return a
  // presumably different callback function.
  // This makes sure that own properties are retained, so that
  // decorations and such are not lost along the way.
  var wrappy_1 = wrappy$1;
  function wrappy$1 (fn, cb) {
    if (fn && cb) return wrappy$1(fn)(cb)

    if (typeof fn !== 'function')
      throw new TypeError('need wrapper function')

    Object.keys(fn).forEach(function (k) {
      wrapper[k] = fn[k];
    });

    return wrapper

    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb = args[args.length-1];
      if (typeof ret === 'function' && ret !== cb) {
        Object.keys(cb).forEach(function (k) {
          ret[k] = cb[k];
        });
      }
      return ret
    }
  }

  var wrappy = wrappy_1;
  once$4.exports = wrappy(once$3);
  once$4.exports.strict = wrappy(onceStrict);

  once$3.proto = once$3(function () {
    Object.defineProperty(Function.prototype, 'once', {
      value: function () {
        return once$3(this)
      },
      configurable: true
    });

    Object.defineProperty(Function.prototype, 'onceStrict', {
      value: function () {
        return onceStrict(this)
      },
      configurable: true
    });
  });

  function once$3 (fn) {
    var f = function () {
      if (f.called) return f.value
      f.called = true;
      return f.value = fn.apply(this, arguments)
    };
    f.called = false;
    return f
  }

  function onceStrict (fn) {
    var f = function () {
      if (f.called)
        throw new Error(f.onceError)
      f.called = true;
      return f.value = fn.apply(this, arguments)
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f
  }

  var once$2 = once$4.exports;

  var noop$4 = function() {};

  var isRequest$1 = function(stream) {
  	return stream.setHeader && typeof stream.abort === 'function';
  };

  var isChildProcess = function(stream) {
  	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
  };

  var eos$1 = function(stream, opts, callback) {
  	if (typeof opts === 'function') return eos$1(stream, null, opts);
  	if (!opts) opts = {};

  	callback = once$2(callback || noop$4);

  	var ws = stream._writableState;
  	var rs = stream._readableState;
  	var readable = opts.readable || (opts.readable !== false && stream.readable);
  	var writable = opts.writable || (opts.writable !== false && stream.writable);
  	var cancelled = false;

  	var onlegacyfinish = function() {
  		if (!stream.writable) onfinish();
  	};

  	var onfinish = function() {
  		writable = false;
  		if (!readable) callback.call(stream);
  	};

  	var onend = function() {
  		readable = false;
  		if (!writable) callback.call(stream);
  	};

  	var onexit = function(exitCode) {
  		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  	};

  	var onerror = function(err) {
  		callback.call(stream, err);
  	};

  	var onclose = function() {
  		browser$1$1.nextTick(onclosenexttick);
  	};

  	var onclosenexttick = function() {
  		if (cancelled) return;
  		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
  		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
  	};

  	var onrequest = function() {
  		stream.req.on('finish', onfinish);
  	};

  	if (isRequest$1(stream)) {
  		stream.on('complete', onfinish);
  		stream.on('abort', onclose);
  		if (stream.req) onrequest();
  		else stream.on('request', onrequest);
  	} else if (writable && !ws) { // legacy streams
  		stream.on('end', onlegacyfinish);
  		stream.on('close', onlegacyfinish);
  	}

  	if (isChildProcess(stream)) stream.on('exit', onexit);

  	stream.on('end', onend);
  	stream.on('finish', onfinish);
  	if (opts.error !== false) stream.on('error', onerror);
  	stream.on('close', onclose);

  	return function() {
  		cancelled = true;
  		stream.removeListener('complete', onfinish);
  		stream.removeListener('abort', onclose);
  		stream.removeListener('request', onrequest);
  		if (stream.req) stream.req.removeListener('finish', onfinish);
  		stream.removeListener('end', onlegacyfinish);
  		stream.removeListener('close', onlegacyfinish);
  		stream.removeListener('finish', onfinish);
  		stream.removeListener('exit', onexit);
  		stream.removeListener('end', onend);
  		stream.removeListener('error', onerror);
  		stream.removeListener('close', onclose);
  	};
  };

  var endOfStream$1 = eos$1;

  var _polyfillNode_fs = {};

  var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _polyfillNode_fs
  });

  var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

  var once$1 = once$4.exports;
  var eos = endOfStream$1;
  var fs = require$$2$1; // we only need fs to get the ReadStream and WriteStream prototypes

  var noop$3 = function () {};
  var ancient = /^v?\.0/.test(browser$1$1.version);

  var isFn = function (fn) {
    return typeof fn === 'function'
  };

  var isFS = function (stream) {
    if (!ancient) return false // newer node version do not need to care about fs is a special way
    if (!fs) return false // browser
    return (stream instanceof (fs.ReadStream || noop$3) || stream instanceof (fs.WriteStream || noop$3)) && isFn(stream.close)
  };

  var isRequest = function (stream) {
    return stream.setHeader && isFn(stream.abort)
  };

  var destroyer = function (stream, reading, writing, callback) {
    callback = once$1(callback);

    var closed = false;
    stream.on('close', function () {
      closed = true;
    });

    eos(stream, {readable: reading, writable: writing}, function (err) {
      if (err) return callback(err)
      closed = true;
      callback();
    });

    var destroyed = false;
    return function (err) {
      if (closed) return
      if (destroyed) return
      destroyed = true;

      if (isFS(stream)) return stream.close(noop$3) // use close for fs streams to avoid fd leaks
      if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

      if (isFn(stream.destroy)) return stream.destroy()

      callback(err || new Error('stream was destroyed'));
    }
  };

  var call = function (fn) {
    fn();
  };

  var pipe = function (from, to) {
    return from.pipe(to)
  };

  var pump = function () {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop$3) && streams.pop() || noop$3;

    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error('pump requires two streams per minimum')

    var error;
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return
        destroys.forEach(call);
        callback(error);
      })
    });

    return streams.reduce(pipe)
  };

  var pump_1$1 = pump;

  var dist$4 = {};

  var idRemapMiddleware = {};

  var getUniqueId$1 = {};

  Object.defineProperty(getUniqueId$1, "__esModule", { value: true });
  getUniqueId$1.getUniqueId = void 0;
  // uint32 (two's complement) max
  // more conservative than Number.MAX_SAFE_INTEGER
  const MAX = 4294967295;
  let idCounter = Math.floor(Math.random() * MAX);
  function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
  }
  getUniqueId$1.getUniqueId = getUniqueId;

  Object.defineProperty(idRemapMiddleware, "__esModule", { value: true });
  idRemapMiddleware.createIdRemapMiddleware = void 0;
  const getUniqueId_1 = getUniqueId$1;
  function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
          const originalId = req.id;
          const newId = getUniqueId_1.getUniqueId();
          req.id = newId;
          res.id = newId;
          next((done) => {
              req.id = originalId;
              res.id = originalId;
              done();
          });
      };
  }
  idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;

  var createAsyncMiddleware$1 = {};

  Object.defineProperty(createAsyncMiddleware$1, "__esModule", { value: true });
  createAsyncMiddleware$1.createAsyncMiddleware = void 0;
  /**
   * JsonRpcEngine only accepts callback-based middleware directly.
   * createAsyncMiddleware exists to enable consumers to pass in async middleware
   * functions.
   *
   * Async middleware have no "end" function. Instead, they "end" if they return
   * without calling "next". Rather than passing in explicit return handlers,
   * async middleware can simply await "next", and perform operations on the
   * response object when execution resumes.
   *
   * To accomplish this, createAsyncMiddleware passes the async middleware a
   * wrapped "next" function. That function calls the internal JsonRpcEngine
   * "next" function with a return handler that resolves a promise when called.
   *
   * The return handler will always be called. Its resolution of the promise
   * enables the control flow described above.
   */
  function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
          // nextPromise is the key to the implementation
          // it is resolved by the return handler passed to the
          // "next" function
          let resolveNextPromise;
          const nextPromise = new Promise((resolve) => {
              resolveNextPromise = resolve;
          });
          let returnHandlerCallback = null;
          let nextWasCalled = false;
          // This will be called by the consumer's async middleware.
          const asyncNext = async () => {
              nextWasCalled = true;
              // We pass a return handler to next(). When it is called by the engine,
              // the consumer's async middleware will resume executing.
              // eslint-disable-next-line node/callback-return
              next((runReturnHandlersCallback) => {
                  // This callback comes from JsonRpcEngine._runReturnHandlers
                  returnHandlerCallback = runReturnHandlersCallback;
                  resolveNextPromise();
              });
              await nextPromise;
          };
          try {
              await asyncMiddleware(req, res, asyncNext);
              if (nextWasCalled) {
                  await nextPromise; // we must wait until the return handler is called
                  returnHandlerCallback(null);
              }
              else {
                  end(null);
              }
          }
          catch (error) {
              if (returnHandlerCallback) {
                  returnHandlerCallback(error);
              }
              else {
                  end(error);
              }
          }
      };
  }
  createAsyncMiddleware$1.createAsyncMiddleware = createAsyncMiddleware;

  var createScaffoldMiddleware$1 = {};

  Object.defineProperty(createScaffoldMiddleware$1, "__esModule", { value: true });
  createScaffoldMiddleware$1.createScaffoldMiddleware = void 0;
  function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
          const handler = handlers[req.method];
          // if no handler, return
          if (handler === undefined) {
              return next();
          }
          // if handler is fn, call as middleware
          if (typeof handler === 'function') {
              return handler(req, res, next, end);
          }
          // if handler is some other value, use as result
          res.result = handler;
          return end();
      };
  }
  createScaffoldMiddleware$1.createScaffoldMiddleware = createScaffoldMiddleware;

  var JsonRpcEngine$1 = {};

  var safeEventEmitter = {};

  var domain$1;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.usingDomains = false;

  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain$1.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone$1(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone$1(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone$1(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone$1(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone$1(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = (type === 'error');

    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler)
      return false;

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] :
                                            [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + type + ' listeners added. ' +
                              'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');

        events = this._events;
        if (!events)
          return this;

        list = events[type];
        if (!list)
          return this;

        if (list === listener || (list.listener && list.listener === listener)) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length; i-- > 0;) {
            if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (list.length === 1) {
            list[0] = undefined;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }

          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };
      
  // Alias for removeListener added in NodeJS 10.0
  // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
  EventEmitter.prototype.off = function(type, listener){
      return this.removeListener(type, listener);
  };

  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events;

        events = this._events;
        if (!events)
          return this;

        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i = 0, key; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          do {
            this.removeListener(type, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }

        return this;
      };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === 'function')
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }

    return ret;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }

  function arrayClone$1(arr, i) {
    var copy = new Array(i);
    while (i--)
      copy[i] = arr[i];
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  var _polyfillNode_events = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': EventEmitter,
    EventEmitter: EventEmitter
  });

  var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

  Object.defineProperty(safeEventEmitter, "__esModule", { value: true });
  const events_1 = require$$2;
  function safeApply(handler, context, args) {
      try {
          Reflect.apply(handler, context, args);
      }
      catch (err) {
          // Throw error after timeout so as not to interrupt the stack
          setTimeout(() => {
              throw err;
          });
      }
  }
  function arrayClone(arr) {
      const n = arr.length;
      const copy = new Array(n);
      for (let i = 0; i < n; i += 1) {
          copy[i] = arr[i];
      }
      return copy;
  }
  class SafeEventEmitter extends events_1.EventEmitter {
      emit(type, ...args) {
          let doError = type === 'error';
          const events = this._events;
          if (events !== undefined) {
              doError = doError && events.error === undefined;
          }
          else if (!doError) {
              return false;
          }
          // If there is no 'error' event listener then throw.
          if (doError) {
              let er;
              if (args.length > 0) {
                  [er] = args;
              }
              if (er instanceof Error) {
                  // Note: The comments on the `throw` lines are intentional, they show
                  // up in Node's output if this results in an unhandled exception.
                  throw er; // Unhandled 'error' event
              }
              // At least give some kind of context to the user
              const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
              err.context = er;
              throw err; // Unhandled 'error' event
          }
          const handler = events[type];
          if (handler === undefined) {
              return false;
          }
          if (typeof handler === 'function') {
              safeApply(handler, this, args);
          }
          else {
              const len = handler.length;
              const listeners = arrayClone(handler);
              for (let i = 0; i < len; i += 1) {
                  safeApply(listeners[i], this, args);
              }
          }
          return true;
      }
  }
  safeEventEmitter.default = SafeEventEmitter;

  var __importDefault$9 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(JsonRpcEngine$1, "__esModule", { value: true });
  JsonRpcEngine$1.JsonRpcEngine = void 0;
  const safe_event_emitter_1$2 = __importDefault$9(safeEventEmitter);
  const eth_rpc_errors_1$2 = dist$5;
  /**
   * A JSON-RPC request and response processor.
   * Give it a stack of middleware, pass it requests, and get back responses.
   */
  class JsonRpcEngine extends safe_event_emitter_1$2.default {
      constructor() {
          super();
          this._middleware = [];
      }
      /**
       * Add a middleware function to the engine's middleware stack.
       *
       * @param middleware - The middleware function to add.
       */
      push(middleware) {
          this._middleware.push(middleware);
      }
      handle(req, cb) {
          if (cb && typeof cb !== 'function') {
              throw new Error('"callback" must be a function if provided.');
          }
          if (Array.isArray(req)) {
              if (cb) {
                  return this._handleBatch(req, cb);
              }
              return this._handleBatch(req);
          }
          if (cb) {
              return this._handle(req, cb);
          }
          return this._promiseHandle(req);
      }
      /**
       * Returns this engine as a middleware function that can be pushed to other
       * engines.
       *
       * @returns This engine as a middleware function.
       */
      asMiddleware() {
          return async (req, res, next, end) => {
              try {
                  const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
                  if (isComplete) {
                      await JsonRpcEngine._runReturnHandlers(returnHandlers);
                      return end(middlewareError);
                  }
                  return next(async (handlerCallback) => {
                      try {
                          await JsonRpcEngine._runReturnHandlers(returnHandlers);
                      }
                      catch (error) {
                          return handlerCallback(error);
                      }
                      return handlerCallback();
                  });
              }
              catch (error) {
                  return end(error);
              }
          };
      }
      async _handleBatch(reqs, cb) {
          // The order here is important
          try {
              // 2. Wait for all requests to finish, or throw on some kind of fatal
              // error
              const responses = await Promise.all(
              // 1. Begin executing each request in the order received
              reqs.map(this._promiseHandle.bind(this)));
              // 3. Return batch response
              if (cb) {
                  return cb(null, responses);
              }
              return responses;
          }
          catch (error) {
              if (cb) {
                  return cb(error);
              }
              throw error;
          }
      }
      /**
       * A promise-wrapped _handle.
       */
      _promiseHandle(req) {
          return new Promise((resolve) => {
              this._handle(req, (_err, res) => {
                  // There will always be a response, and it will always have any error
                  // that is caught and propagated.
                  resolve(res);
              });
          });
      }
      /**
       * Ensures that the request object is valid, processes it, and passes any
       * error and the response object to the given callback.
       *
       * Does not reject.
       */
      async _handle(callerReq, cb) {
          if (!callerReq ||
              Array.isArray(callerReq) ||
              typeof callerReq !== 'object') {
              const error = new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
              return cb(error, { id: undefined, jsonrpc: '2.0', error });
          }
          if (typeof callerReq.method !== 'string') {
              const error = new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
              return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
          }
          const req = Object.assign({}, callerReq);
          const res = {
              id: req.id,
              jsonrpc: req.jsonrpc,
          };
          let error = null;
          try {
              await this._processRequest(req, res);
          }
          catch (_error) {
              // A request handler error, a re-thrown middleware error, or something
              // unexpected.
              error = _error;
          }
          if (error) {
              // Ensure no result is present on an errored response
              delete res.result;
              if (!res.error) {
                  res.error = eth_rpc_errors_1$2.serializeError(error);
              }
          }
          return cb(error, res);
      }
      /**
       * For the given request and response, runs all middleware and their return
       * handlers, if any, and ensures that internal request processing semantics
       * are satisfied.
       */
      async _processRequest(req, res) {
          const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
          // Throw if "end" was not called, or if the response has neither a result
          // nor an error.
          JsonRpcEngine._checkForCompletion(req, res, isComplete);
          // The return handlers should run even if an error was encountered during
          // middleware processing.
          await JsonRpcEngine._runReturnHandlers(returnHandlers);
          // Now we re-throw the middleware processing error, if any, to catch it
          // further up the call chain.
          if (error) {
              throw error;
          }
      }
      /**
       * Serially executes the given stack of middleware.
       *
       * @returns An array of any error encountered during middleware execution,
       * a boolean indicating whether the request was completed, and an array of
       * middleware-defined return handlers.
       */
      static async _runAllMiddleware(req, res, middlewareStack) {
          const returnHandlers = [];
          let error = null;
          let isComplete = false;
          // Go down stack of middleware, call and collect optional returnHandlers
          for (const middleware of middlewareStack) {
              [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
              if (isComplete) {
                  break;
              }
          }
          return [error, isComplete, returnHandlers.reverse()];
      }
      /**
       * Runs an individual middleware.
       *
       * @returns An array of any error encountered during middleware exection,
       * and a boolean indicating whether the request should end.
       */
      static _runMiddleware(req, res, middleware, returnHandlers) {
          return new Promise((resolve) => {
              const end = (err) => {
                  const error = err || res.error;
                  if (error) {
                      res.error = eth_rpc_errors_1$2.serializeError(error);
                  }
                  // True indicates that the request should end
                  resolve([error, true]);
              };
              const next = (returnHandler) => {
                  if (res.error) {
                      end(res.error);
                  }
                  else {
                      if (returnHandler) {
                          if (typeof returnHandler !== 'function') {
                              end(new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                  `Received "${typeof returnHandler}" for request:\n${jsonify(req)}`, { request: req }));
                          }
                          returnHandlers.push(returnHandler);
                      }
                      // False indicates that the request should not end
                      resolve([null, false]);
                  }
              };
              try {
                  middleware(req, res, next, end);
              }
              catch (error) {
                  end(error);
              }
          });
      }
      /**
       * Serially executes array of return handlers. The request and response are
       * assumed to be in their scope.
       */
      static async _runReturnHandlers(handlers) {
          for (const handler of handlers) {
              await new Promise((resolve, reject) => {
                  handler((err) => (err ? reject(err) : resolve()));
              });
          }
      }
      /**
       * Throws an error if the response has neither a result nor an error, or if
       * the "isComplete" flag is falsy.
       */
      static _checkForCompletion(req, res, isComplete) {
          if (!('result' in res) && !('error' in res)) {
              throw new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(req)}`, { request: req });
          }
          if (!isComplete) {
              throw new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(req)}`, { request: req });
          }
      }
  }
  JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
  function jsonify(request) {
      return JSON.stringify(request, null, 2);
  }

  var mergeMiddleware$1 = {};

  Object.defineProperty(mergeMiddleware$1, "__esModule", { value: true });
  mergeMiddleware$1.mergeMiddleware = void 0;
  const JsonRpcEngine_1 = JsonRpcEngine$1;
  function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
  }
  mergeMiddleware$1.mergeMiddleware = mergeMiddleware;

  (function (exports) {
  	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  	}) : (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    o[k2] = m[k];
  	}));
  	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
  	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	__exportStar(idRemapMiddleware, exports);
  	__exportStar(createAsyncMiddleware$1, exports);
  	__exportStar(createScaffoldMiddleware$1, exports);
  	__exportStar(getUniqueId$1, exports);
  	__exportStar(JsonRpcEngine$1, exports);
  	__exportStar(mergeMiddleware$1, exports);
  	
  } (dist$4));

  var dist$3 = {};

  var createEngineStream$1 = {};

  var readableBrowser$1 = {exports: {}};

  var processNextickArgs$1 = {exports: {}};

  var hasRequiredProcessNextickArgs;

  function requireProcessNextickArgs () {
  	if (hasRequiredProcessNextickArgs) return processNextickArgs$1.exports;
  	hasRequiredProcessNextickArgs = 1;

  	if (typeof browser$1$1 === 'undefined' ||
  	    !browser$1$1.version ||
  	    browser$1$1.version.indexOf('v0.') === 0 ||
  	    browser$1$1.version.indexOf('v1.') === 0 && browser$1$1.version.indexOf('v1.8.') !== 0) {
  	  processNextickArgs$1.exports = { nextTick: nextTick };
  	} else {
  	  processNextickArgs$1.exports = browser$1$1;
  	}

  	function nextTick(fn, arg1, arg2, arg3) {
  	  if (typeof fn !== 'function') {
  	    throw new TypeError('"callback" argument must be a function');
  	  }
  	  var len = arguments.length;
  	  var args, i;
  	  switch (len) {
  	  case 0:
  	  case 1:
  	    return browser$1$1.nextTick(fn);
  	  case 2:
  	    return browser$1$1.nextTick(function afterTickOne() {
  	      fn.call(null, arg1);
  	    });
  	  case 3:
  	    return browser$1$1.nextTick(function afterTickTwo() {
  	      fn.call(null, arg1, arg2);
  	    });
  	  case 4:
  	    return browser$1$1.nextTick(function afterTickThree() {
  	      fn.call(null, arg1, arg2, arg3);
  	    });
  	  default:
  	    args = new Array(len - 1);
  	    i = 0;
  	    while (i < args.length) {
  	      args[i++] = arguments[i];
  	    }
  	    return browser$1$1.nextTick(function afterTick() {
  	      fn.apply(null, args);
  	    });
  	  }
  	}
  	return processNextickArgs$1.exports;
  }

  var isarray;
  var hasRequiredIsarray;

  function requireIsarray () {
  	if (hasRequiredIsarray) return isarray;
  	hasRequiredIsarray = 1;
  	var toString = {}.toString;

  	isarray = Array.isArray || function (arr) {
  	  return toString.call(arr) == '[object Array]';
  	};
  	return isarray;
  }

  var streamBrowser$1;
  var hasRequiredStreamBrowser;

  function requireStreamBrowser () {
  	if (hasRequiredStreamBrowser) return streamBrowser$1;
  	hasRequiredStreamBrowser = 1;
  	streamBrowser$1 = require$$2.EventEmitter;
  	return streamBrowser$1;
  }

  var safeBuffer = {exports: {}};

  var buffer = {};

  var base64Js = {};

  base64Js.byteLength = byteLength$1;
  base64Js.toByteArray = toByteArray$1;
  base64Js.fromByteArray = fromByteArray$1;

  var lookup$1 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
    lookup$1[i$1] = code[i$1];
    revLookup$1[code.charCodeAt(i$1)] = i$1;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup$1['-'.charCodeAt(0)] = 62;
  revLookup$1['_'.charCodeAt(0)] = 63;

  function getLens (b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;

    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4);

    return [validLen, placeHoldersLen]
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength$1 (b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function toByteArray$1 (b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];

    var arr = new Arr$1(_byteLength(b64, validLen, placeHoldersLen));

    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen;

    var i;
    for (i = 0; i < len; i += 4) {
      tmp =
        (revLookup$1[b64.charCodeAt(i)] << 18) |
        (revLookup$1[b64.charCodeAt(i + 1)] << 12) |
        (revLookup$1[b64.charCodeAt(i + 2)] << 6) |
        revLookup$1[b64.charCodeAt(i + 3)];
      arr[curByte++] = (tmp >> 16) & 0xFF;
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp =
        (revLookup$1[b64.charCodeAt(i)] << 2) |
        (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp =
        (revLookup$1[b64.charCodeAt(i)] << 10) |
        (revLookup$1[b64.charCodeAt(i + 1)] << 4) |
        (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64$1 (num) {
    return lookup$1[num >> 18 & 0x3F] +
      lookup$1[num >> 12 & 0x3F] +
      lookup$1[num >> 6 & 0x3F] +
      lookup$1[num & 0x3F]
  }

  function encodeChunk$1 (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64$1(tmp));
    }
    return output.join('')
  }

  function fromByteArray$1 (uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 2] +
        lookup$1[(tmp << 4) & 0x3F] +
        '=='
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup$1[tmp >> 10] +
        lookup$1[(tmp >> 4) & 0x3F] +
        lookup$1[(tmp << 2) & 0x3F] +
        '='
      );
    }

    return parts.join('')
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  };

  ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */

  (function (exports) {

  	const base64 = base64Js;
  	const ieee754$1 = ieee754;
  	const customInspectSymbol =
  	  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
  	    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  	    : null;

  	exports.Buffer = Buffer;
  	exports.SlowBuffer = SlowBuffer;
  	exports.INSPECT_MAX_BYTES = 50;

  	const K_MAX_LENGTH = 0x7fffffff;
  	exports.kMaxLength = K_MAX_LENGTH;

  	/**
  	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
  	 *   === true    Use Uint8Array implementation (fastest)
  	 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
  	 *               implementation (most compatible, even IE6)
  	 *
  	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
  	 * Opera 11.6+, iOS 4.2+.
  	 *
  	 * We report that the browser does not support typed arrays if the are not subclassable
  	 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
  	 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
  	 * for __proto__ and has a buggy typed array implementation.
  	 */
  	Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  	if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
  	    typeof console.error === 'function') {
  	  console.error(
  	    'This browser lacks typed array (Uint8Array) support which is required by ' +
  	    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  	  );
  	}

  	function typedArraySupport () {
  	  // Can typed array instances can be augmented?
  	  try {
  	    const arr = new Uint8Array(1);
  	    const proto = { foo: function () { return 42 } };
  	    Object.setPrototypeOf(proto, Uint8Array.prototype);
  	    Object.setPrototypeOf(arr, proto);
  	    return arr.foo() === 42
  	  } catch (e) {
  	    return false
  	  }
  	}

  	Object.defineProperty(Buffer.prototype, 'parent', {
  	  enumerable: true,
  	  get: function () {
  	    if (!Buffer.isBuffer(this)) return undefined
  	    return this.buffer
  	  }
  	});

  	Object.defineProperty(Buffer.prototype, 'offset', {
  	  enumerable: true,
  	  get: function () {
  	    if (!Buffer.isBuffer(this)) return undefined
  	    return this.byteOffset
  	  }
  	});

  	function createBuffer (length) {
  	  if (length > K_MAX_LENGTH) {
  	    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  	  }
  	  // Return an augmented `Uint8Array` instance
  	  const buf = new Uint8Array(length);
  	  Object.setPrototypeOf(buf, Buffer.prototype);
  	  return buf
  	}

  	/**
  	 * The Buffer constructor returns instances of `Uint8Array` that have their
  	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
  	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
  	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
  	 * returns a single octet.
  	 *
  	 * The `Uint8Array` prototype remains unmodified.
  	 */

  	function Buffer (arg, encodingOrOffset, length) {
  	  // Common case.
  	  if (typeof arg === 'number') {
  	    if (typeof encodingOrOffset === 'string') {
  	      throw new TypeError(
  	        'The "string" argument must be of type string. Received type number'
  	      )
  	    }
  	    return allocUnsafe(arg)
  	  }
  	  return from(arg, encodingOrOffset, length)
  	}

  	Buffer.poolSize = 8192; // not used by this implementation

  	function from (value, encodingOrOffset, length) {
  	  if (typeof value === 'string') {
  	    return fromString(value, encodingOrOffset)
  	  }

  	  if (ArrayBuffer.isView(value)) {
  	    return fromArrayView(value)
  	  }

  	  if (value == null) {
  	    throw new TypeError(
  	      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
  	      'or Array-like Object. Received type ' + (typeof value)
  	    )
  	  }

  	  if (isInstance(value, ArrayBuffer) ||
  	      (value && isInstance(value.buffer, ArrayBuffer))) {
  	    return fromArrayBuffer(value, encodingOrOffset, length)
  	  }

  	  if (typeof SharedArrayBuffer !== 'undefined' &&
  	      (isInstance(value, SharedArrayBuffer) ||
  	      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
  	    return fromArrayBuffer(value, encodingOrOffset, length)
  	  }

  	  if (typeof value === 'number') {
  	    throw new TypeError(
  	      'The "value" argument must not be of type number. Received type number'
  	    )
  	  }

  	  const valueOf = value.valueOf && value.valueOf();
  	  if (valueOf != null && valueOf !== value) {
  	    return Buffer.from(valueOf, encodingOrOffset, length)
  	  }

  	  const b = fromObject(value);
  	  if (b) return b

  	  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
  	      typeof value[Symbol.toPrimitive] === 'function') {
  	    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  	  }

  	  throw new TypeError(
  	    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
  	    'or Array-like Object. Received type ' + (typeof value)
  	  )
  	}

  	/**
  	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
  	 * if value is a number.
  	 * Buffer.from(str[, encoding])
  	 * Buffer.from(array)
  	 * Buffer.from(buffer)
  	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
  	 **/
  	Buffer.from = function (value, encodingOrOffset, length) {
  	  return from(value, encodingOrOffset, length)
  	};

  	// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  	// https://github.com/feross/buffer/pull/148
  	Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  	Object.setPrototypeOf(Buffer, Uint8Array);

  	function assertSize (size) {
  	  if (typeof size !== 'number') {
  	    throw new TypeError('"size" argument must be of type number')
  	  } else if (size < 0) {
  	    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  	  }
  	}

  	function alloc (size, fill, encoding) {
  	  assertSize(size);
  	  if (size <= 0) {
  	    return createBuffer(size)
  	  }
  	  if (fill !== undefined) {
  	    // Only pay attention to encoding if it's a string. This
  	    // prevents accidentally sending in a number that would
  	    // be interpreted as a start offset.
  	    return typeof encoding === 'string'
  	      ? createBuffer(size).fill(fill, encoding)
  	      : createBuffer(size).fill(fill)
  	  }
  	  return createBuffer(size)
  	}

  	/**
  	 * Creates a new filled Buffer instance.
  	 * alloc(size[, fill[, encoding]])
  	 **/
  	Buffer.alloc = function (size, fill, encoding) {
  	  return alloc(size, fill, encoding)
  	};

  	function allocUnsafe (size) {
  	  assertSize(size);
  	  return createBuffer(size < 0 ? 0 : checked(size) | 0)
  	}

  	/**
  	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
  	 * */
  	Buffer.allocUnsafe = function (size) {
  	  return allocUnsafe(size)
  	};
  	/**
  	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
  	 */
  	Buffer.allocUnsafeSlow = function (size) {
  	  return allocUnsafe(size)
  	};

  	function fromString (string, encoding) {
  	  if (typeof encoding !== 'string' || encoding === '') {
  	    encoding = 'utf8';
  	  }

  	  if (!Buffer.isEncoding(encoding)) {
  	    throw new TypeError('Unknown encoding: ' + encoding)
  	  }

  	  const length = byteLength(string, encoding) | 0;
  	  let buf = createBuffer(length);

  	  const actual = buf.write(string, encoding);

  	  if (actual !== length) {
  	    // Writing a hex string, for example, that contains invalid characters will
  	    // cause everything after the first invalid character to be ignored. (e.g.
  	    // 'abxxcd' will be treated as 'ab')
  	    buf = buf.slice(0, actual);
  	  }

  	  return buf
  	}

  	function fromArrayLike (array) {
  	  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  	  const buf = createBuffer(length);
  	  for (let i = 0; i < length; i += 1) {
  	    buf[i] = array[i] & 255;
  	  }
  	  return buf
  	}

  	function fromArrayView (arrayView) {
  	  if (isInstance(arrayView, Uint8Array)) {
  	    const copy = new Uint8Array(arrayView);
  	    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  	  }
  	  return fromArrayLike(arrayView)
  	}

  	function fromArrayBuffer (array, byteOffset, length) {
  	  if (byteOffset < 0 || array.byteLength < byteOffset) {
  	    throw new RangeError('"offset" is outside of buffer bounds')
  	  }

  	  if (array.byteLength < byteOffset + (length || 0)) {
  	    throw new RangeError('"length" is outside of buffer bounds')
  	  }

  	  let buf;
  	  if (byteOffset === undefined && length === undefined) {
  	    buf = new Uint8Array(array);
  	  } else if (length === undefined) {
  	    buf = new Uint8Array(array, byteOffset);
  	  } else {
  	    buf = new Uint8Array(array, byteOffset, length);
  	  }

  	  // Return an augmented `Uint8Array` instance
  	  Object.setPrototypeOf(buf, Buffer.prototype);

  	  return buf
  	}

  	function fromObject (obj) {
  	  if (Buffer.isBuffer(obj)) {
  	    const len = checked(obj.length) | 0;
  	    const buf = createBuffer(len);

  	    if (buf.length === 0) {
  	      return buf
  	    }

  	    obj.copy(buf, 0, 0, len);
  	    return buf
  	  }

  	  if (obj.length !== undefined) {
  	    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
  	      return createBuffer(0)
  	    }
  	    return fromArrayLike(obj)
  	  }

  	  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
  	    return fromArrayLike(obj.data)
  	  }
  	}

  	function checked (length) {
  	  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  	  // length is NaN (which is otherwise coerced to zero.)
  	  if (length >= K_MAX_LENGTH) {
  	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
  	                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  	  }
  	  return length | 0
  	}

  	function SlowBuffer (length) {
  	  if (+length != length) { // eslint-disable-line eqeqeq
  	    length = 0;
  	  }
  	  return Buffer.alloc(+length)
  	}

  	Buffer.isBuffer = function isBuffer (b) {
  	  return b != null && b._isBuffer === true &&
  	    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  	};

  	Buffer.compare = function compare (a, b) {
  	  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  	  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
  	    throw new TypeError(
  	      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
  	    )
  	  }

  	  if (a === b) return 0

  	  let x = a.length;
  	  let y = b.length;

  	  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
  	    if (a[i] !== b[i]) {
  	      x = a[i];
  	      y = b[i];
  	      break
  	    }
  	  }

  	  if (x < y) return -1
  	  if (y < x) return 1
  	  return 0
  	};

  	Buffer.isEncoding = function isEncoding (encoding) {
  	  switch (String(encoding).toLowerCase()) {
  	    case 'hex':
  	    case 'utf8':
  	    case 'utf-8':
  	    case 'ascii':
  	    case 'latin1':
  	    case 'binary':
  	    case 'base64':
  	    case 'ucs2':
  	    case 'ucs-2':
  	    case 'utf16le':
  	    case 'utf-16le':
  	      return true
  	    default:
  	      return false
  	  }
  	};

  	Buffer.concat = function concat (list, length) {
  	  if (!Array.isArray(list)) {
  	    throw new TypeError('"list" argument must be an Array of Buffers')
  	  }

  	  if (list.length === 0) {
  	    return Buffer.alloc(0)
  	  }

  	  let i;
  	  if (length === undefined) {
  	    length = 0;
  	    for (i = 0; i < list.length; ++i) {
  	      length += list[i].length;
  	    }
  	  }

  	  const buffer = Buffer.allocUnsafe(length);
  	  let pos = 0;
  	  for (i = 0; i < list.length; ++i) {
  	    let buf = list[i];
  	    if (isInstance(buf, Uint8Array)) {
  	      if (pos + buf.length > buffer.length) {
  	        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
  	        buf.copy(buffer, pos);
  	      } else {
  	        Uint8Array.prototype.set.call(
  	          buffer,
  	          buf,
  	          pos
  	        );
  	      }
  	    } else if (!Buffer.isBuffer(buf)) {
  	      throw new TypeError('"list" argument must be an Array of Buffers')
  	    } else {
  	      buf.copy(buffer, pos);
  	    }
  	    pos += buf.length;
  	  }
  	  return buffer
  	};

  	function byteLength (string, encoding) {
  	  if (Buffer.isBuffer(string)) {
  	    return string.length
  	  }
  	  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
  	    return string.byteLength
  	  }
  	  if (typeof string !== 'string') {
  	    throw new TypeError(
  	      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
  	      'Received type ' + typeof string
  	    )
  	  }

  	  const len = string.length;
  	  const mustMatch = (arguments.length > 2 && arguments[2] === true);
  	  if (!mustMatch && len === 0) return 0

  	  // Use a for loop to avoid recursion
  	  let loweredCase = false;
  	  for (;;) {
  	    switch (encoding) {
  	      case 'ascii':
  	      case 'latin1':
  	      case 'binary':
  	        return len
  	      case 'utf8':
  	      case 'utf-8':
  	        return utf8ToBytes(string).length
  	      case 'ucs2':
  	      case 'ucs-2':
  	      case 'utf16le':
  	      case 'utf-16le':
  	        return len * 2
  	      case 'hex':
  	        return len >>> 1
  	      case 'base64':
  	        return base64ToBytes(string).length
  	      default:
  	        if (loweredCase) {
  	          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
  	        }
  	        encoding = ('' + encoding).toLowerCase();
  	        loweredCase = true;
  	    }
  	  }
  	}
  	Buffer.byteLength = byteLength;

  	function slowToString (encoding, start, end) {
  	  let loweredCase = false;

  	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  	  // property of a typed array.

  	  // This behaves neither like String nor Uint8Array in that we set start/end
  	  // to their upper/lower bounds if the value passed is out of range.
  	  // undefined is handled specially as per ECMA-262 6th Edition,
  	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  	  if (start === undefined || start < 0) {
  	    start = 0;
  	  }
  	  // Return early if start > this.length. Done here to prevent potential uint32
  	  // coercion fail below.
  	  if (start > this.length) {
  	    return ''
  	  }

  	  if (end === undefined || end > this.length) {
  	    end = this.length;
  	  }

  	  if (end <= 0) {
  	    return ''
  	  }

  	  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  	  end >>>= 0;
  	  start >>>= 0;

  	  if (end <= start) {
  	    return ''
  	  }

  	  if (!encoding) encoding = 'utf8';

  	  while (true) {
  	    switch (encoding) {
  	      case 'hex':
  	        return hexSlice(this, start, end)

  	      case 'utf8':
  	      case 'utf-8':
  	        return utf8Slice(this, start, end)

  	      case 'ascii':
  	        return asciiSlice(this, start, end)

  	      case 'latin1':
  	      case 'binary':
  	        return latin1Slice(this, start, end)

  	      case 'base64':
  	        return base64Slice(this, start, end)

  	      case 'ucs2':
  	      case 'ucs-2':
  	      case 'utf16le':
  	      case 'utf-16le':
  	        return utf16leSlice(this, start, end)

  	      default:
  	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
  	        encoding = (encoding + '').toLowerCase();
  	        loweredCase = true;
  	    }
  	  }
  	}

  	// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  	// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  	// reliably in a browserify context because there could be multiple different
  	// copies of the 'buffer' package in use. This method works even for Buffer
  	// instances that were created from another copy of the `buffer` package.
  	// See: https://github.com/feross/buffer/issues/154
  	Buffer.prototype._isBuffer = true;

  	function swap (b, n, m) {
  	  const i = b[n];
  	  b[n] = b[m];
  	  b[m] = i;
  	}

  	Buffer.prototype.swap16 = function swap16 () {
  	  const len = this.length;
  	  if (len % 2 !== 0) {
  	    throw new RangeError('Buffer size must be a multiple of 16-bits')
  	  }
  	  for (let i = 0; i < len; i += 2) {
  	    swap(this, i, i + 1);
  	  }
  	  return this
  	};

  	Buffer.prototype.swap32 = function swap32 () {
  	  const len = this.length;
  	  if (len % 4 !== 0) {
  	    throw new RangeError('Buffer size must be a multiple of 32-bits')
  	  }
  	  for (let i = 0; i < len; i += 4) {
  	    swap(this, i, i + 3);
  	    swap(this, i + 1, i + 2);
  	  }
  	  return this
  	};

  	Buffer.prototype.swap64 = function swap64 () {
  	  const len = this.length;
  	  if (len % 8 !== 0) {
  	    throw new RangeError('Buffer size must be a multiple of 64-bits')
  	  }
  	  for (let i = 0; i < len; i += 8) {
  	    swap(this, i, i + 7);
  	    swap(this, i + 1, i + 6);
  	    swap(this, i + 2, i + 5);
  	    swap(this, i + 3, i + 4);
  	  }
  	  return this
  	};

  	Buffer.prototype.toString = function toString () {
  	  const length = this.length;
  	  if (length === 0) return ''
  	  if (arguments.length === 0) return utf8Slice(this, 0, length)
  	  return slowToString.apply(this, arguments)
  	};

  	Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  	Buffer.prototype.equals = function equals (b) {
  	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  	  if (this === b) return true
  	  return Buffer.compare(this, b) === 0
  	};

  	Buffer.prototype.inspect = function inspect () {
  	  let str = '';
  	  const max = exports.INSPECT_MAX_BYTES;
  	  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  	  if (this.length > max) str += ' ... ';
  	  return '<Buffer ' + str + '>'
  	};
  	if (customInspectSymbol) {
  	  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  	}

  	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  	  if (isInstance(target, Uint8Array)) {
  	    target = Buffer.from(target, target.offset, target.byteLength);
  	  }
  	  if (!Buffer.isBuffer(target)) {
  	    throw new TypeError(
  	      'The "target" argument must be one of type Buffer or Uint8Array. ' +
  	      'Received type ' + (typeof target)
  	    )
  	  }

  	  if (start === undefined) {
  	    start = 0;
  	  }
  	  if (end === undefined) {
  	    end = target ? target.length : 0;
  	  }
  	  if (thisStart === undefined) {
  	    thisStart = 0;
  	  }
  	  if (thisEnd === undefined) {
  	    thisEnd = this.length;
  	  }

  	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
  	    throw new RangeError('out of range index')
  	  }

  	  if (thisStart >= thisEnd && start >= end) {
  	    return 0
  	  }
  	  if (thisStart >= thisEnd) {
  	    return -1
  	  }
  	  if (start >= end) {
  	    return 1
  	  }

  	  start >>>= 0;
  	  end >>>= 0;
  	  thisStart >>>= 0;
  	  thisEnd >>>= 0;

  	  if (this === target) return 0

  	  let x = thisEnd - thisStart;
  	  let y = end - start;
  	  const len = Math.min(x, y);

  	  const thisCopy = this.slice(thisStart, thisEnd);
  	  const targetCopy = target.slice(start, end);

  	  for (let i = 0; i < len; ++i) {
  	    if (thisCopy[i] !== targetCopy[i]) {
  	      x = thisCopy[i];
  	      y = targetCopy[i];
  	      break
  	    }
  	  }

  	  if (x < y) return -1
  	  if (y < x) return 1
  	  return 0
  	};

  	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  	//
  	// Arguments:
  	// - buffer - a Buffer to search
  	// - val - a string, Buffer, or number
  	// - byteOffset - an index into `buffer`; will be clamped to an int32
  	// - encoding - an optional encoding, relevant is val is a string
  	// - dir - true for indexOf, false for lastIndexOf
  	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  	  // Empty buffer means no match
  	  if (buffer.length === 0) return -1

  	  // Normalize byteOffset
  	  if (typeof byteOffset === 'string') {
  	    encoding = byteOffset;
  	    byteOffset = 0;
  	  } else if (byteOffset > 0x7fffffff) {
  	    byteOffset = 0x7fffffff;
  	  } else if (byteOffset < -0x80000000) {
  	    byteOffset = -0x80000000;
  	  }
  	  byteOffset = +byteOffset; // Coerce to Number.
  	  if (numberIsNaN(byteOffset)) {
  	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
  	    byteOffset = dir ? 0 : (buffer.length - 1);
  	  }

  	  // Normalize byteOffset: negative offsets start from the end of the buffer
  	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  	  if (byteOffset >= buffer.length) {
  	    if (dir) return -1
  	    else byteOffset = buffer.length - 1;
  	  } else if (byteOffset < 0) {
  	    if (dir) byteOffset = 0;
  	    else return -1
  	  }

  	  // Normalize val
  	  if (typeof val === 'string') {
  	    val = Buffer.from(val, encoding);
  	  }

  	  // Finally, search either indexOf (if dir is true) or lastIndexOf
  	  if (Buffer.isBuffer(val)) {
  	    // Special case: looking for empty string/buffer always fails
  	    if (val.length === 0) {
  	      return -1
  	    }
  	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  	  } else if (typeof val === 'number') {
  	    val = val & 0xFF; // Search for a byte value [0-255]
  	    if (typeof Uint8Array.prototype.indexOf === 'function') {
  	      if (dir) {
  	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
  	      } else {
  	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
  	      }
  	    }
  	    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  	  }

  	  throw new TypeError('val must be string, number or Buffer')
  	}

  	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  	  let indexSize = 1;
  	  let arrLength = arr.length;
  	  let valLength = val.length;

  	  if (encoding !== undefined) {
  	    encoding = String(encoding).toLowerCase();
  	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
  	        encoding === 'utf16le' || encoding === 'utf-16le') {
  	      if (arr.length < 2 || val.length < 2) {
  	        return -1
  	      }
  	      indexSize = 2;
  	      arrLength /= 2;
  	      valLength /= 2;
  	      byteOffset /= 2;
  	    }
  	  }

  	  function read (buf, i) {
  	    if (indexSize === 1) {
  	      return buf[i]
  	    } else {
  	      return buf.readUInt16BE(i * indexSize)
  	    }
  	  }

  	  let i;
  	  if (dir) {
  	    let foundIndex = -1;
  	    for (i = byteOffset; i < arrLength; i++) {
  	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
  	        if (foundIndex === -1) foundIndex = i;
  	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
  	      } else {
  	        if (foundIndex !== -1) i -= i - foundIndex;
  	        foundIndex = -1;
  	      }
  	    }
  	  } else {
  	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
  	    for (i = byteOffset; i >= 0; i--) {
  	      let found = true;
  	      for (let j = 0; j < valLength; j++) {
  	        if (read(arr, i + j) !== read(val, j)) {
  	          found = false;
  	          break
  	        }
  	      }
  	      if (found) return i
  	    }
  	  }

  	  return -1
  	}

  	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  	  return this.indexOf(val, byteOffset, encoding) !== -1
  	};

  	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  	};

  	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  	};

  	function hexWrite (buf, string, offset, length) {
  	  offset = Number(offset) || 0;
  	  const remaining = buf.length - offset;
  	  if (!length) {
  	    length = remaining;
  	  } else {
  	    length = Number(length);
  	    if (length > remaining) {
  	      length = remaining;
  	    }
  	  }

  	  const strLen = string.length;

  	  if (length > strLen / 2) {
  	    length = strLen / 2;
  	  }
  	  let i;
  	  for (i = 0; i < length; ++i) {
  	    const parsed = parseInt(string.substr(i * 2, 2), 16);
  	    if (numberIsNaN(parsed)) return i
  	    buf[offset + i] = parsed;
  	  }
  	  return i
  	}

  	function utf8Write (buf, string, offset, length) {
  	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  	}

  	function asciiWrite (buf, string, offset, length) {
  	  return blitBuffer(asciiToBytes(string), buf, offset, length)
  	}

  	function base64Write (buf, string, offset, length) {
  	  return blitBuffer(base64ToBytes(string), buf, offset, length)
  	}

  	function ucs2Write (buf, string, offset, length) {
  	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  	}

  	Buffer.prototype.write = function write (string, offset, length, encoding) {
  	  // Buffer#write(string)
  	  if (offset === undefined) {
  	    encoding = 'utf8';
  	    length = this.length;
  	    offset = 0;
  	  // Buffer#write(string, encoding)
  	  } else if (length === undefined && typeof offset === 'string') {
  	    encoding = offset;
  	    length = this.length;
  	    offset = 0;
  	  // Buffer#write(string, offset[, length][, encoding])
  	  } else if (isFinite(offset)) {
  	    offset = offset >>> 0;
  	    if (isFinite(length)) {
  	      length = length >>> 0;
  	      if (encoding === undefined) encoding = 'utf8';
  	    } else {
  	      encoding = length;
  	      length = undefined;
  	    }
  	  } else {
  	    throw new Error(
  	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
  	    )
  	  }

  	  const remaining = this.length - offset;
  	  if (length === undefined || length > remaining) length = remaining;

  	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
  	    throw new RangeError('Attempt to write outside buffer bounds')
  	  }

  	  if (!encoding) encoding = 'utf8';

  	  let loweredCase = false;
  	  for (;;) {
  	    switch (encoding) {
  	      case 'hex':
  	        return hexWrite(this, string, offset, length)

  	      case 'utf8':
  	      case 'utf-8':
  	        return utf8Write(this, string, offset, length)

  	      case 'ascii':
  	      case 'latin1':
  	      case 'binary':
  	        return asciiWrite(this, string, offset, length)

  	      case 'base64':
  	        // Warning: maxLength not taken into account in base64Write
  	        return base64Write(this, string, offset, length)

  	      case 'ucs2':
  	      case 'ucs-2':
  	      case 'utf16le':
  	      case 'utf-16le':
  	        return ucs2Write(this, string, offset, length)

  	      default:
  	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
  	        encoding = ('' + encoding).toLowerCase();
  	        loweredCase = true;
  	    }
  	  }
  	};

  	Buffer.prototype.toJSON = function toJSON () {
  	  return {
  	    type: 'Buffer',
  	    data: Array.prototype.slice.call(this._arr || this, 0)
  	  }
  	};

  	function base64Slice (buf, start, end) {
  	  if (start === 0 && end === buf.length) {
  	    return base64.fromByteArray(buf)
  	  } else {
  	    return base64.fromByteArray(buf.slice(start, end))
  	  }
  	}

  	function utf8Slice (buf, start, end) {
  	  end = Math.min(buf.length, end);
  	  const res = [];

  	  let i = start;
  	  while (i < end) {
  	    const firstByte = buf[i];
  	    let codePoint = null;
  	    let bytesPerSequence = (firstByte > 0xEF)
  	      ? 4
  	      : (firstByte > 0xDF)
  	          ? 3
  	          : (firstByte > 0xBF)
  	              ? 2
  	              : 1;

  	    if (i + bytesPerSequence <= end) {
  	      let secondByte, thirdByte, fourthByte, tempCodePoint;

  	      switch (bytesPerSequence) {
  	        case 1:
  	          if (firstByte < 0x80) {
  	            codePoint = firstByte;
  	          }
  	          break
  	        case 2:
  	          secondByte = buf[i + 1];
  	          if ((secondByte & 0xC0) === 0x80) {
  	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
  	            if (tempCodePoint > 0x7F) {
  	              codePoint = tempCodePoint;
  	            }
  	          }
  	          break
  	        case 3:
  	          secondByte = buf[i + 1];
  	          thirdByte = buf[i + 2];
  	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
  	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
  	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
  	              codePoint = tempCodePoint;
  	            }
  	          }
  	          break
  	        case 4:
  	          secondByte = buf[i + 1];
  	          thirdByte = buf[i + 2];
  	          fourthByte = buf[i + 3];
  	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
  	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
  	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
  	              codePoint = tempCodePoint;
  	            }
  	          }
  	      }
  	    }

  	    if (codePoint === null) {
  	      // we did not generate a valid codePoint so insert a
  	      // replacement char (U+FFFD) and advance only 1 byte
  	      codePoint = 0xFFFD;
  	      bytesPerSequence = 1;
  	    } else if (codePoint > 0xFFFF) {
  	      // encode to utf16 (surrogate pair dance)
  	      codePoint -= 0x10000;
  	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
  	      codePoint = 0xDC00 | codePoint & 0x3FF;
  	    }

  	    res.push(codePoint);
  	    i += bytesPerSequence;
  	  }

  	  return decodeCodePointsArray(res)
  	}

  	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
  	// the lowest limit is Chrome, with 0x10000 args.
  	// We go 1 magnitude less, for safety
  	const MAX_ARGUMENTS_LENGTH = 0x1000;

  	function decodeCodePointsArray (codePoints) {
  	  const len = codePoints.length;
  	  if (len <= MAX_ARGUMENTS_LENGTH) {
  	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  	  }

  	  // Decode in chunks to avoid "call stack size exceeded".
  	  let res = '';
  	  let i = 0;
  	  while (i < len) {
  	    res += String.fromCharCode.apply(
  	      String,
  	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
  	    );
  	  }
  	  return res
  	}

  	function asciiSlice (buf, start, end) {
  	  let ret = '';
  	  end = Math.min(buf.length, end);

  	  for (let i = start; i < end; ++i) {
  	    ret += String.fromCharCode(buf[i] & 0x7F);
  	  }
  	  return ret
  	}

  	function latin1Slice (buf, start, end) {
  	  let ret = '';
  	  end = Math.min(buf.length, end);

  	  for (let i = start; i < end; ++i) {
  	    ret += String.fromCharCode(buf[i]);
  	  }
  	  return ret
  	}

  	function hexSlice (buf, start, end) {
  	  const len = buf.length;

  	  if (!start || start < 0) start = 0;
  	  if (!end || end < 0 || end > len) end = len;

  	  let out = '';
  	  for (let i = start; i < end; ++i) {
  	    out += hexSliceLookupTable[buf[i]];
  	  }
  	  return out
  	}

  	function utf16leSlice (buf, start, end) {
  	  const bytes = buf.slice(start, end);
  	  let res = '';
  	  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  	  for (let i = 0; i < bytes.length - 1; i += 2) {
  	    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
  	  }
  	  return res
  	}

  	Buffer.prototype.slice = function slice (start, end) {
  	  const len = this.length;
  	  start = ~~start;
  	  end = end === undefined ? len : ~~end;

  	  if (start < 0) {
  	    start += len;
  	    if (start < 0) start = 0;
  	  } else if (start > len) {
  	    start = len;
  	  }

  	  if (end < 0) {
  	    end += len;
  	    if (end < 0) end = 0;
  	  } else if (end > len) {
  	    end = len;
  	  }

  	  if (end < start) end = start;

  	  const newBuf = this.subarray(start, end);
  	  // Return an augmented `Uint8Array` instance
  	  Object.setPrototypeOf(newBuf, Buffer.prototype);

  	  return newBuf
  	};

  	/*
  	 * Need to make sure that buffer isn't trying to write out of bounds.
  	 */
  	function checkOffset (offset, ext, length) {
  	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  	}

  	Buffer.prototype.readUintLE =
  	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) checkOffset(offset, byteLength, this.length);

  	  let val = this[offset];
  	  let mul = 1;
  	  let i = 0;
  	  while (++i < byteLength && (mul *= 0x100)) {
  	    val += this[offset + i] * mul;
  	  }

  	  return val
  	};

  	Buffer.prototype.readUintBE =
  	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) {
  	    checkOffset(offset, byteLength, this.length);
  	  }

  	  let val = this[offset + --byteLength];
  	  let mul = 1;
  	  while (byteLength > 0 && (mul *= 0x100)) {
  	    val += this[offset + --byteLength] * mul;
  	  }

  	  return val
  	};

  	Buffer.prototype.readUint8 =
  	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 1, this.length);
  	  return this[offset]
  	};

  	Buffer.prototype.readUint16LE =
  	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 2, this.length);
  	  return this[offset] | (this[offset + 1] << 8)
  	};

  	Buffer.prototype.readUint16BE =
  	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 2, this.length);
  	  return (this[offset] << 8) | this[offset + 1]
  	};

  	Buffer.prototype.readUint32LE =
  	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);

  	  return ((this[offset]) |
  	      (this[offset + 1] << 8) |
  	      (this[offset + 2] << 16)) +
  	      (this[offset + 3] * 0x1000000)
  	};

  	Buffer.prototype.readUint32BE =
  	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);

  	  return (this[offset] * 0x1000000) +
  	    ((this[offset + 1] << 16) |
  	    (this[offset + 2] << 8) |
  	    this[offset + 3])
  	};

  	Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  	  offset = offset >>> 0;
  	  validateNumber(offset, 'offset');
  	  const first = this[offset];
  	  const last = this[offset + 7];
  	  if (first === undefined || last === undefined) {
  	    boundsError(offset, this.length - 8);
  	  }

  	  const lo = first +
  	    this[++offset] * 2 ** 8 +
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 24;

  	  const hi = this[++offset] +
  	    this[++offset] * 2 ** 8 +
  	    this[++offset] * 2 ** 16 +
  	    last * 2 ** 24;

  	  return BigInt(lo) + (BigInt(hi) << BigInt(32))
  	});

  	Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  	  offset = offset >>> 0;
  	  validateNumber(offset, 'offset');
  	  const first = this[offset];
  	  const last = this[offset + 7];
  	  if (first === undefined || last === undefined) {
  	    boundsError(offset, this.length - 8);
  	  }

  	  const hi = first * 2 ** 24 +
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 8 +
  	    this[++offset];

  	  const lo = this[++offset] * 2 ** 24 +
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 8 +
  	    last;

  	  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
  	});

  	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) checkOffset(offset, byteLength, this.length);

  	  let val = this[offset];
  	  let mul = 1;
  	  let i = 0;
  	  while (++i < byteLength && (mul *= 0x100)) {
  	    val += this[offset + i] * mul;
  	  }
  	  mul *= 0x80;

  	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  	  return val
  	};

  	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) checkOffset(offset, byteLength, this.length);

  	  let i = byteLength;
  	  let mul = 1;
  	  let val = this[offset + --i];
  	  while (i > 0 && (mul *= 0x100)) {
  	    val += this[offset + --i] * mul;
  	  }
  	  mul *= 0x80;

  	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  	  return val
  	};

  	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 1, this.length);
  	  if (!(this[offset] & 0x80)) return (this[offset])
  	  return ((0xff - this[offset] + 1) * -1)
  	};

  	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 2, this.length);
  	  const val = this[offset] | (this[offset + 1] << 8);
  	  return (val & 0x8000) ? val | 0xFFFF0000 : val
  	};

  	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 2, this.length);
  	  const val = this[offset + 1] | (this[offset] << 8);
  	  return (val & 0x8000) ? val | 0xFFFF0000 : val
  	};

  	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);

  	  return (this[offset]) |
  	    (this[offset + 1] << 8) |
  	    (this[offset + 2] << 16) |
  	    (this[offset + 3] << 24)
  	};

  	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);

  	  return (this[offset] << 24) |
  	    (this[offset + 1] << 16) |
  	    (this[offset + 2] << 8) |
  	    (this[offset + 3])
  	};

  	Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  	  offset = offset >>> 0;
  	  validateNumber(offset, 'offset');
  	  const first = this[offset];
  	  const last = this[offset + 7];
  	  if (first === undefined || last === undefined) {
  	    boundsError(offset, this.length - 8);
  	  }

  	  const val = this[offset + 4] +
  	    this[offset + 5] * 2 ** 8 +
  	    this[offset + 6] * 2 ** 16 +
  	    (last << 24); // Overflow

  	  return (BigInt(val) << BigInt(32)) +
  	    BigInt(first +
  	    this[++offset] * 2 ** 8 +
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 24)
  	});

  	Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  	  offset = offset >>> 0;
  	  validateNumber(offset, 'offset');
  	  const first = this[offset];
  	  const last = this[offset + 7];
  	  if (first === undefined || last === undefined) {
  	    boundsError(offset, this.length - 8);
  	  }

  	  const val = (first << 24) + // Overflow
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 8 +
  	    this[++offset];

  	  return (BigInt(val) << BigInt(32)) +
  	    BigInt(this[++offset] * 2 ** 24 +
  	    this[++offset] * 2 ** 16 +
  	    this[++offset] * 2 ** 8 +
  	    last)
  	});

  	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);
  	  return ieee754$1.read(this, offset, true, 23, 4)
  	};

  	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 4, this.length);
  	  return ieee754$1.read(this, offset, false, 23, 4)
  	};

  	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 8, this.length);
  	  return ieee754$1.read(this, offset, true, 52, 8)
  	};

  	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  	  offset = offset >>> 0;
  	  if (!noAssert) checkOffset(offset, 8, this.length);
  	  return ieee754$1.read(this, offset, false, 52, 8)
  	};

  	function checkInt (buf, value, offset, ext, max, min) {
  	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  	}

  	Buffer.prototype.writeUintLE =
  	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) {
  	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
  	    checkInt(this, value, offset, byteLength, maxBytes, 0);
  	  }

  	  let mul = 1;
  	  let i = 0;
  	  this[offset] = value & 0xFF;
  	  while (++i < byteLength && (mul *= 0x100)) {
  	    this[offset + i] = (value / mul) & 0xFF;
  	  }

  	  return offset + byteLength
  	};

  	Buffer.prototype.writeUintBE =
  	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  byteLength = byteLength >>> 0;
  	  if (!noAssert) {
  	    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
  	    checkInt(this, value, offset, byteLength, maxBytes, 0);
  	  }

  	  let i = byteLength - 1;
  	  let mul = 1;
  	  this[offset + i] = value & 0xFF;
  	  while (--i >= 0 && (mul *= 0x100)) {
  	    this[offset + i] = (value / mul) & 0xFF;
  	  }

  	  return offset + byteLength
  	};

  	Buffer.prototype.writeUint8 =
  	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  	  this[offset] = (value & 0xff);
  	  return offset + 1
  	};

  	Buffer.prototype.writeUint16LE =
  	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  	  this[offset] = (value & 0xff);
  	  this[offset + 1] = (value >>> 8);
  	  return offset + 2
  	};

  	Buffer.prototype.writeUint16BE =
  	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  	  this[offset] = (value >>> 8);
  	  this[offset + 1] = (value & 0xff);
  	  return offset + 2
  	};

  	Buffer.prototype.writeUint32LE =
  	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  	  this[offset + 3] = (value >>> 24);
  	  this[offset + 2] = (value >>> 16);
  	  this[offset + 1] = (value >>> 8);
  	  this[offset] = (value & 0xff);
  	  return offset + 4
  	};

  	Buffer.prototype.writeUint32BE =
  	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  	  this[offset] = (value >>> 24);
  	  this[offset + 1] = (value >>> 16);
  	  this[offset + 2] = (value >>> 8);
  	  this[offset + 3] = (value & 0xff);
  	  return offset + 4
  	};

  	function wrtBigUInt64LE (buf, value, offset, min, max) {
  	  checkIntBI(value, min, max, buf, offset, 7);

  	  let lo = Number(value & BigInt(0xffffffff));
  	  buf[offset++] = lo;
  	  lo = lo >> 8;
  	  buf[offset++] = lo;
  	  lo = lo >> 8;
  	  buf[offset++] = lo;
  	  lo = lo >> 8;
  	  buf[offset++] = lo;
  	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  	  buf[offset++] = hi;
  	  hi = hi >> 8;
  	  buf[offset++] = hi;
  	  hi = hi >> 8;
  	  buf[offset++] = hi;
  	  hi = hi >> 8;
  	  buf[offset++] = hi;
  	  return offset
  	}

  	function wrtBigUInt64BE (buf, value, offset, min, max) {
  	  checkIntBI(value, min, max, buf, offset, 7);

  	  let lo = Number(value & BigInt(0xffffffff));
  	  buf[offset + 7] = lo;
  	  lo = lo >> 8;
  	  buf[offset + 6] = lo;
  	  lo = lo >> 8;
  	  buf[offset + 5] = lo;
  	  lo = lo >> 8;
  	  buf[offset + 4] = lo;
  	  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  	  buf[offset + 3] = hi;
  	  hi = hi >> 8;
  	  buf[offset + 2] = hi;
  	  hi = hi >> 8;
  	  buf[offset + 1] = hi;
  	  hi = hi >> 8;
  	  buf[offset] = hi;
  	  return offset + 8
  	}

  	Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  	  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  	});

  	Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  	  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
  	});

  	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) {
  	    const limit = Math.pow(2, (8 * byteLength) - 1);

  	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  	  }

  	  let i = 0;
  	  let mul = 1;
  	  let sub = 0;
  	  this[offset] = value & 0xFF;
  	  while (++i < byteLength && (mul *= 0x100)) {
  	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
  	      sub = 1;
  	    }
  	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  	  }

  	  return offset + byteLength
  	};

  	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) {
  	    const limit = Math.pow(2, (8 * byteLength) - 1);

  	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  	  }

  	  let i = byteLength - 1;
  	  let mul = 1;
  	  let sub = 0;
  	  this[offset + i] = value & 0xFF;
  	  while (--i >= 0 && (mul *= 0x100)) {
  	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
  	      sub = 1;
  	    }
  	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  	  }

  	  return offset + byteLength
  	};

  	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  	  if (value < 0) value = 0xff + value + 1;
  	  this[offset] = (value & 0xff);
  	  return offset + 1
  	};

  	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  	  this[offset] = (value & 0xff);
  	  this[offset + 1] = (value >>> 8);
  	  return offset + 2
  	};

  	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  	  this[offset] = (value >>> 8);
  	  this[offset + 1] = (value & 0xff);
  	  return offset + 2
  	};

  	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  	  this[offset] = (value & 0xff);
  	  this[offset + 1] = (value >>> 8);
  	  this[offset + 2] = (value >>> 16);
  	  this[offset + 3] = (value >>> 24);
  	  return offset + 4
  	};

  	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  	  if (value < 0) value = 0xffffffff + value + 1;
  	  this[offset] = (value >>> 24);
  	  this[offset + 1] = (value >>> 16);
  	  this[offset + 2] = (value >>> 8);
  	  this[offset + 3] = (value & 0xff);
  	  return offset + 4
  	};

  	Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  	  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  	});

  	Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  	  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
  	});

  	function checkIEEE754 (buf, value, offset, ext, max, min) {
  	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  	  if (offset < 0) throw new RangeError('Index out of range')
  	}

  	function writeFloat (buf, value, offset, littleEndian, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) {
  	    checkIEEE754(buf, value, offset, 4);
  	  }
  	  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
  	  return offset + 4
  	}

  	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  	  return writeFloat(this, value, offset, true, noAssert)
  	};

  	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  	  return writeFloat(this, value, offset, false, noAssert)
  	};

  	function writeDouble (buf, value, offset, littleEndian, noAssert) {
  	  value = +value;
  	  offset = offset >>> 0;
  	  if (!noAssert) {
  	    checkIEEE754(buf, value, offset, 8);
  	  }
  	  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
  	  return offset + 8
  	}

  	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  	  return writeDouble(this, value, offset, true, noAssert)
  	};

  	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  	  return writeDouble(this, value, offset, false, noAssert)
  	};

  	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  	  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  	  if (!start) start = 0;
  	  if (!end && end !== 0) end = this.length;
  	  if (targetStart >= target.length) targetStart = target.length;
  	  if (!targetStart) targetStart = 0;
  	  if (end > 0 && end < start) end = start;

  	  // Copy 0 bytes; we're done
  	  if (end === start) return 0
  	  if (target.length === 0 || this.length === 0) return 0

  	  // Fatal error conditions
  	  if (targetStart < 0) {
  	    throw new RangeError('targetStart out of bounds')
  	  }
  	  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  	  // Are we oob?
  	  if (end > this.length) end = this.length;
  	  if (target.length - targetStart < end - start) {
  	    end = target.length - targetStart + start;
  	  }

  	  const len = end - start;

  	  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
  	    // Use built-in when available, missing from IE11
  	    this.copyWithin(targetStart, start, end);
  	  } else {
  	    Uint8Array.prototype.set.call(
  	      target,
  	      this.subarray(start, end),
  	      targetStart
  	    );
  	  }

  	  return len
  	};

  	// Usage:
  	//    buffer.fill(number[, offset[, end]])
  	//    buffer.fill(buffer[, offset[, end]])
  	//    buffer.fill(string[, offset[, end]][, encoding])
  	Buffer.prototype.fill = function fill (val, start, end, encoding) {
  	  // Handle string cases:
  	  if (typeof val === 'string') {
  	    if (typeof start === 'string') {
  	      encoding = start;
  	      start = 0;
  	      end = this.length;
  	    } else if (typeof end === 'string') {
  	      encoding = end;
  	      end = this.length;
  	    }
  	    if (encoding !== undefined && typeof encoding !== 'string') {
  	      throw new TypeError('encoding must be a string')
  	    }
  	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
  	      throw new TypeError('Unknown encoding: ' + encoding)
  	    }
  	    if (val.length === 1) {
  	      const code = val.charCodeAt(0);
  	      if ((encoding === 'utf8' && code < 128) ||
  	          encoding === 'latin1') {
  	        // Fast path: If `val` fits into a single byte, use that numeric value.
  	        val = code;
  	      }
  	    }
  	  } else if (typeof val === 'number') {
  	    val = val & 255;
  	  } else if (typeof val === 'boolean') {
  	    val = Number(val);
  	  }

  	  // Invalid ranges are not set to a default, so can range check early.
  	  if (start < 0 || this.length < start || this.length < end) {
  	    throw new RangeError('Out of range index')
  	  }

  	  if (end <= start) {
  	    return this
  	  }

  	  start = start >>> 0;
  	  end = end === undefined ? this.length : end >>> 0;

  	  if (!val) val = 0;

  	  let i;
  	  if (typeof val === 'number') {
  	    for (i = start; i < end; ++i) {
  	      this[i] = val;
  	    }
  	  } else {
  	    const bytes = Buffer.isBuffer(val)
  	      ? val
  	      : Buffer.from(val, encoding);
  	    const len = bytes.length;
  	    if (len === 0) {
  	      throw new TypeError('The value "' + val +
  	        '" is invalid for argument "value"')
  	    }
  	    for (i = 0; i < end - start; ++i) {
  	      this[i + start] = bytes[i % len];
  	    }
  	  }

  	  return this
  	};

  	// CUSTOM ERRORS
  	// =============

  	// Simplified versions from Node, changed for Buffer-only usage
  	const errors = {};
  	function E (sym, getMessage, Base) {
  	  errors[sym] = class NodeError extends Base {
  	    constructor () {
  	      super();

  	      Object.defineProperty(this, 'message', {
  	        value: getMessage.apply(this, arguments),
  	        writable: true,
  	        configurable: true
  	      });

  	      // Add the error code to the name to include it in the stack trace.
  	      this.name = `${this.name} [${sym}]`;
  	      // Access the stack to generate the error message including the error code
  	      // from the name.
  	      this.stack; // eslint-disable-line no-unused-expressions
  	      // Reset the name to the actual name.
  	      delete this.name;
  	    }

  	    get code () {
  	      return sym
  	    }

  	    set code (value) {
  	      Object.defineProperty(this, 'code', {
  	        configurable: true,
  	        enumerable: true,
  	        value,
  	        writable: true
  	      });
  	    }

  	    toString () {
  	      return `${this.name} [${sym}]: ${this.message}`
  	    }
  	  };
  	}

  	E('ERR_BUFFER_OUT_OF_BOUNDS',
  	  function (name) {
  	    if (name) {
  	      return `${name} is outside of buffer bounds`
  	    }

  	    return 'Attempt to access memory outside buffer bounds'
  	  }, RangeError);
  	E('ERR_INVALID_ARG_TYPE',
  	  function (name, actual) {
  	    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  	  }, TypeError);
  	E('ERR_OUT_OF_RANGE',
  	  function (str, range, input) {
  	    let msg = `The value of "${str}" is out of range.`;
  	    let received = input;
  	    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
  	      received = addNumericalSeparator(String(input));
  	    } else if (typeof input === 'bigint') {
  	      received = String(input);
  	      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
  	        received = addNumericalSeparator(received);
  	      }
  	      received += 'n';
  	    }
  	    msg += ` It must be ${range}. Received ${received}`;
  	    return msg
  	  }, RangeError);

  	function addNumericalSeparator (val) {
  	  let res = '';
  	  let i = val.length;
  	  const start = val[0] === '-' ? 1 : 0;
  	  for (; i >= start + 4; i -= 3) {
  	    res = `_${val.slice(i - 3, i)}${res}`;
  	  }
  	  return `${val.slice(0, i)}${res}`
  	}

  	// CHECK FUNCTIONS
  	// ===============

  	function checkBounds (buf, offset, byteLength) {
  	  validateNumber(offset, 'offset');
  	  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
  	    boundsError(offset, buf.length - (byteLength + 1));
  	  }
  	}

  	function checkIntBI (value, min, max, buf, offset, byteLength) {
  	  if (value > max || value < min) {
  	    const n = typeof min === 'bigint' ? 'n' : '';
  	    let range;
  	    if (byteLength > 3) {
  	      if (min === 0 || min === BigInt(0)) {
  	        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
  	      } else {
  	        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
  	                `${(byteLength + 1) * 8 - 1}${n}`;
  	      }
  	    } else {
  	      range = `>= ${min}${n} and <= ${max}${n}`;
  	    }
  	    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  	  }
  	  checkBounds(buf, offset, byteLength);
  	}

  	function validateNumber (value, name) {
  	  if (typeof value !== 'number') {
  	    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  	  }
  	}

  	function boundsError (value, length, type) {
  	  if (Math.floor(value) !== value) {
  	    validateNumber(value, type);
  	    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  	  }

  	  if (length < 0) {
  	    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  	  }

  	  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
  	                                    `>= ${type ? 1 : 0} and <= ${length}`,
  	                                    value)
  	}

  	// HELPER FUNCTIONS
  	// ================

  	const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  	function base64clean (str) {
  	  // Node takes equal signs as end of the Base64 encoding
  	  str = str.split('=')[0];
  	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  	  str = str.trim().replace(INVALID_BASE64_RE, '');
  	  // Node converts strings with length < 2 to ''
  	  if (str.length < 2) return ''
  	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  	  while (str.length % 4 !== 0) {
  	    str = str + '=';
  	  }
  	  return str
  	}

  	function utf8ToBytes (string, units) {
  	  units = units || Infinity;
  	  let codePoint;
  	  const length = string.length;
  	  let leadSurrogate = null;
  	  const bytes = [];

  	  for (let i = 0; i < length; ++i) {
  	    codePoint = string.charCodeAt(i);

  	    // is surrogate component
  	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
  	      // last char was a lead
  	      if (!leadSurrogate) {
  	        // no lead yet
  	        if (codePoint > 0xDBFF) {
  	          // unexpected trail
  	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  	          continue
  	        } else if (i + 1 === length) {
  	          // unpaired lead
  	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  	          continue
  	        }

  	        // valid lead
  	        leadSurrogate = codePoint;

  	        continue
  	      }

  	      // 2 leads in a row
  	      if (codePoint < 0xDC00) {
  	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  	        leadSurrogate = codePoint;
  	        continue
  	      }

  	      // valid surrogate pair
  	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
  	    } else if (leadSurrogate) {
  	      // valid bmp char, but last char was a lead
  	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
  	    }

  	    leadSurrogate = null;

  	    // encode utf8
  	    if (codePoint < 0x80) {
  	      if ((units -= 1) < 0) break
  	      bytes.push(codePoint);
  	    } else if (codePoint < 0x800) {
  	      if ((units -= 2) < 0) break
  	      bytes.push(
  	        codePoint >> 0x6 | 0xC0,
  	        codePoint & 0x3F | 0x80
  	      );
  	    } else if (codePoint < 0x10000) {
  	      if ((units -= 3) < 0) break
  	      bytes.push(
  	        codePoint >> 0xC | 0xE0,
  	        codePoint >> 0x6 & 0x3F | 0x80,
  	        codePoint & 0x3F | 0x80
  	      );
  	    } else if (codePoint < 0x110000) {
  	      if ((units -= 4) < 0) break
  	      bytes.push(
  	        codePoint >> 0x12 | 0xF0,
  	        codePoint >> 0xC & 0x3F | 0x80,
  	        codePoint >> 0x6 & 0x3F | 0x80,
  	        codePoint & 0x3F | 0x80
  	      );
  	    } else {
  	      throw new Error('Invalid code point')
  	    }
  	  }

  	  return bytes
  	}

  	function asciiToBytes (str) {
  	  const byteArray = [];
  	  for (let i = 0; i < str.length; ++i) {
  	    // Node's code seems to be doing this and not & 0x7F..
  	    byteArray.push(str.charCodeAt(i) & 0xFF);
  	  }
  	  return byteArray
  	}

  	function utf16leToBytes (str, units) {
  	  let c, hi, lo;
  	  const byteArray = [];
  	  for (let i = 0; i < str.length; ++i) {
  	    if ((units -= 2) < 0) break

  	    c = str.charCodeAt(i);
  	    hi = c >> 8;
  	    lo = c % 256;
  	    byteArray.push(lo);
  	    byteArray.push(hi);
  	  }

  	  return byteArray
  	}

  	function base64ToBytes (str) {
  	  return base64.toByteArray(base64clean(str))
  	}

  	function blitBuffer (src, dst, offset, length) {
  	  let i;
  	  for (i = 0; i < length; ++i) {
  	    if ((i + offset >= dst.length) || (i >= src.length)) break
  	    dst[i + offset] = src[i];
  	  }
  	  return i
  	}

  	// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  	// the `instanceof` check but they should be treated as of that type.
  	// See: https://github.com/feross/buffer/issues/166
  	function isInstance (obj, type) {
  	  return obj instanceof type ||
  	    (obj != null && obj.constructor != null && obj.constructor.name != null &&
  	      obj.constructor.name === type.name)
  	}
  	function numberIsNaN (obj) {
  	  // For IE11 support
  	  return obj !== obj // eslint-disable-line no-self-compare
  	}

  	// Create lookup table for `toString('hex')`
  	// See: https://github.com/feross/buffer/issues/219
  	const hexSliceLookupTable = (function () {
  	  const alphabet = '0123456789abcdef';
  	  const table = new Array(256);
  	  for (let i = 0; i < 16; ++i) {
  	    const i16 = i * 16;
  	    for (let j = 0; j < 16; ++j) {
  	      table[i16 + j] = alphabet[i] + alphabet[j];
  	    }
  	  }
  	  return table
  	})();

  	// Return not function with Error if BigInt not supported
  	function defineBigIntMethod (fn) {
  	  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
  	}

  	function BufferBigIntNotDefined () {
  	  throw new Error('BigInt not supported')
  	}
  } (buffer));

  /* eslint-disable node/no-deprecated-api */

  var hasRequiredSafeBuffer;

  function requireSafeBuffer () {
  	if (hasRequiredSafeBuffer) return safeBuffer.exports;
  	hasRequiredSafeBuffer = 1;
  	(function (module, exports) {
  		var buffer$1 = buffer;
  		var Buffer = buffer$1.Buffer;

  		// alternative to using Object.keys for old browsers
  		function copyProps (src, dst) {
  		  for (var key in src) {
  		    dst[key] = src[key];
  		  }
  		}
  		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  		  module.exports = buffer$1;
  		} else {
  		  // Copy properties from require('buffer')
  		  copyProps(buffer$1, exports);
  		  exports.Buffer = SafeBuffer;
  		}

  		function SafeBuffer (arg, encodingOrOffset, length) {
  		  return Buffer(arg, encodingOrOffset, length)
  		}

  		// Copy static methods from Buffer
  		copyProps(Buffer, SafeBuffer);

  		SafeBuffer.from = function (arg, encodingOrOffset, length) {
  		  if (typeof arg === 'number') {
  		    throw new TypeError('Argument must not be a number')
  		  }
  		  return Buffer(arg, encodingOrOffset, length)
  		};

  		SafeBuffer.alloc = function (size, fill, encoding) {
  		  if (typeof size !== 'number') {
  		    throw new TypeError('Argument must be a number')
  		  }
  		  var buf = Buffer(size);
  		  if (fill !== undefined) {
  		    if (typeof encoding === 'string') {
  		      buf.fill(fill, encoding);
  		    } else {
  		      buf.fill(fill);
  		    }
  		  } else {
  		    buf.fill(0);
  		  }
  		  return buf
  		};

  		SafeBuffer.allocUnsafe = function (size) {
  		  if (typeof size !== 'number') {
  		    throw new TypeError('Argument must be a number')
  		  }
  		  return Buffer(size)
  		};

  		SafeBuffer.allocUnsafeSlow = function (size) {
  		  if (typeof size !== 'number') {
  		    throw new TypeError('Argument must be a number')
  		  }
  		  return buffer$1.SlowBuffer(size)
  		};
  } (safeBuffer, safeBuffer.exports));
  	return safeBuffer.exports;
  }

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$1 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$1.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer$1;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$1(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var util$2 = {};

  var hasRequiredUtil;

  function requireUtil () {
  	if (hasRequiredUtil) return util$2;
  	hasRequiredUtil = 1;
  	// Copyright Joyent, Inc. and other Node contributors.
  	//
  	// Permission is hereby granted, free of charge, to any person obtaining a
  	// copy of this software and associated documentation files (the
  	// "Software"), to deal in the Software without restriction, including
  	// without limitation the rights to use, copy, modify, merge, publish,
  	// distribute, sublicense, and/or sell copies of the Software, and to permit
  	// persons to whom the Software is furnished to do so, subject to the
  	// following conditions:
  	//
  	// The above copyright notice and this permission notice shall be included
  	// in all copies or substantial portions of the Software.
  	//
  	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  	// USE OR OTHER DEALINGS IN THE SOFTWARE.

  	// NOTE: These type checking functions intentionally don't use `instanceof`
  	// because it is fragile and can be easily faked with `Object.create()`.

  	function isArray(arg) {
  	  if (Array.isArray) {
  	    return Array.isArray(arg);
  	  }
  	  return objectToString(arg) === '[object Array]';
  	}
  	util$2.isArray = isArray;

  	function isBoolean(arg) {
  	  return typeof arg === 'boolean';
  	}
  	util$2.isBoolean = isBoolean;

  	function isNull(arg) {
  	  return arg === null;
  	}
  	util$2.isNull = isNull;

  	function isNullOrUndefined(arg) {
  	  return arg == null;
  	}
  	util$2.isNullOrUndefined = isNullOrUndefined;

  	function isNumber(arg) {
  	  return typeof arg === 'number';
  	}
  	util$2.isNumber = isNumber;

  	function isString(arg) {
  	  return typeof arg === 'string';
  	}
  	util$2.isString = isString;

  	function isSymbol(arg) {
  	  return typeof arg === 'symbol';
  	}
  	util$2.isSymbol = isSymbol;

  	function isUndefined(arg) {
  	  return arg === void 0;
  	}
  	util$2.isUndefined = isUndefined;

  	function isRegExp(re) {
  	  return objectToString(re) === '[object RegExp]';
  	}
  	util$2.isRegExp = isRegExp;

  	function isObject(arg) {
  	  return typeof arg === 'object' && arg !== null;
  	}
  	util$2.isObject = isObject;

  	function isDate(d) {
  	  return objectToString(d) === '[object Date]';
  	}
  	util$2.isDate = isDate;

  	function isError(e) {
  	  return (objectToString(e) === '[object Error]' || e instanceof Error);
  	}
  	util$2.isError = isError;

  	function isFunction(arg) {
  	  return typeof arg === 'function';
  	}
  	util$2.isFunction = isFunction;

  	function isPrimitive(arg) {
  	  return arg === null ||
  	         typeof arg === 'boolean' ||
  	         typeof arg === 'number' ||
  	         typeof arg === 'string' ||
  	         typeof arg === 'symbol' ||  // ES6 symbol
  	         typeof arg === 'undefined';
  	}
  	util$2.isPrimitive = isPrimitive;

  	util$2.isBuffer = Buffer.isBuffer;

  	function objectToString(o) {
  	  return Object.prototype.toString.call(o);
  	}
  	return util$2;
  }

  var inherits_browser = {exports: {}};

  var hasRequiredInherits_browser;

  function requireInherits_browser () {
  	if (hasRequiredInherits_browser) return inherits_browser.exports;
  	hasRequiredInherits_browser = 1;
  	if (typeof Object.create === 'function') {
  	  // implementation from standard node.js 'util' module
  	  inherits_browser.exports = function inherits(ctor, superCtor) {
  	    if (superCtor) {
  	      ctor.super_ = superCtor;
  	      ctor.prototype = Object.create(superCtor.prototype, {
  	        constructor: {
  	          value: ctor,
  	          enumerable: false,
  	          writable: true,
  	          configurable: true
  	        }
  	      });
  	    }
  	  };
  	} else {
  	  // old school shim for old browsers
  	  inherits_browser.exports = function inherits(ctor, superCtor) {
  	    if (superCtor) {
  	      ctor.super_ = superCtor;
  	      var TempCtor = function () {};
  	      TempCtor.prototype = superCtor.prototype;
  	      ctor.prototype = new TempCtor();
  	      ctor.prototype.constructor = ctor;
  	    }
  	  };
  	}
  	return inherits_browser.exports;
  }

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
  });

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  var BufferList$2 = {exports: {}};

  var hasRequiredBufferList$1;

  function requireBufferList$1 () {
  	if (hasRequiredBufferList$1) return BufferList$2.exports;
  	hasRequiredBufferList$1 = 1;
  	(function (module) {

  		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  		var Buffer = requireSafeBuffer().Buffer;
  		var util = require$$0$1;

  		function copyBuffer(src, target, offset) {
  		  src.copy(target, offset);
  		}

  		module.exports = function () {
  		  function BufferList() {
  		    _classCallCheck(this, BufferList);

  		    this.head = null;
  		    this.tail = null;
  		    this.length = 0;
  		  }

  		  BufferList.prototype.push = function push(v) {
  		    var entry = { data: v, next: null };
  		    if (this.length > 0) this.tail.next = entry;else this.head = entry;
  		    this.tail = entry;
  		    ++this.length;
  		  };

  		  BufferList.prototype.unshift = function unshift(v) {
  		    var entry = { data: v, next: this.head };
  		    if (this.length === 0) this.tail = entry;
  		    this.head = entry;
  		    ++this.length;
  		  };

  		  BufferList.prototype.shift = function shift() {
  		    if (this.length === 0) return;
  		    var ret = this.head.data;
  		    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  		    --this.length;
  		    return ret;
  		  };

  		  BufferList.prototype.clear = function clear() {
  		    this.head = this.tail = null;
  		    this.length = 0;
  		  };

  		  BufferList.prototype.join = function join(s) {
  		    if (this.length === 0) return '';
  		    var p = this.head;
  		    var ret = '' + p.data;
  		    while (p = p.next) {
  		      ret += s + p.data;
  		    }return ret;
  		  };

  		  BufferList.prototype.concat = function concat(n) {
  		    if (this.length === 0) return Buffer.alloc(0);
  		    if (this.length === 1) return this.head.data;
  		    var ret = Buffer.allocUnsafe(n >>> 0);
  		    var p = this.head;
  		    var i = 0;
  		    while (p) {
  		      copyBuffer(p.data, ret, i);
  		      i += p.data.length;
  		      p = p.next;
  		    }
  		    return ret;
  		  };

  		  return BufferList;
  		}();

  		if (util && util.inspect && util.inspect.custom) {
  		  module.exports.prototype[util.inspect.custom] = function () {
  		    var obj = util.inspect({ length: this.length });
  		    return this.constructor.name + ' ' + obj;
  		  };
  		}
  } (BufferList$2));
  	return BufferList$2.exports;
  }

  var destroy_1$1;
  var hasRequiredDestroy;

  function requireDestroy () {
  	if (hasRequiredDestroy) return destroy_1$1;
  	hasRequiredDestroy = 1;

  	/*<replacement>*/

  	var pna = requireProcessNextickArgs();
  	/*</replacement>*/

  	// undocumented cb() API, needed for core, not for public API
  	function destroy(err, cb) {
  	  var _this = this;

  	  var readableDestroyed = this._readableState && this._readableState.destroyed;
  	  var writableDestroyed = this._writableState && this._writableState.destroyed;

  	  if (readableDestroyed || writableDestroyed) {
  	    if (cb) {
  	      cb(err);
  	    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
  	      pna.nextTick(emitErrorNT, this, err);
  	    }
  	    return this;
  	  }

  	  // we set destroyed to true before firing error callbacks in order
  	  // to make it re-entrance safe in case destroy() is called within callbacks

  	  if (this._readableState) {
  	    this._readableState.destroyed = true;
  	  }

  	  // if this is a duplex stream mark the writable part as destroyed as well
  	  if (this._writableState) {
  	    this._writableState.destroyed = true;
  	  }

  	  this._destroy(err || null, function (err) {
  	    if (!cb && err) {
  	      pna.nextTick(emitErrorNT, _this, err);
  	      if (_this._writableState) {
  	        _this._writableState.errorEmitted = true;
  	      }
  	    } else if (cb) {
  	      cb(err);
  	    }
  	  });

  	  return this;
  	}

  	function undestroy() {
  	  if (this._readableState) {
  	    this._readableState.destroyed = false;
  	    this._readableState.reading = false;
  	    this._readableState.ended = false;
  	    this._readableState.endEmitted = false;
  	  }

  	  if (this._writableState) {
  	    this._writableState.destroyed = false;
  	    this._writableState.ended = false;
  	    this._writableState.ending = false;
  	    this._writableState.finished = false;
  	    this._writableState.errorEmitted = false;
  	  }
  	}

  	function emitErrorNT(self, err) {
  	  self.emit('error', err);
  	}

  	destroy_1$1 = {
  	  destroy: destroy,
  	  undestroy: undestroy
  	};
  	return destroy_1$1;
  }

  var browser$2;
  var hasRequiredBrowser;

  function requireBrowser () {
  	if (hasRequiredBrowser) return browser$2;
  	hasRequiredBrowser = 1;
  	/**
  	 * Module exports.
  	 */

  	browser$2 = deprecate;

  	/**
  	 * Mark that a method should not be used.
  	 * Returns a modified function which warns once by default.
  	 *
  	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
  	 *
  	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
  	 * will throw an Error when invoked.
  	 *
  	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
  	 * will invoke `console.trace()` instead of `console.error()`.
  	 *
  	 * @param {Function} fn - the function to deprecate
  	 * @param {String} msg - the string to print to the console when `fn` is invoked
  	 * @returns {Function} a new "deprecated" version of `fn`
  	 * @api public
  	 */

  	function deprecate (fn, msg) {
  	  if (config('noDeprecation')) {
  	    return fn;
  	  }

  	  var warned = false;
  	  function deprecated() {
  	    if (!warned) {
  	      if (config('throwDeprecation')) {
  	        throw new Error(msg);
  	      } else if (config('traceDeprecation')) {
  	        console.trace(msg);
  	      } else {
  	        console.warn(msg);
  	      }
  	      warned = true;
  	    }
  	    return fn.apply(this, arguments);
  	  }

  	  return deprecated;
  	}

  	/**
  	 * Checks `localStorage` for boolean values for the given `name`.
  	 *
  	 * @param {String} name
  	 * @returns {Boolean}
  	 * @api private
  	 */

  	function config (name) {
  	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  	  try {
  	    if (!commonjsGlobal.localStorage) return false;
  	  } catch (_) {
  	    return false;
  	  }
  	  var val = commonjsGlobal.localStorage[name];
  	  if (null == val) return false;
  	  return String(val).toLowerCase() === 'true';
  	}
  	return browser$2;
  }

  var _stream_writable$1;
  var hasRequired_stream_writable$1;

  function require_stream_writable$1 () {
  	if (hasRequired_stream_writable$1) return _stream_writable$1;
  	hasRequired_stream_writable$1 = 1;

  	/*<replacement>*/

  	var pna = requireProcessNextickArgs();
  	/*</replacement>*/

  	_stream_writable$1 = Writable;

  	// It seems a linked list but it is not
  	// there will be only 2 of these for each stream
  	function CorkedRequest(state) {
  	  var _this = this;

  	  this.next = null;
  	  this.entry = null;
  	  this.finish = function () {
  	    onCorkedFinish(_this, state);
  	  };
  	}
  	/* </replacement> */

  	/*<replacement>*/
  	var asyncWrite = !browser$1$1.browser && ['v0.10', 'v0.9.'].indexOf(browser$1$1.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  	/*</replacement>*/

  	/*<replacement>*/
  	var Duplex;
  	/*</replacement>*/

  	Writable.WritableState = WritableState;

  	/*<replacement>*/
  	var util = Object.create(requireUtil());
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	/*<replacement>*/
  	var internalUtil = {
  	  deprecate: requireBrowser()
  	};
  	/*</replacement>*/

  	/*<replacement>*/
  	var Stream = requireStreamBrowser();
  	/*</replacement>*/

  	/*<replacement>*/

  	var Buffer = requireSafeBuffer().Buffer;
  	var OurUint8Array = commonjsGlobal.Uint8Array || function () {};
  	function _uint8ArrayToBuffer(chunk) {
  	  return Buffer.from(chunk);
  	}
  	function _isUint8Array(obj) {
  	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  	}

  	/*</replacement>*/

  	var destroyImpl = requireDestroy();

  	util.inherits(Writable, Stream);

  	function nop() {}

  	function WritableState(options, stream) {
  	  Duplex = Duplex || require_stream_duplex$1();

  	  options = options || {};

  	  // Duplex streams are both readable and writable, but share
  	  // the same options object.
  	  // However, some cases require setting options to different
  	  // values for the readable and the writable sides of the duplex stream.
  	  // These options can be provided separately as readableXXX and writableXXX.
  	  var isDuplex = stream instanceof Duplex;

  	  // object stream flag to indicate whether or not this stream
  	  // contains buffers or objects.
  	  this.objectMode = !!options.objectMode;

  	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  	  // the point at which write() starts returning false
  	  // Note: 0 is a valid value, means that we always return false if
  	  // the entire buffer is not flushed immediately on write()
  	  var hwm = options.highWaterMark;
  	  var writableHwm = options.writableHighWaterMark;
  	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  	  // cast to ints.
  	  this.highWaterMark = Math.floor(this.highWaterMark);

  	  // if _final has been called
  	  this.finalCalled = false;

  	  // drain event flag.
  	  this.needDrain = false;
  	  // at the start of calling end()
  	  this.ending = false;
  	  // when end() has been called, and returned
  	  this.ended = false;
  	  // when 'finish' is emitted
  	  this.finished = false;

  	  // has it been destroyed
  	  this.destroyed = false;

  	  // should we decode strings into buffers before passing to _write?
  	  // this is here so that some node-core streams can optimize string
  	  // handling at a lower level.
  	  var noDecode = options.decodeStrings === false;
  	  this.decodeStrings = !noDecode;

  	  // Crypto is kind of old and crusty.  Historically, its default string
  	  // encoding is 'binary' so we have to make this configurable.
  	  // Everything else in the universe uses 'utf8', though.
  	  this.defaultEncoding = options.defaultEncoding || 'utf8';

  	  // not an actual buffer we keep track of, but a measurement
  	  // of how much we're waiting to get pushed to some underlying
  	  // socket or file.
  	  this.length = 0;

  	  // a flag to see when we're in the middle of a write.
  	  this.writing = false;

  	  // when true all writes will be buffered until .uncork() call
  	  this.corked = 0;

  	  // a flag to be able to tell if the onwrite cb is called immediately,
  	  // or on a later tick.  We set this to true at first, because any
  	  // actions that shouldn't happen until "later" should generally also
  	  // not happen before the first write call.
  	  this.sync = true;

  	  // a flag to know if we're processing previously buffered items, which
  	  // may call the _write() callback in the same tick, so that we don't
  	  // end up in an overlapped onwrite situation.
  	  this.bufferProcessing = false;

  	  // the callback that's passed to _write(chunk,cb)
  	  this.onwrite = function (er) {
  	    onwrite(stream, er);
  	  };

  	  // the callback that the user supplies to write(chunk,encoding,cb)
  	  this.writecb = null;

  	  // the amount that is being written when _write is called.
  	  this.writelen = 0;

  	  this.bufferedRequest = null;
  	  this.lastBufferedRequest = null;

  	  // number of pending user-supplied write callbacks
  	  // this must be 0 before 'finish' can be emitted
  	  this.pendingcb = 0;

  	  // emit prefinish if the only thing we're waiting for is _write cbs
  	  // This is relevant for synchronous Transform streams
  	  this.prefinished = false;

  	  // True if the error was already emitted and should not be thrown again
  	  this.errorEmitted = false;

  	  // count buffered requests
  	  this.bufferedRequestCount = 0;

  	  // allocate the first CorkedRequest, there is always
  	  // one allocated and free to use, and we maintain at most two
  	  this.corkedRequestsFree = new CorkedRequest(this);
  	}

  	WritableState.prototype.getBuffer = function getBuffer() {
  	  var current = this.bufferedRequest;
  	  var out = [];
  	  while (current) {
  	    out.push(current);
  	    current = current.next;
  	  }
  	  return out;
  	};

  	(function () {
  	  try {
  	    Object.defineProperty(WritableState.prototype, 'buffer', {
  	      get: internalUtil.deprecate(function () {
  	        return this.getBuffer();
  	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
  	    });
  	  } catch (_) {}
  	})();

  	// Test _writableState for inheritance to account for Duplex streams,
  	// whose prototype chain only points to Readable.
  	var realHasInstance;
  	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  	  realHasInstance = Function.prototype[Symbol.hasInstance];
  	  Object.defineProperty(Writable, Symbol.hasInstance, {
  	    value: function (object) {
  	      if (realHasInstance.call(this, object)) return true;
  	      if (this !== Writable) return false;

  	      return object && object._writableState instanceof WritableState;
  	    }
  	  });
  	} else {
  	  realHasInstance = function (object) {
  	    return object instanceof this;
  	  };
  	}

  	function Writable(options) {
  	  Duplex = Duplex || require_stream_duplex$1();

  	  // Writable ctor is applied to Duplexes, too.
  	  // `realHasInstance` is necessary because using plain `instanceof`
  	  // would return false, as no `_writableState` property is attached.

  	  // Trying to use the custom `instanceof` for Writable here will also break the
  	  // Node.js LazyTransform implementation, which has a non-trivial getter for
  	  // `_writableState` that would lead to infinite recursion.
  	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
  	    return new Writable(options);
  	  }

  	  this._writableState = new WritableState(options, this);

  	  // legacy.
  	  this.writable = true;

  	  if (options) {
  	    if (typeof options.write === 'function') this._write = options.write;

  	    if (typeof options.writev === 'function') this._writev = options.writev;

  	    if (typeof options.destroy === 'function') this._destroy = options.destroy;

  	    if (typeof options.final === 'function') this._final = options.final;
  	  }

  	  Stream.call(this);
  	}

  	// Otherwise people can pipe Writable streams, which is just wrong.
  	Writable.prototype.pipe = function () {
  	  this.emit('error', new Error('Cannot pipe, not readable'));
  	};

  	function writeAfterEnd(stream, cb) {
  	  var er = new Error('write after end');
  	  // TODO: defer error events consistently everywhere, not just the cb
  	  stream.emit('error', er);
  	  pna.nextTick(cb, er);
  	}

  	// Checks that a user-supplied chunk is valid, especially for the particular
  	// mode the stream is in. Currently this means that `null` is never accepted
  	// and undefined/non-string values are only allowed in object mode.
  	function validChunk(stream, state, chunk, cb) {
  	  var valid = true;
  	  var er = false;

  	  if (chunk === null) {
  	    er = new TypeError('May not write null values to stream');
  	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
  	    er = new TypeError('Invalid non-string/buffer chunk');
  	  }
  	  if (er) {
  	    stream.emit('error', er);
  	    pna.nextTick(cb, er);
  	    valid = false;
  	  }
  	  return valid;
  	}

  	Writable.prototype.write = function (chunk, encoding, cb) {
  	  var state = this._writableState;
  	  var ret = false;
  	  var isBuf = !state.objectMode && _isUint8Array(chunk);

  	  if (isBuf && !Buffer.isBuffer(chunk)) {
  	    chunk = _uint8ArrayToBuffer(chunk);
  	  }

  	  if (typeof encoding === 'function') {
  	    cb = encoding;
  	    encoding = null;
  	  }

  	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  	  if (typeof cb !== 'function') cb = nop;

  	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
  	    state.pendingcb++;
  	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  	  }

  	  return ret;
  	};

  	Writable.prototype.cork = function () {
  	  var state = this._writableState;

  	  state.corked++;
  	};

  	Writable.prototype.uncork = function () {
  	  var state = this._writableState;

  	  if (state.corked) {
  	    state.corked--;

  	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  	  }
  	};

  	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  	  // node::ParseEncoding() requires lower case.
  	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  	  this._writableState.defaultEncoding = encoding;
  	  return this;
  	};

  	function decodeChunk(state, chunk, encoding) {
  	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
  	    chunk = Buffer.from(chunk, encoding);
  	  }
  	  return chunk;
  	}

  	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  	  // making it explicit this property is not enumerable
  	  // because otherwise some prototype manipulation in
  	  // userland will fail
  	  enumerable: false,
  	  get: function () {
  	    return this._writableState.highWaterMark;
  	  }
  	});

  	// if we're already writing something, then just put this
  	// in the queue, and wait our turn.  Otherwise, call _write
  	// If we return false, then we need a drain event, so set that flag.
  	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  	  if (!isBuf) {
  	    var newChunk = decodeChunk(state, chunk, encoding);
  	    if (chunk !== newChunk) {
  	      isBuf = true;
  	      encoding = 'buffer';
  	      chunk = newChunk;
  	    }
  	  }
  	  var len = state.objectMode ? 1 : chunk.length;

  	  state.length += len;

  	  var ret = state.length < state.highWaterMark;
  	  // we must ensure that previous needDrain will not be reset to false.
  	  if (!ret) state.needDrain = true;

  	  if (state.writing || state.corked) {
  	    var last = state.lastBufferedRequest;
  	    state.lastBufferedRequest = {
  	      chunk: chunk,
  	      encoding: encoding,
  	      isBuf: isBuf,
  	      callback: cb,
  	      next: null
  	    };
  	    if (last) {
  	      last.next = state.lastBufferedRequest;
  	    } else {
  	      state.bufferedRequest = state.lastBufferedRequest;
  	    }
  	    state.bufferedRequestCount += 1;
  	  } else {
  	    doWrite(stream, state, false, len, chunk, encoding, cb);
  	  }

  	  return ret;
  	}

  	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  	  state.writelen = len;
  	  state.writecb = cb;
  	  state.writing = true;
  	  state.sync = true;
  	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  	  state.sync = false;
  	}

  	function onwriteError(stream, state, sync, er, cb) {
  	  --state.pendingcb;

  	  if (sync) {
  	    // defer the callback if we are being called synchronously
  	    // to avoid piling up things on the stack
  	    pna.nextTick(cb, er);
  	    // this can emit finish, and it will always happen
  	    // after error
  	    pna.nextTick(finishMaybe, stream, state);
  	    stream._writableState.errorEmitted = true;
  	    stream.emit('error', er);
  	  } else {
  	    // the caller expect this to happen before if
  	    // it is async
  	    cb(er);
  	    stream._writableState.errorEmitted = true;
  	    stream.emit('error', er);
  	    // this can emit finish, but finish must
  	    // always follow error
  	    finishMaybe(stream, state);
  	  }
  	}

  	function onwriteStateUpdate(state) {
  	  state.writing = false;
  	  state.writecb = null;
  	  state.length -= state.writelen;
  	  state.writelen = 0;
  	}

  	function onwrite(stream, er) {
  	  var state = stream._writableState;
  	  var sync = state.sync;
  	  var cb = state.writecb;

  	  onwriteStateUpdate(state);

  	  if (er) onwriteError(stream, state, sync, er, cb);else {
  	    // Check if we're actually ready to finish, but don't emit yet
  	    var finished = needFinish(state);

  	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
  	      clearBuffer(stream, state);
  	    }

  	    if (sync) {
  	      /*<replacement>*/
  	      asyncWrite(afterWrite, stream, state, finished, cb);
  	      /*</replacement>*/
  	    } else {
  	      afterWrite(stream, state, finished, cb);
  	    }
  	  }
  	}

  	function afterWrite(stream, state, finished, cb) {
  	  if (!finished) onwriteDrain(stream, state);
  	  state.pendingcb--;
  	  cb();
  	  finishMaybe(stream, state);
  	}

  	// Must force callback to be called on nextTick, so that we don't
  	// emit 'drain' before the write() consumer gets the 'false' return
  	// value, and has a chance to attach a 'drain' listener.
  	function onwriteDrain(stream, state) {
  	  if (state.length === 0 && state.needDrain) {
  	    state.needDrain = false;
  	    stream.emit('drain');
  	  }
  	}

  	// if there's something in the buffer waiting, then process it
  	function clearBuffer(stream, state) {
  	  state.bufferProcessing = true;
  	  var entry = state.bufferedRequest;

  	  if (stream._writev && entry && entry.next) {
  	    // Fast case, write everything using _writev()
  	    var l = state.bufferedRequestCount;
  	    var buffer = new Array(l);
  	    var holder = state.corkedRequestsFree;
  	    holder.entry = entry;

  	    var count = 0;
  	    var allBuffers = true;
  	    while (entry) {
  	      buffer[count] = entry;
  	      if (!entry.isBuf) allBuffers = false;
  	      entry = entry.next;
  	      count += 1;
  	    }
  	    buffer.allBuffers = allBuffers;

  	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

  	    // doWrite is almost always async, defer these to save a bit of time
  	    // as the hot path ends with doWrite
  	    state.pendingcb++;
  	    state.lastBufferedRequest = null;
  	    if (holder.next) {
  	      state.corkedRequestsFree = holder.next;
  	      holder.next = null;
  	    } else {
  	      state.corkedRequestsFree = new CorkedRequest(state);
  	    }
  	    state.bufferedRequestCount = 0;
  	  } else {
  	    // Slow case, write chunks one-by-one
  	    while (entry) {
  	      var chunk = entry.chunk;
  	      var encoding = entry.encoding;
  	      var cb = entry.callback;
  	      var len = state.objectMode ? 1 : chunk.length;

  	      doWrite(stream, state, false, len, chunk, encoding, cb);
  	      entry = entry.next;
  	      state.bufferedRequestCount--;
  	      // if we didn't call the onwrite immediately, then
  	      // it means that we need to wait until it does.
  	      // also, that means that the chunk and cb are currently
  	      // being processed, so move the buffer counter past them.
  	      if (state.writing) {
  	        break;
  	      }
  	    }

  	    if (entry === null) state.lastBufferedRequest = null;
  	  }

  	  state.bufferedRequest = entry;
  	  state.bufferProcessing = false;
  	}

  	Writable.prototype._write = function (chunk, encoding, cb) {
  	  cb(new Error('_write() is not implemented'));
  	};

  	Writable.prototype._writev = null;

  	Writable.prototype.end = function (chunk, encoding, cb) {
  	  var state = this._writableState;

  	  if (typeof chunk === 'function') {
  	    cb = chunk;
  	    chunk = null;
  	    encoding = null;
  	  } else if (typeof encoding === 'function') {
  	    cb = encoding;
  	    encoding = null;
  	  }

  	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  	  // .end() fully uncorks
  	  if (state.corked) {
  	    state.corked = 1;
  	    this.uncork();
  	  }

  	  // ignore unnecessary end() calls.
  	  if (!state.ending && !state.finished) endWritable(this, state, cb);
  	};

  	function needFinish(state) {
  	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  	}
  	function callFinal(stream, state) {
  	  stream._final(function (err) {
  	    state.pendingcb--;
  	    if (err) {
  	      stream.emit('error', err);
  	    }
  	    state.prefinished = true;
  	    stream.emit('prefinish');
  	    finishMaybe(stream, state);
  	  });
  	}
  	function prefinish(stream, state) {
  	  if (!state.prefinished && !state.finalCalled) {
  	    if (typeof stream._final === 'function') {
  	      state.pendingcb++;
  	      state.finalCalled = true;
  	      pna.nextTick(callFinal, stream, state);
  	    } else {
  	      state.prefinished = true;
  	      stream.emit('prefinish');
  	    }
  	  }
  	}

  	function finishMaybe(stream, state) {
  	  var need = needFinish(state);
  	  if (need) {
  	    prefinish(stream, state);
  	    if (state.pendingcb === 0) {
  	      state.finished = true;
  	      stream.emit('finish');
  	    }
  	  }
  	  return need;
  	}

  	function endWritable(stream, state, cb) {
  	  state.ending = true;
  	  finishMaybe(stream, state);
  	  if (cb) {
  	    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  	  }
  	  state.ended = true;
  	  stream.writable = false;
  	}

  	function onCorkedFinish(corkReq, state, err) {
  	  var entry = corkReq.entry;
  	  corkReq.entry = null;
  	  while (entry) {
  	    var cb = entry.callback;
  	    state.pendingcb--;
  	    cb(err);
  	    entry = entry.next;
  	  }
  	  if (state.corkedRequestsFree) {
  	    state.corkedRequestsFree.next = corkReq;
  	  } else {
  	    state.corkedRequestsFree = corkReq;
  	  }
  	}

  	Object.defineProperty(Writable.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._writableState === undefined) {
  	      return false;
  	    }
  	    return this._writableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (!this._writableState) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._writableState.destroyed = value;
  	  }
  	});

  	Writable.prototype.destroy = destroyImpl.destroy;
  	Writable.prototype._undestroy = destroyImpl.undestroy;
  	Writable.prototype._destroy = function (err, cb) {
  	  this.end();
  	  cb(err);
  	};
  	return _stream_writable$1;
  }

  var _stream_duplex$1;
  var hasRequired_stream_duplex$1;

  function require_stream_duplex$1 () {
  	if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  	hasRequired_stream_duplex$1 = 1;

  	/*<replacement>*/

  	var pna = requireProcessNextickArgs();
  	/*</replacement>*/

  	/*<replacement>*/
  	var objectKeys = Object.keys || function (obj) {
  	  var keys = [];
  	  for (var key in obj) {
  	    keys.push(key);
  	  }return keys;
  	};
  	/*</replacement>*/

  	_stream_duplex$1 = Duplex;

  	/*<replacement>*/
  	var util = Object.create(requireUtil());
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	var Readable = require_stream_readable$1();
  	var Writable = require_stream_writable$1();

  	util.inherits(Duplex, Readable);

  	{
  	  // avoid scope creep, the keys array can then be collected
  	  var keys = objectKeys(Writable.prototype);
  	  for (var v = 0; v < keys.length; v++) {
  	    var method = keys[v];
  	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  	  }
  	}

  	function Duplex(options) {
  	  if (!(this instanceof Duplex)) return new Duplex(options);

  	  Readable.call(this, options);
  	  Writable.call(this, options);

  	  if (options && options.readable === false) this.readable = false;

  	  if (options && options.writable === false) this.writable = false;

  	  this.allowHalfOpen = true;
  	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  	  this.once('end', onend);
  	}

  	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  	  // making it explicit this property is not enumerable
  	  // because otherwise some prototype manipulation in
  	  // userland will fail
  	  enumerable: false,
  	  get: function () {
  	    return this._writableState.highWaterMark;
  	  }
  	});

  	// the no-half-open enforcer
  	function onend() {
  	  // if we allow half-open state, or if the writable side ended,
  	  // then we're ok.
  	  if (this.allowHalfOpen || this._writableState.ended) return;

  	  // no more data can be written.
  	  // But allow more writes to happen in this tick.
  	  pna.nextTick(onEndNT, this);
  	}

  	function onEndNT(self) {
  	  self.end();
  	}

  	Object.defineProperty(Duplex.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._readableState === undefined || this._writableState === undefined) {
  	      return false;
  	    }
  	    return this._readableState.destroyed && this._writableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (this._readableState === undefined || this._writableState === undefined) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._readableState.destroyed = value;
  	    this._writableState.destroyed = value;
  	  }
  	});

  	Duplex.prototype._destroy = function (err, cb) {
  	  this.push(null);
  	  this.end();

  	  pna.nextTick(cb, err);
  	};
  	return _stream_duplex$1;
  }

  var string_decoder$1 = {};

  var hasRequiredString_decoder$1;

  function requireString_decoder$1 () {
  	if (hasRequiredString_decoder$1) return string_decoder$1;
  	hasRequiredString_decoder$1 = 1;

  	/*<replacement>*/

  	var Buffer = requireSafeBuffer().Buffer;
  	/*</replacement>*/

  	var isEncoding = Buffer.isEncoding || function (encoding) {
  	  encoding = '' + encoding;
  	  switch (encoding && encoding.toLowerCase()) {
  	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
  	      return true;
  	    default:
  	      return false;
  	  }
  	};

  	function _normalizeEncoding(enc) {
  	  if (!enc) return 'utf8';
  	  var retried;
  	  while (true) {
  	    switch (enc) {
  	      case 'utf8':
  	      case 'utf-8':
  	        return 'utf8';
  	      case 'ucs2':
  	      case 'ucs-2':
  	      case 'utf16le':
  	      case 'utf-16le':
  	        return 'utf16le';
  	      case 'latin1':
  	      case 'binary':
  	        return 'latin1';
  	      case 'base64':
  	      case 'ascii':
  	      case 'hex':
  	        return enc;
  	      default:
  	        if (retried) return; // undefined
  	        enc = ('' + enc).toLowerCase();
  	        retried = true;
  	    }
  	  }
  	}
  	// Do not cache `Buffer.isEncoding` when checking encoding names as some
  	// modules monkey-patch it to support additional encodings
  	function normalizeEncoding(enc) {
  	  var nenc = _normalizeEncoding(enc);
  	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  	  return nenc || enc;
  	}

  	// StringDecoder provides an interface for efficiently splitting a series of
  	// buffers into a series of JS strings without breaking apart multi-byte
  	// characters.
  	string_decoder$1.StringDecoder = StringDecoder;
  	function StringDecoder(encoding) {
  	  this.encoding = normalizeEncoding(encoding);
  	  var nb;
  	  switch (this.encoding) {
  	    case 'utf16le':
  	      this.text = utf16Text;
  	      this.end = utf16End;
  	      nb = 4;
  	      break;
  	    case 'utf8':
  	      this.fillLast = utf8FillLast;
  	      nb = 4;
  	      break;
  	    case 'base64':
  	      this.text = base64Text;
  	      this.end = base64End;
  	      nb = 3;
  	      break;
  	    default:
  	      this.write = simpleWrite;
  	      this.end = simpleEnd;
  	      return;
  	  }
  	  this.lastNeed = 0;
  	  this.lastTotal = 0;
  	  this.lastChar = Buffer.allocUnsafe(nb);
  	}

  	StringDecoder.prototype.write = function (buf) {
  	  if (buf.length === 0) return '';
  	  var r;
  	  var i;
  	  if (this.lastNeed) {
  	    r = this.fillLast(buf);
  	    if (r === undefined) return '';
  	    i = this.lastNeed;
  	    this.lastNeed = 0;
  	  } else {
  	    i = 0;
  	  }
  	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  	  return r || '';
  	};

  	StringDecoder.prototype.end = utf8End;

  	// Returns only complete characters in a Buffer
  	StringDecoder.prototype.text = utf8Text;

  	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  	StringDecoder.prototype.fillLast = function (buf) {
  	  if (this.lastNeed <= buf.length) {
  	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
  	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  	  }
  	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  	  this.lastNeed -= buf.length;
  	};

  	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  	// continuation byte. If an invalid byte is detected, -2 is returned.
  	function utf8CheckByte(byte) {
  	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  	  return byte >> 6 === 0x02 ? -1 : -2;
  	}

  	// Checks at most 3 bytes at the end of a Buffer in order to detect an
  	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  	// needed to complete the UTF-8 character (if applicable) are returned.
  	function utf8CheckIncomplete(self, buf, i) {
  	  var j = buf.length - 1;
  	  if (j < i) return 0;
  	  var nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) self.lastNeed = nb - 1;
  	    return nb;
  	  }
  	  if (--j < i || nb === -2) return 0;
  	  nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) self.lastNeed = nb - 2;
  	    return nb;
  	  }
  	  if (--j < i || nb === -2) return 0;
  	  nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) {
  	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
  	    }
  	    return nb;
  	  }
  	  return 0;
  	}

  	// Validates as many continuation bytes for a multi-byte UTF-8 character as
  	// needed or are available. If we see a non-continuation byte where we expect
  	// one, we "replace" the validated continuation bytes we've seen so far with
  	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
  	// behavior. The continuation byte check is included three times in the case
  	// where all of the continuation bytes for a character exist in the same buffer.
  	// It is also done this way as a slight performance increase instead of using a
  	// loop.
  	function utf8CheckExtraBytes(self, buf, p) {
  	  if ((buf[0] & 0xC0) !== 0x80) {
  	    self.lastNeed = 0;
  	    return '\ufffd';
  	  }
  	  if (self.lastNeed > 1 && buf.length > 1) {
  	    if ((buf[1] & 0xC0) !== 0x80) {
  	      self.lastNeed = 1;
  	      return '\ufffd';
  	    }
  	    if (self.lastNeed > 2 && buf.length > 2) {
  	      if ((buf[2] & 0xC0) !== 0x80) {
  	        self.lastNeed = 2;
  	        return '\ufffd';
  	      }
  	    }
  	  }
  	}

  	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  	function utf8FillLast(buf) {
  	  var p = this.lastTotal - this.lastNeed;
  	  var r = utf8CheckExtraBytes(this, buf);
  	  if (r !== undefined) return r;
  	  if (this.lastNeed <= buf.length) {
  	    buf.copy(this.lastChar, p, 0, this.lastNeed);
  	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  	  }
  	  buf.copy(this.lastChar, p, 0, buf.length);
  	  this.lastNeed -= buf.length;
  	}

  	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  	// partial character, the character's bytes are buffered until the required
  	// number of bytes are available.
  	function utf8Text(buf, i) {
  	  var total = utf8CheckIncomplete(this, buf, i);
  	  if (!this.lastNeed) return buf.toString('utf8', i);
  	  this.lastTotal = total;
  	  var end = buf.length - (total - this.lastNeed);
  	  buf.copy(this.lastChar, 0, end);
  	  return buf.toString('utf8', i, end);
  	}

  	// For UTF-8, a replacement character is added when ending on a partial
  	// character.
  	function utf8End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) return r + '\ufffd';
  	  return r;
  	}

  	// UTF-16LE typically needs two bytes per character, but even if we have an even
  	// number of bytes available, we need to check if we end on a leading/high
  	// surrogate. In that case, we need to wait for the next two bytes in order to
  	// decode the last character properly.
  	function utf16Text(buf, i) {
  	  if ((buf.length - i) % 2 === 0) {
  	    var r = buf.toString('utf16le', i);
  	    if (r) {
  	      var c = r.charCodeAt(r.length - 1);
  	      if (c >= 0xD800 && c <= 0xDBFF) {
  	        this.lastNeed = 2;
  	        this.lastTotal = 4;
  	        this.lastChar[0] = buf[buf.length - 2];
  	        this.lastChar[1] = buf[buf.length - 1];
  	        return r.slice(0, -1);
  	      }
  	    }
  	    return r;
  	  }
  	  this.lastNeed = 1;
  	  this.lastTotal = 2;
  	  this.lastChar[0] = buf[buf.length - 1];
  	  return buf.toString('utf16le', i, buf.length - 1);
  	}

  	// For UTF-16LE we do not explicitly append special replacement characters if we
  	// end on a partial character, we simply let v8 handle that.
  	function utf16End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) {
  	    var end = this.lastTotal - this.lastNeed;
  	    return r + this.lastChar.toString('utf16le', 0, end);
  	  }
  	  return r;
  	}

  	function base64Text(buf, i) {
  	  var n = (buf.length - i) % 3;
  	  if (n === 0) return buf.toString('base64', i);
  	  this.lastNeed = 3 - n;
  	  this.lastTotal = 3;
  	  if (n === 1) {
  	    this.lastChar[0] = buf[buf.length - 1];
  	  } else {
  	    this.lastChar[0] = buf[buf.length - 2];
  	    this.lastChar[1] = buf[buf.length - 1];
  	  }
  	  return buf.toString('base64', i, buf.length - n);
  	}

  	function base64End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  	  return r;
  	}

  	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  	function simpleWrite(buf) {
  	  return buf.toString(this.encoding);
  	}

  	function simpleEnd(buf) {
  	  return buf && buf.length ? this.write(buf) : '';
  	}
  	return string_decoder$1;
  }

  var _stream_readable$1;
  var hasRequired_stream_readable$1;

  function require_stream_readable$1 () {
  	if (hasRequired_stream_readable$1) return _stream_readable$1;
  	hasRequired_stream_readable$1 = 1;

  	/*<replacement>*/

  	var pna = requireProcessNextickArgs();
  	/*</replacement>*/

  	_stream_readable$1 = Readable;

  	/*<replacement>*/
  	var isArray = requireIsarray();
  	/*</replacement>*/

  	/*<replacement>*/
  	var Duplex;
  	/*</replacement>*/

  	Readable.ReadableState = ReadableState;

  	/*<replacement>*/
  	require$$2.EventEmitter;

  	var EElistenerCount = function (emitter, type) {
  	  return emitter.listeners(type).length;
  	};
  	/*</replacement>*/

  	/*<replacement>*/
  	var Stream = requireStreamBrowser();
  	/*</replacement>*/

  	/*<replacement>*/

  	var Buffer = requireSafeBuffer().Buffer;
  	var OurUint8Array = commonjsGlobal.Uint8Array || function () {};
  	function _uint8ArrayToBuffer(chunk) {
  	  return Buffer.from(chunk);
  	}
  	function _isUint8Array(obj) {
  	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  	}

  	/*</replacement>*/

  	/*<replacement>*/
  	var util = Object.create(requireUtil());
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	/*<replacement>*/
  	var debugUtil = require$$0$1;
  	var debug = void 0;
  	if (debugUtil && debugUtil.debuglog) {
  	  debug = debugUtil.debuglog('stream');
  	} else {
  	  debug = function () {};
  	}
  	/*</replacement>*/

  	var BufferList = requireBufferList$1();
  	var destroyImpl = requireDestroy();
  	var StringDecoder;

  	util.inherits(Readable, Stream);

  	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

  	function prependListener(emitter, event, fn) {
  	  // Sadly this is not cacheable as some libraries bundle their own
  	  // event emitter implementation with them.
  	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  	  // This is a hack to make sure that our error handler is attached before any
  	  // userland ones.  NEVER DO THIS. This is here only because this code needs
  	  // to continue to work with older versions of Node.js that do not include
  	  // the prependListener() method. The goal is to eventually remove this hack.
  	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  	}

  	function ReadableState(options, stream) {
  	  Duplex = Duplex || require_stream_duplex$1();

  	  options = options || {};

  	  // Duplex streams are both readable and writable, but share
  	  // the same options object.
  	  // However, some cases require setting options to different
  	  // values for the readable and the writable sides of the duplex stream.
  	  // These options can be provided separately as readableXXX and writableXXX.
  	  var isDuplex = stream instanceof Duplex;

  	  // object stream flag. Used to make read(n) ignore n and to
  	  // make all the buffer merging and length checks go away
  	  this.objectMode = !!options.objectMode;

  	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  	  // the point at which it stops calling _read() to fill the buffer
  	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  	  var hwm = options.highWaterMark;
  	  var readableHwm = options.readableHighWaterMark;
  	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  	  // cast to ints.
  	  this.highWaterMark = Math.floor(this.highWaterMark);

  	  // A linked list is used to store data chunks instead of an array because the
  	  // linked list can remove elements from the beginning faster than
  	  // array.shift()
  	  this.buffer = new BufferList();
  	  this.length = 0;
  	  this.pipes = null;
  	  this.pipesCount = 0;
  	  this.flowing = null;
  	  this.ended = false;
  	  this.endEmitted = false;
  	  this.reading = false;

  	  // a flag to be able to tell if the event 'readable'/'data' is emitted
  	  // immediately, or on a later tick.  We set this to true at first, because
  	  // any actions that shouldn't happen until "later" should generally also
  	  // not happen before the first read call.
  	  this.sync = true;

  	  // whenever we return null, then we set a flag to say
  	  // that we're awaiting a 'readable' event emission.
  	  this.needReadable = false;
  	  this.emittedReadable = false;
  	  this.readableListening = false;
  	  this.resumeScheduled = false;

  	  // has it been destroyed
  	  this.destroyed = false;

  	  // Crypto is kind of old and crusty.  Historically, its default string
  	  // encoding is 'binary' so we have to make this configurable.
  	  // Everything else in the universe uses 'utf8', though.
  	  this.defaultEncoding = options.defaultEncoding || 'utf8';

  	  // the number of writers that are awaiting a drain event in .pipe()s
  	  this.awaitDrain = 0;

  	  // if true, a maybeReadMore has been scheduled
  	  this.readingMore = false;

  	  this.decoder = null;
  	  this.encoding = null;
  	  if (options.encoding) {
  	    if (!StringDecoder) StringDecoder = requireString_decoder$1().StringDecoder;
  	    this.decoder = new StringDecoder(options.encoding);
  	    this.encoding = options.encoding;
  	  }
  	}

  	function Readable(options) {
  	  Duplex = Duplex || require_stream_duplex$1();

  	  if (!(this instanceof Readable)) return new Readable(options);

  	  this._readableState = new ReadableState(options, this);

  	  // legacy
  	  this.readable = true;

  	  if (options) {
  	    if (typeof options.read === 'function') this._read = options.read;

  	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  	  }

  	  Stream.call(this);
  	}

  	Object.defineProperty(Readable.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._readableState === undefined) {
  	      return false;
  	    }
  	    return this._readableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (!this._readableState) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._readableState.destroyed = value;
  	  }
  	});

  	Readable.prototype.destroy = destroyImpl.destroy;
  	Readable.prototype._undestroy = destroyImpl.undestroy;
  	Readable.prototype._destroy = function (err, cb) {
  	  this.push(null);
  	  cb(err);
  	};

  	// Manually shove something into the read() buffer.
  	// This returns true if the highWaterMark has not been hit yet,
  	// similar to how Writable.write() returns true if you should
  	// write() some more.
  	Readable.prototype.push = function (chunk, encoding) {
  	  var state = this._readableState;
  	  var skipChunkCheck;

  	  if (!state.objectMode) {
  	    if (typeof chunk === 'string') {
  	      encoding = encoding || state.defaultEncoding;
  	      if (encoding !== state.encoding) {
  	        chunk = Buffer.from(chunk, encoding);
  	        encoding = '';
  	      }
  	      skipChunkCheck = true;
  	    }
  	  } else {
  	    skipChunkCheck = true;
  	  }

  	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  	};

  	// Unshift should *always* be something directly out of read()
  	Readable.prototype.unshift = function (chunk) {
  	  return readableAddChunk(this, chunk, null, true, false);
  	};

  	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  	  var state = stream._readableState;
  	  if (chunk === null) {
  	    state.reading = false;
  	    onEofChunk(stream, state);
  	  } else {
  	    var er;
  	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
  	    if (er) {
  	      stream.emit('error', er);
  	    } else if (state.objectMode || chunk && chunk.length > 0) {
  	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
  	        chunk = _uint8ArrayToBuffer(chunk);
  	      }

  	      if (addToFront) {
  	        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
  	      } else if (state.ended) {
  	        stream.emit('error', new Error('stream.push() after EOF'));
  	      } else {
  	        state.reading = false;
  	        if (state.decoder && !encoding) {
  	          chunk = state.decoder.write(chunk);
  	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
  	        } else {
  	          addChunk(stream, state, chunk, false);
  	        }
  	      }
  	    } else if (!addToFront) {
  	      state.reading = false;
  	    }
  	  }

  	  return needMoreData(state);
  	}

  	function addChunk(stream, state, chunk, addToFront) {
  	  if (state.flowing && state.length === 0 && !state.sync) {
  	    stream.emit('data', chunk);
  	    stream.read(0);
  	  } else {
  	    // update the buffer info.
  	    state.length += state.objectMode ? 1 : chunk.length;
  	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

  	    if (state.needReadable) emitReadable(stream);
  	  }
  	  maybeReadMore(stream, state);
  	}

  	function chunkInvalid(state, chunk) {
  	  var er;
  	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
  	    er = new TypeError('Invalid non-string/buffer chunk');
  	  }
  	  return er;
  	}

  	// if it's past the high water mark, we can push in some more.
  	// Also, if we have no data yet, we can stand some
  	// more bytes.  This is to work around cases where hwm=0,
  	// such as the repl.  Also, if the push() triggered a
  	// readable event, and the user called read(largeNumber) such that
  	// needReadable was set, then we ought to push more, so that another
  	// 'readable' event will be triggered.
  	function needMoreData(state) {
  	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  	}

  	Readable.prototype.isPaused = function () {
  	  return this._readableState.flowing === false;
  	};

  	// backwards compatibility.
  	Readable.prototype.setEncoding = function (enc) {
  	  if (!StringDecoder) StringDecoder = requireString_decoder$1().StringDecoder;
  	  this._readableState.decoder = new StringDecoder(enc);
  	  this._readableState.encoding = enc;
  	  return this;
  	};

  	// Don't raise the hwm > 8MB
  	var MAX_HWM = 0x800000;
  	function computeNewHighWaterMark(n) {
  	  if (n >= MAX_HWM) {
  	    n = MAX_HWM;
  	  } else {
  	    // Get the next highest power of 2 to prevent increasing hwm excessively in
  	    // tiny amounts
  	    n--;
  	    n |= n >>> 1;
  	    n |= n >>> 2;
  	    n |= n >>> 4;
  	    n |= n >>> 8;
  	    n |= n >>> 16;
  	    n++;
  	  }
  	  return n;
  	}

  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function howMuchToRead(n, state) {
  	  if (n <= 0 || state.length === 0 && state.ended) return 0;
  	  if (state.objectMode) return 1;
  	  if (n !== n) {
  	    // Only flow one buffer at a time
  	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  	  }
  	  // If we're asking for more than the current hwm, then raise the hwm.
  	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  	  if (n <= state.length) return n;
  	  // Don't have enough
  	  if (!state.ended) {
  	    state.needReadable = true;
  	    return 0;
  	  }
  	  return state.length;
  	}

  	// you can override either this method, or the async _read(n) below.
  	Readable.prototype.read = function (n) {
  	  debug('read', n);
  	  n = parseInt(n, 10);
  	  var state = this._readableState;
  	  var nOrig = n;

  	  if (n !== 0) state.emittedReadable = false;

  	  // if we're doing read(0) to trigger a readable event, but we
  	  // already have a bunch of data in the buffer, then just trigger
  	  // the 'readable' event and move on.
  	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
  	    debug('read: emitReadable', state.length, state.ended);
  	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
  	    return null;
  	  }

  	  n = howMuchToRead(n, state);

  	  // if we've ended, and we're now clear, then finish it up.
  	  if (n === 0 && state.ended) {
  	    if (state.length === 0) endReadable(this);
  	    return null;
  	  }

  	  // All the actual chunk generation logic needs to be
  	  // *below* the call to _read.  The reason is that in certain
  	  // synthetic stream cases, such as passthrough streams, _read
  	  // may be a completely synchronous operation which may change
  	  // the state of the read buffer, providing enough data when
  	  // before there was *not* enough.
  	  //
  	  // So, the steps are:
  	  // 1. Figure out what the state of things will be after we do
  	  // a read from the buffer.
  	  //
  	  // 2. If that resulting state will trigger a _read, then call _read.
  	  // Note that this may be asynchronous, or synchronous.  Yes, it is
  	  // deeply ugly to write APIs this way, but that still doesn't mean
  	  // that the Readable class should behave improperly, as streams are
  	  // designed to be sync/async agnostic.
  	  // Take note if the _read call is sync or async (ie, if the read call
  	  // has returned yet), so that we know whether or not it's safe to emit
  	  // 'readable' etc.
  	  //
  	  // 3. Actually pull the requested chunks out of the buffer and return.

  	  // if we need a readable event, then we need to do some reading.
  	  var doRead = state.needReadable;
  	  debug('need readable', doRead);

  	  // if we currently have less than the highWaterMark, then also read some
  	  if (state.length === 0 || state.length - n < state.highWaterMark) {
  	    doRead = true;
  	    debug('length less than watermark', doRead);
  	  }

  	  // however, if we've ended, then there's no point, and if we're already
  	  // reading, then it's unnecessary.
  	  if (state.ended || state.reading) {
  	    doRead = false;
  	    debug('reading or ended', doRead);
  	  } else if (doRead) {
  	    debug('do read');
  	    state.reading = true;
  	    state.sync = true;
  	    // if the length is currently zero, then we *need* a readable event.
  	    if (state.length === 0) state.needReadable = true;
  	    // call internal read method
  	    this._read(state.highWaterMark);
  	    state.sync = false;
  	    // If _read pushed data synchronously, then `reading` will be false,
  	    // and we need to re-evaluate how much data we can return to the user.
  	    if (!state.reading) n = howMuchToRead(nOrig, state);
  	  }

  	  var ret;
  	  if (n > 0) ret = fromList(n, state);else ret = null;

  	  if (ret === null) {
  	    state.needReadable = true;
  	    n = 0;
  	  } else {
  	    state.length -= n;
  	  }

  	  if (state.length === 0) {
  	    // If we have nothing in the buffer, then we want to know
  	    // as soon as we *do* get something into the buffer.
  	    if (!state.ended) state.needReadable = true;

  	    // If we tried to read() past the EOF, then emit end on the next tick.
  	    if (nOrig !== n && state.ended) endReadable(this);
  	  }

  	  if (ret !== null) this.emit('data', ret);

  	  return ret;
  	};

  	function onEofChunk(stream, state) {
  	  if (state.ended) return;
  	  if (state.decoder) {
  	    var chunk = state.decoder.end();
  	    if (chunk && chunk.length) {
  	      state.buffer.push(chunk);
  	      state.length += state.objectMode ? 1 : chunk.length;
  	    }
  	  }
  	  state.ended = true;

  	  // emit 'readable' now to make sure it gets picked up.
  	  emitReadable(stream);
  	}

  	// Don't emit readable right away in sync mode, because this can trigger
  	// another read() call => stack overflow.  This way, it might trigger
  	// a nextTick recursion warning, but that's not so bad.
  	function emitReadable(stream) {
  	  var state = stream._readableState;
  	  state.needReadable = false;
  	  if (!state.emittedReadable) {
  	    debug('emitReadable', state.flowing);
  	    state.emittedReadable = true;
  	    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  	  }
  	}

  	function emitReadable_(stream) {
  	  debug('emit readable');
  	  stream.emit('readable');
  	  flow(stream);
  	}

  	// at this point, the user has presumably seen the 'readable' event,
  	// and called read() to consume some data.  that may have triggered
  	// in turn another _read(n) call, in which case reading = true if
  	// it's in progress.
  	// However, if we're not ended, or reading, and the length < hwm,
  	// then go ahead and try to read some more preemptively.
  	function maybeReadMore(stream, state) {
  	  if (!state.readingMore) {
  	    state.readingMore = true;
  	    pna.nextTick(maybeReadMore_, stream, state);
  	  }
  	}

  	function maybeReadMore_(stream, state) {
  	  var len = state.length;
  	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
  	    debug('maybeReadMore read 0');
  	    stream.read(0);
  	    if (len === state.length)
  	      // didn't get any data, stop spinning.
  	      break;else len = state.length;
  	  }
  	  state.readingMore = false;
  	}

  	// abstract method.  to be overridden in specific implementation classes.
  	// call cb(er, data) where data is <= n in length.
  	// for virtual (non-string, non-buffer) streams, "length" is somewhat
  	// arbitrary, and perhaps not very meaningful.
  	Readable.prototype._read = function (n) {
  	  this.emit('error', new Error('_read() is not implemented'));
  	};

  	Readable.prototype.pipe = function (dest, pipeOpts) {
  	  var src = this;
  	  var state = this._readableState;

  	  switch (state.pipesCount) {
  	    case 0:
  	      state.pipes = dest;
  	      break;
  	    case 1:
  	      state.pipes = [state.pipes, dest];
  	      break;
  	    default:
  	      state.pipes.push(dest);
  	      break;
  	  }
  	  state.pipesCount += 1;
  	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;

  	  var endFn = doEnd ? onend : unpipe;
  	  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  	  dest.on('unpipe', onunpipe);
  	  function onunpipe(readable, unpipeInfo) {
  	    debug('onunpipe');
  	    if (readable === src) {
  	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
  	        unpipeInfo.hasUnpiped = true;
  	        cleanup();
  	      }
  	    }
  	  }

  	  function onend() {
  	    debug('onend');
  	    dest.end();
  	  }

  	  // when the dest drains, it reduces the awaitDrain counter
  	  // on the source.  This would be more elegant with a .once()
  	  // handler in flow(), but adding and removing repeatedly is
  	  // too slow.
  	  var ondrain = pipeOnDrain(src);
  	  dest.on('drain', ondrain);

  	  var cleanedUp = false;
  	  function cleanup() {
  	    debug('cleanup');
  	    // cleanup event handlers once the pipe is broken
  	    dest.removeListener('close', onclose);
  	    dest.removeListener('finish', onfinish);
  	    dest.removeListener('drain', ondrain);
  	    dest.removeListener('error', onerror);
  	    dest.removeListener('unpipe', onunpipe);
  	    src.removeListener('end', onend);
  	    src.removeListener('end', unpipe);
  	    src.removeListener('data', ondata);

  	    cleanedUp = true;

  	    // if the reader is waiting for a drain event from this
  	    // specific writer, then it would cause it to never start
  	    // flowing again.
  	    // So, if this is awaiting a drain, then we just call it now.
  	    // If we don't know, then assume that we are waiting for one.
  	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  	  }

  	  // If the user pushes more data while we're writing to dest then we'll end up
  	  // in ondata again. However, we only want to increase awaitDrain once because
  	  // dest will only emit one 'drain' event for the multiple writes.
  	  // => Introduce a guard on increasing awaitDrain.
  	  var increasedAwaitDrain = false;
  	  src.on('data', ondata);
  	  function ondata(chunk) {
  	    debug('ondata');
  	    increasedAwaitDrain = false;
  	    var ret = dest.write(chunk);
  	    if (false === ret && !increasedAwaitDrain) {
  	      // If the user unpiped during `dest.write()`, it is possible
  	      // to get stuck in a permanently paused state if that write
  	      // also returned false.
  	      // => Check whether `dest` is still a piping destination.
  	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
  	        debug('false write response, pause', src._readableState.awaitDrain);
  	        src._readableState.awaitDrain++;
  	        increasedAwaitDrain = true;
  	      }
  	      src.pause();
  	    }
  	  }

  	  // if the dest has an error, then stop piping into it.
  	  // however, don't suppress the throwing behavior for this.
  	  function onerror(er) {
  	    debug('onerror', er);
  	    unpipe();
  	    dest.removeListener('error', onerror);
  	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  	  }

  	  // Make sure our error handler is attached before userland ones.
  	  prependListener(dest, 'error', onerror);

  	  // Both close and finish should trigger unpipe, but only once.
  	  function onclose() {
  	    dest.removeListener('finish', onfinish);
  	    unpipe();
  	  }
  	  dest.once('close', onclose);
  	  function onfinish() {
  	    debug('onfinish');
  	    dest.removeListener('close', onclose);
  	    unpipe();
  	  }
  	  dest.once('finish', onfinish);

  	  function unpipe() {
  	    debug('unpipe');
  	    src.unpipe(dest);
  	  }

  	  // tell the dest that it's being piped to
  	  dest.emit('pipe', src);

  	  // start the flow if it hasn't been started already.
  	  if (!state.flowing) {
  	    debug('pipe resume');
  	    src.resume();
  	  }

  	  return dest;
  	};

  	function pipeOnDrain(src) {
  	  return function () {
  	    var state = src._readableState;
  	    debug('pipeOnDrain', state.awaitDrain);
  	    if (state.awaitDrain) state.awaitDrain--;
  	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
  	      state.flowing = true;
  	      flow(src);
  	    }
  	  };
  	}

  	Readable.prototype.unpipe = function (dest) {
  	  var state = this._readableState;
  	  var unpipeInfo = { hasUnpiped: false };

  	  // if we're not piping anywhere, then do nothing.
  	  if (state.pipesCount === 0) return this;

  	  // just one destination.  most common case.
  	  if (state.pipesCount === 1) {
  	    // passed in one, but it's not the right one.
  	    if (dest && dest !== state.pipes) return this;

  	    if (!dest) dest = state.pipes;

  	    // got a match.
  	    state.pipes = null;
  	    state.pipesCount = 0;
  	    state.flowing = false;
  	    if (dest) dest.emit('unpipe', this, unpipeInfo);
  	    return this;
  	  }

  	  // slow case. multiple pipe destinations.

  	  if (!dest) {
  	    // remove all.
  	    var dests = state.pipes;
  	    var len = state.pipesCount;
  	    state.pipes = null;
  	    state.pipesCount = 0;
  	    state.flowing = false;

  	    for (var i = 0; i < len; i++) {
  	      dests[i].emit('unpipe', this, unpipeInfo);
  	    }return this;
  	  }

  	  // try to find the right one.
  	  var index = indexOf(state.pipes, dest);
  	  if (index === -1) return this;

  	  state.pipes.splice(index, 1);
  	  state.pipesCount -= 1;
  	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  	  dest.emit('unpipe', this, unpipeInfo);

  	  return this;
  	};

  	// set up data events if they are asked for
  	// Ensure readable listeners eventually get something
  	Readable.prototype.on = function (ev, fn) {
  	  var res = Stream.prototype.on.call(this, ev, fn);

  	  if (ev === 'data') {
  	    // Start flowing on next tick if stream isn't explicitly paused
  	    if (this._readableState.flowing !== false) this.resume();
  	  } else if (ev === 'readable') {
  	    var state = this._readableState;
  	    if (!state.endEmitted && !state.readableListening) {
  	      state.readableListening = state.needReadable = true;
  	      state.emittedReadable = false;
  	      if (!state.reading) {
  	        pna.nextTick(nReadingNextTick, this);
  	      } else if (state.length) {
  	        emitReadable(this);
  	      }
  	    }
  	  }

  	  return res;
  	};
  	Readable.prototype.addListener = Readable.prototype.on;

  	function nReadingNextTick(self) {
  	  debug('readable nexttick read 0');
  	  self.read(0);
  	}

  	// pause() and resume() are remnants of the legacy readable stream API
  	// If the user uses them, then switch into old mode.
  	Readable.prototype.resume = function () {
  	  var state = this._readableState;
  	  if (!state.flowing) {
  	    debug('resume');
  	    state.flowing = true;
  	    resume(this, state);
  	  }
  	  return this;
  	};

  	function resume(stream, state) {
  	  if (!state.resumeScheduled) {
  	    state.resumeScheduled = true;
  	    pna.nextTick(resume_, stream, state);
  	  }
  	}

  	function resume_(stream, state) {
  	  if (!state.reading) {
  	    debug('resume read 0');
  	    stream.read(0);
  	  }

  	  state.resumeScheduled = false;
  	  state.awaitDrain = 0;
  	  stream.emit('resume');
  	  flow(stream);
  	  if (state.flowing && !state.reading) stream.read(0);
  	}

  	Readable.prototype.pause = function () {
  	  debug('call pause flowing=%j', this._readableState.flowing);
  	  if (false !== this._readableState.flowing) {
  	    debug('pause');
  	    this._readableState.flowing = false;
  	    this.emit('pause');
  	  }
  	  return this;
  	};

  	function flow(stream) {
  	  var state = stream._readableState;
  	  debug('flow', state.flowing);
  	  while (state.flowing && stream.read() !== null) {}
  	}

  	// wrap an old-style stream as the async data source.
  	// This is *not* part of the readable stream interface.
  	// It is an ugly unfortunate mess of history.
  	Readable.prototype.wrap = function (stream) {
  	  var _this = this;

  	  var state = this._readableState;
  	  var paused = false;

  	  stream.on('end', function () {
  	    debug('wrapped end');
  	    if (state.decoder && !state.ended) {
  	      var chunk = state.decoder.end();
  	      if (chunk && chunk.length) _this.push(chunk);
  	    }

  	    _this.push(null);
  	  });

  	  stream.on('data', function (chunk) {
  	    debug('wrapped data');
  	    if (state.decoder) chunk = state.decoder.write(chunk);

  	    // don't skip over falsy values in objectMode
  	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

  	    var ret = _this.push(chunk);
  	    if (!ret) {
  	      paused = true;
  	      stream.pause();
  	    }
  	  });

  	  // proxy all the other methods.
  	  // important when wrapping filters and duplexes.
  	  for (var i in stream) {
  	    if (this[i] === undefined && typeof stream[i] === 'function') {
  	      this[i] = function (method) {
  	        return function () {
  	          return stream[method].apply(stream, arguments);
  	        };
  	      }(i);
  	    }
  	  }

  	  // proxy certain important events.
  	  for (var n = 0; n < kProxyEvents.length; n++) {
  	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  	  }

  	  // when we try to consume some more bytes, simply unpause the
  	  // underlying stream.
  	  this._read = function (n) {
  	    debug('wrapped _read', n);
  	    if (paused) {
  	      paused = false;
  	      stream.resume();
  	    }
  	  };

  	  return this;
  	};

  	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  	  // making it explicit this property is not enumerable
  	  // because otherwise some prototype manipulation in
  	  // userland will fail
  	  enumerable: false,
  	  get: function () {
  	    return this._readableState.highWaterMark;
  	  }
  	});

  	// exposed for testing purposes only.
  	Readable._fromList = fromList;

  	// Pluck off n bytes from an array of buffers.
  	// Length is the combined lengths of all the buffers in the list.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function fromList(n, state) {
  	  // nothing buffered
  	  if (state.length === 0) return null;

  	  var ret;
  	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
  	    // read it all, truncate the list
  	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
  	    state.buffer.clear();
  	  } else {
  	    // read part of list
  	    ret = fromListPartial(n, state.buffer, state.decoder);
  	  }

  	  return ret;
  	}

  	// Extracts only enough buffered data to satisfy the amount requested.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function fromListPartial(n, list, hasStrings) {
  	  var ret;
  	  if (n < list.head.data.length) {
  	    // slice is the same for buffers and strings
  	    ret = list.head.data.slice(0, n);
  	    list.head.data = list.head.data.slice(n);
  	  } else if (n === list.head.data.length) {
  	    // first chunk is a perfect match
  	    ret = list.shift();
  	  } else {
  	    // result spans more than one buffer
  	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  	  }
  	  return ret;
  	}

  	// Copies a specified amount of characters from the list of buffered data
  	// chunks.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function copyFromBufferString(n, list) {
  	  var p = list.head;
  	  var c = 1;
  	  var ret = p.data;
  	  n -= ret.length;
  	  while (p = p.next) {
  	    var str = p.data;
  	    var nb = n > str.length ? str.length : n;
  	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
  	    n -= nb;
  	    if (n === 0) {
  	      if (nb === str.length) {
  	        ++c;
  	        if (p.next) list.head = p.next;else list.head = list.tail = null;
  	      } else {
  	        list.head = p;
  	        p.data = str.slice(nb);
  	      }
  	      break;
  	    }
  	    ++c;
  	  }
  	  list.length -= c;
  	  return ret;
  	}

  	// Copies a specified amount of bytes from the list of buffered data chunks.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function copyFromBuffer(n, list) {
  	  var ret = Buffer.allocUnsafe(n);
  	  var p = list.head;
  	  var c = 1;
  	  p.data.copy(ret);
  	  n -= p.data.length;
  	  while (p = p.next) {
  	    var buf = p.data;
  	    var nb = n > buf.length ? buf.length : n;
  	    buf.copy(ret, ret.length - n, 0, nb);
  	    n -= nb;
  	    if (n === 0) {
  	      if (nb === buf.length) {
  	        ++c;
  	        if (p.next) list.head = p.next;else list.head = list.tail = null;
  	      } else {
  	        list.head = p;
  	        p.data = buf.slice(nb);
  	      }
  	      break;
  	    }
  	    ++c;
  	  }
  	  list.length -= c;
  	  return ret;
  	}

  	function endReadable(stream) {
  	  var state = stream._readableState;

  	  // If we get here before consuming all the bytes, then that is a
  	  // bug in node.  Should never happen.
  	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  	  if (!state.endEmitted) {
  	    state.ended = true;
  	    pna.nextTick(endReadableNT, state, stream);
  	  }
  	}

  	function endReadableNT(state, stream) {
  	  // Check that we didn't get one last unshift.
  	  if (!state.endEmitted && state.length === 0) {
  	    state.endEmitted = true;
  	    stream.readable = false;
  	    stream.emit('end');
  	  }
  	}

  	function indexOf(xs, x) {
  	  for (var i = 0, l = xs.length; i < l; i++) {
  	    if (xs[i] === x) return i;
  	  }
  	  return -1;
  	}
  	return _stream_readable$1;
  }

  var _stream_transform$1;
  var hasRequired_stream_transform;

  function require_stream_transform () {
  	if (hasRequired_stream_transform) return _stream_transform$1;
  	hasRequired_stream_transform = 1;

  	_stream_transform$1 = Transform;

  	var Duplex = require_stream_duplex$1();

  	/*<replacement>*/
  	var util = Object.create(requireUtil());
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	util.inherits(Transform, Duplex);

  	function afterTransform(er, data) {
  	  var ts = this._transformState;
  	  ts.transforming = false;

  	  var cb = ts.writecb;

  	  if (!cb) {
  	    return this.emit('error', new Error('write callback called multiple times'));
  	  }

  	  ts.writechunk = null;
  	  ts.writecb = null;

  	  if (data != null) // single equals check for both `null` and `undefined`
  	    this.push(data);

  	  cb(er);

  	  var rs = this._readableState;
  	  rs.reading = false;
  	  if (rs.needReadable || rs.length < rs.highWaterMark) {
  	    this._read(rs.highWaterMark);
  	  }
  	}

  	function Transform(options) {
  	  if (!(this instanceof Transform)) return new Transform(options);

  	  Duplex.call(this, options);

  	  this._transformState = {
  	    afterTransform: afterTransform.bind(this),
  	    needTransform: false,
  	    transforming: false,
  	    writecb: null,
  	    writechunk: null,
  	    writeencoding: null
  	  };

  	  // start out asking for a readable event once data is transformed.
  	  this._readableState.needReadable = true;

  	  // we have implemented the _read method, and done the other things
  	  // that Readable wants before the first _read call, so unset the
  	  // sync guard flag.
  	  this._readableState.sync = false;

  	  if (options) {
  	    if (typeof options.transform === 'function') this._transform = options.transform;

  	    if (typeof options.flush === 'function') this._flush = options.flush;
  	  }

  	  // When the writable side finishes, then flush out anything remaining.
  	  this.on('prefinish', prefinish);
  	}

  	function prefinish() {
  	  var _this = this;

  	  if (typeof this._flush === 'function') {
  	    this._flush(function (er, data) {
  	      done(_this, er, data);
  	    });
  	  } else {
  	    done(this, null, null);
  	  }
  	}

  	Transform.prototype.push = function (chunk, encoding) {
  	  this._transformState.needTransform = false;
  	  return Duplex.prototype.push.call(this, chunk, encoding);
  	};

  	// This is the part where you do stuff!
  	// override this function in implementation classes.
  	// 'chunk' is an input chunk.
  	//
  	// Call `push(newChunk)` to pass along transformed output
  	// to the readable side.  You may call 'push' zero or more times.
  	//
  	// Call `cb(err)` when you are done with this chunk.  If you pass
  	// an error, then that'll put the hurt on the whole operation.  If you
  	// never call cb(), then you'll never get another chunk.
  	Transform.prototype._transform = function (chunk, encoding, cb) {
  	  throw new Error('_transform() is not implemented');
  	};

  	Transform.prototype._write = function (chunk, encoding, cb) {
  	  var ts = this._transformState;
  	  ts.writecb = cb;
  	  ts.writechunk = chunk;
  	  ts.writeencoding = encoding;
  	  if (!ts.transforming) {
  	    var rs = this._readableState;
  	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  	  }
  	};

  	// Doesn't matter what the args are here.
  	// _transform does all the work.
  	// That we got here means that the readable side wants more data.
  	Transform.prototype._read = function (n) {
  	  var ts = this._transformState;

  	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
  	    ts.transforming = true;
  	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  	  } else {
  	    // mark that we need a transform, so that any data that comes in
  	    // will get processed, now that we've asked for it.
  	    ts.needTransform = true;
  	  }
  	};

  	Transform.prototype._destroy = function (err, cb) {
  	  var _this2 = this;

  	  Duplex.prototype._destroy.call(this, err, function (err2) {
  	    cb(err2);
  	    _this2.emit('close');
  	  });
  	};

  	function done(stream, er, data) {
  	  if (er) return stream.emit('error', er);

  	  if (data != null) // single equals check for both `null` and `undefined`
  	    stream.push(data);

  	  // if there's nothing in the write buffer, then that means
  	  // that nothing more will ever be provided
  	  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  	  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  	  return stream.push(null);
  	}
  	return _stream_transform$1;
  }

  var _stream_passthrough$1;
  var hasRequired_stream_passthrough;

  function require_stream_passthrough () {
  	if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  	hasRequired_stream_passthrough = 1;

  	_stream_passthrough$1 = PassThrough;

  	var Transform = require_stream_transform();

  	/*<replacement>*/
  	var util = Object.create(requireUtil());
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	util.inherits(PassThrough, Transform);

  	function PassThrough(options) {
  	  if (!(this instanceof PassThrough)) return new PassThrough(options);

  	  Transform.call(this, options);
  	}

  	PassThrough.prototype._transform = function (chunk, encoding, cb) {
  	  cb(null, chunk);
  	};
  	return _stream_passthrough$1;
  }

  (function (module, exports) {
  	exports = module.exports = require_stream_readable$1();
  	exports.Stream = exports;
  	exports.Readable = exports;
  	exports.Writable = require_stream_writable$1();
  	exports.Duplex = require_stream_duplex$1();
  	exports.Transform = require_stream_transform();
  	exports.PassThrough = require_stream_passthrough();
  } (readableBrowser$1, readableBrowser$1.exports));

  Object.defineProperty(createEngineStream$1, "__esModule", { value: true });
  const readable_stream_1$4 = readableBrowser$1.exports;
  /**
   * Takes a JsonRpcEngine and returns a Duplex stream wrapping it.
   *
   * @param opts - Options bag.
   * @param opts.engine - The JsonRpcEngine to wrap in a stream.
   * @returns The stream wrapping the engine.
   */
  function createEngineStream(opts) {
      if (!opts || !opts.engine) {
          throw new Error('Missing engine parameter!');
      }
      const { engine } = opts;
      const stream = new readable_stream_1$4.Duplex({ objectMode: true, read, write });
      // forward notifications
      if (engine.on) {
          engine.on('notification', (message) => {
              stream.push(message);
          });
      }
      return stream;
      function read() {
          return undefined;
      }
      function write(req, _encoding, cb) {
          engine.handle(req, (_err, res) => {
              stream.push(res);
          });
          cb();
      }
  }
  createEngineStream$1.default = createEngineStream;

  var createStreamMiddleware$1 = {};

  var __importDefault$8 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(createStreamMiddleware$1, "__esModule", { value: true });
  const safe_event_emitter_1$1 = __importDefault$8(safeEventEmitter);
  const readable_stream_1$3 = readableBrowser$1.exports;
  /**
   * Creates a JsonRpcEngine middleware with an associated Duplex stream and
   * EventEmitter. The middleware, and by extension stream, assume that middleware
   * parameters are properly formatted. No runtime type checking or validation is
   * performed.
   *
   * @returns The event emitter, middleware, and stream.
   */
  function createStreamMiddleware() {
      const idMap = {};
      const stream = new readable_stream_1$3.Duplex({
          objectMode: true,
          read: readNoop,
          write: processMessage,
      });
      const events = new safe_event_emitter_1$1.default();
      const middleware = (req, res, next, end) => {
          // write req to stream
          stream.push(req);
          // register request on id map
          idMap[req.id] = { req, res, next, end };
      };
      return { events, middleware, stream };
      function readNoop() {
          return false;
      }
      function processMessage(res, _encoding, cb) {
          let err;
          try {
              const isNotification = !res.id;
              if (isNotification) {
                  processNotification(res);
              }
              else {
                  processResponse(res);
              }
          }
          catch (_err) {
              err = _err;
          }
          // continue processing stream
          cb(err);
      }
      function processResponse(res) {
          const context = idMap[res.id];
          if (!context) {
              throw new Error(`StreamMiddleware - Unknown response id "${res.id}"`);
          }
          delete idMap[res.id];
          // copy whole res onto original res
          Object.assign(context.res, res);
          // run callback on empty stack,
          // prevent internal stream-handler from catching errors
          setTimeout(context.end);
      }
      function processNotification(res) {
          events.emit('notification', res);
      }
  }
  createStreamMiddleware$1.default = createStreamMiddleware;

  var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(dist$3, "__esModule", { value: true });
  dist$3.createStreamMiddleware = dist$3.createEngineStream = void 0;
  const createEngineStream_1 = __importDefault$7(createEngineStream$1);
  dist$3.createEngineStream = createEngineStream_1.default;
  const createStreamMiddleware_1 = __importDefault$7(createStreamMiddleware$1);
  dist$3.createStreamMiddleware = createStreamMiddleware_1.default;

  var ObjectMultiplex$2 = {};

  var Substream$2 = {};

  Object.defineProperty(Substream$2, "__esModule", { value: true });
  Substream$2.Substream = void 0;
  const readable_stream_1$2 = readableBrowser$1.exports;
  class Substream$1 extends readable_stream_1$2.Duplex {
      constructor({ parent, name }) {
          super({ objectMode: true });
          this._parent = parent;
          this._name = name;
      }
      /**
       * Explicitly sets read operations to a no-op.
       */
      _read() {
          return undefined;
      }
      /**
       * Called when data should be written to this writable stream.
       *
       * @param chunk - Arbitrary object to write
       * @param encoding - Encoding to use when writing payload
       * @param callback - Called when writing is complete or an error occurs
       */
      _write(chunk, _encoding, callback) {
          this._parent.push({
              name: this._name,
              data: chunk,
          });
          callback();
      }
  }
  Substream$2.Substream = Substream$1;

  var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(ObjectMultiplex$2, "__esModule", { value: true });
  ObjectMultiplex$2.ObjectMultiplex = void 0;
  const readable_stream_1$1 = readableBrowser$1.exports;
  const end_of_stream_1 = __importDefault$6(endOfStream$1);
  const once_1 = __importDefault$6(once$4.exports);
  const Substream_1 = Substream$2;
  const IGNORE_SUBSTREAM$1 = Symbol('IGNORE_SUBSTREAM');
  class ObjectMultiplex$1 extends readable_stream_1$1.Duplex {
      constructor(opts = {}) {
          super(Object.assign(Object.assign({}, opts), { objectMode: true }));
          this._substreams = {};
      }
      createStream(name) {
          // guard stream against destroyed already
          if (this.destroyed) {
              throw new Error(`ObjectMultiplex - parent stream for name "${name}" already destroyed`);
          }
          // guard stream against ended already
          if (this._readableState.ended || this._writableState.ended) {
              throw new Error(`ObjectMultiplex - parent stream for name "${name}" already ended`);
          }
          // validate name
          if (!name) {
              throw new Error('ObjectMultiplex - name must not be empty');
          }
          if (this._substreams[name]) {
              throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
          }
          // create substream
          const substream = new Substream_1.Substream({ parent: this, name });
          this._substreams[name] = substream;
          // listen for parent stream to end
          anyStreamEnd$1(this, (_error) => {
              return substream.destroy(_error || undefined);
          });
          return substream;
      }
      // ignore streams (dont display orphaned data warning)
      ignoreStream(name) {
          // validate name
          if (!name) {
              throw new Error('ObjectMultiplex - name must not be empty');
          }
          if (this._substreams[name]) {
              throw new Error(`ObjectMultiplex - Substream for name "${name}" already exists`);
          }
          // set
          this._substreams[name] = IGNORE_SUBSTREAM$1;
      }
      _read() {
          return undefined;
      }
      _write(chunk, _encoding, callback) {
          const { name, data } = chunk;
          if (!name) {
              console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
              return callback();
          }
          // get corresponding substream
          const substream = this._substreams[name];
          if (!substream) {
              console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
              return callback();
          }
          // push data into substream
          if (substream !== IGNORE_SUBSTREAM$1) {
              substream.push(data);
          }
          return callback();
      }
  }
  ObjectMultiplex$2.ObjectMultiplex = ObjectMultiplex$1;
  // util
  function anyStreamEnd$1(stream, _cb) {
      const cb = once_1.default(_cb);
      end_of_stream_1.default(stream, { readable: false }, cb);
      end_of_stream_1.default(stream, { writable: false }, cb);
  }

  const ObjectMultiplex_1 = ObjectMultiplex$2;
  var dist$2 = ObjectMultiplex_1.ObjectMultiplex;

  var isArray$1 = Array.isArray;
  var keyList = Object.keys;
  var hasProp = Object.prototype.hasOwnProperty;

  var fastDeepEqual = function equal(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      var arrA = isArray$1(a)
        , arrB = isArray$1(b)
        , i
        , length
        , key;

      if (arrA && arrB) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;)
          if (!equal(a[i], b[i])) return false;
        return true;
      }

      if (arrA != arrB) return false;

      var dateA = a instanceof Date
        , dateB = b instanceof Date;
      if (dateA != dateB) return false;
      if (dateA && dateB) return a.getTime() == b.getTime();

      var regexpA = a instanceof RegExp
        , regexpB = b instanceof RegExp;
      if (regexpA != regexpB) return false;
      if (regexpA && regexpB) return a.toString() == b.toString();

      var keys = keyList(a);
      length = keys.length;

      if (length !== keyList(b).length)
        return false;

      for (i = length; i-- !== 0;)
        if (!hasProp.call(b, keys[i])) return false;

      for (i = length; i-- !== 0;) {
        key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }

      return true;
    }

    return a!==a && b!==b;
  };

  const isStream = stream =>
  	stream !== null &&
  	typeof stream === 'object' &&
  	typeof stream.pipe === 'function';

  isStream.writable = stream =>
  	isStream(stream) &&
  	stream.writable !== false &&
  	typeof stream._write === 'function' &&
  	typeof stream._writableState === 'object';

  isStream.readable = stream =>
  	isStream(stream) &&
  	stream.readable !== false &&
  	typeof stream._read === 'function' &&
  	typeof stream._readableState === 'object';

  isStream.duplex = stream =>
  	isStream.writable(stream) &&
  	isStream.readable(stream);

  isStream.transform = stream =>
  	isStream.duplex(stream) &&
  	typeof stream._transform === 'function';

  var isStream_1 = isStream;

  var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(BaseProvider$1, "__esModule", { value: true });
  const pump_1 = __importDefault$5(pump_1$1);
  const json_rpc_engine_1 = dist$4;
  const json_rpc_middleware_stream_1 = dist$3;
  const object_multiplex_1 = __importDefault$5(dist$2);
  const safe_event_emitter_1 = __importDefault$5(safeEventEmitter);
  const fast_deep_equal_1 = __importDefault$5(fastDeepEqual);
  const eth_rpc_errors_1$1 = dist$5;
  const is_stream_1 = isStream_1;
  const messages_1$1 = __importDefault$5(messages$1);
  const utils_1$1 = utils;
  class BaseProvider extends safe_event_emitter_1.default {
      /**
       * @param connectionStream - A Node.js duplex stream
       * @param options - An options bag
       * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
       * Default: metamask-provider
       * @param options.logger - The logging API to use. Default: console
       * @param options.maxEventListeners - The maximum number of event
       * listeners. Default: 100
       */
      constructor(connectionStream, { jsonRpcStreamName = 'metamask-provider', logger = console, maxEventListeners = 100, } = {}) {
          super();
          if (!is_stream_1.duplex(connectionStream)) {
              throw new Error(messages_1$1.default.errors.invalidDuplexStream());
          }
          this._log = logger;
          this.setMaxListeners(maxEventListeners);
          // private state
          this._state = Object.assign({}, BaseProvider._defaultState);
          // public state
          this.selectedAddress = null;
          this.chainId = null;
          // bind functions (to prevent consumers from making unbound calls)
          this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
          this._handleConnect = this._handleConnect.bind(this);
          this._handleChainChanged = this._handleChainChanged.bind(this);
          this._handleDisconnect = this._handleDisconnect.bind(this);
          this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
          this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
          this._rpcRequest = this._rpcRequest.bind(this);
          this.request = this.request.bind(this);
          // setup connectionStream multiplexing
          const mux = new object_multiplex_1.default();
          pump_1.default(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, 'MetaMask'));
          // setup own event listeners
          // EIP-1193 connect
          this.on('connect', () => {
              this._state.isConnected = true;
          });
          // setup RPC connection
          this._jsonRpcConnection = json_rpc_middleware_stream_1.createStreamMiddleware();
          pump_1.default(this._jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, 'MetaMask RpcProvider'));
          // handle RPC requests via dapp-side rpc engine
          const rpcEngine = new json_rpc_engine_1.JsonRpcEngine();
          rpcEngine.push(json_rpc_engine_1.createIdRemapMiddleware());
          rpcEngine.push(utils_1$1.createErrorMiddleware(this._log));
          rpcEngine.push(this._jsonRpcConnection.middleware);
          this._rpcEngine = rpcEngine;
          this._initializeState();
          // handle JSON-RPC notifications
          this._jsonRpcConnection.events.on('notification', (payload) => {
              const { method, params } = payload;
              if (method === 'metamask_accountsChanged') {
                  this._handleAccountsChanged(params);
              }
              else if (method === 'metamask_unlockStateChanged') {
                  this._handleUnlockStateChanged(params);
              }
              else if (method === 'metamask_chainChanged') {
                  this._handleChainChanged(params);
              }
              else if (utils_1$1.EMITTED_NOTIFICATIONS.includes(method)) {
                  this.emit('message', {
                      type: method,
                      data: params,
                  });
              }
              else if (method === 'METAMASK_STREAM_FAILURE') {
                  connectionStream.destroy(new Error(messages_1$1.default.errors.permanentlyDisconnected()));
              }
          });
      }
      //====================
      // Public Methods
      //====================
      /**
       * Returns whether the provider can process RPC requests.
       */
      isConnected() {
          return this._state.isConnected;
      }
      /**
       * Submits an RPC request for the given method, with the given params.
       * Resolves with the result of the method call, or rejects on error.
       *
       * @param args - The RPC request arguments.
       * @param args.method - The RPC method name.
       * @param args.params - The parameters for the RPC method.
       * @returns A Promise that resolves with the result of the RPC method,
       * or rejects if an error is encountered.
       */
      async request(args) {
          if (!args || typeof args !== 'object' || Array.isArray(args)) {
              throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
                  message: messages_1$1.default.errors.invalidRequestArgs(),
                  data: args,
              });
          }
          const { method, params } = args;
          if (typeof method !== 'string' || method.length === 0) {
              throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
                  message: messages_1$1.default.errors.invalidRequestMethod(),
                  data: args,
              });
          }
          if (params !== undefined &&
              !Array.isArray(params) &&
              (typeof params !== 'object' || params === null)) {
              throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
                  message: messages_1$1.default.errors.invalidRequestParams(),
                  data: args,
              });
          }
          return new Promise((resolve, reject) => {
              this._rpcRequest({ method, params }, utils_1$1.getRpcPromiseCallback(resolve, reject));
          });
      }
      //====================
      // Private Methods
      //====================
      /**
       * Constructor helper.
       * Populates initial state by calling 'metamask_getProviderState' and emits
       * necessary events.
       */
      async _initializeState() {
          try {
              const { accounts, chainId, isUnlocked, networkVersion, } = (await this.request({
                  method: 'metamask_getProviderState',
              }));
              // indicate that we've connected, for EIP-1193 compliance
              this.emit('connect', { chainId });
              this._handleChainChanged({ chainId, networkVersion });
              this._handleUnlockStateChanged({ accounts, isUnlocked });
              this._handleAccountsChanged(accounts);
          }
          catch (error) {
              this._log.error('MetaMask: Failed to get initial state. Please report this bug.', error);
          }
          finally {
              this._state.initialized = true;
              this.emit('_initialized');
          }
      }
      /**
       * Internal RPC method. Forwards requests to background via the RPC engine.
       * Also remap ids inbound and outbound.
       *
       * @param payload - The RPC request object.
       * @param callback - The consumer's callback.
       */
      _rpcRequest(payload, callback) {
          let cb = callback;
          if (!Array.isArray(payload)) {
              if (!payload.jsonrpc) {
                  payload.jsonrpc = '2.0';
              }
              if (payload.method === 'eth_accounts' ||
                  payload.method === 'eth_requestAccounts') {
                  // handle accounts changing
                  cb = (err, res) => {
                      this._handleAccountsChanged(res.result || [], payload.method === 'eth_accounts');
                      callback(err, res);
                  };
              }
              return this._rpcEngine.handle(payload, cb);
          }
          return this._rpcEngine.handle(payload, cb);
      }
      /**
       * When the provider becomes connected, updates internal state and emits
       * required events. Idempotent.
       *
       * @param chainId - The ID of the newly connected chain.
       * @emits MetaMaskInpageProvider#connect
       */
      _handleConnect(chainId) {
          if (!this._state.isConnected) {
              this._state.isConnected = true;
              this.emit('connect', { chainId });
              this._log.debug(messages_1$1.default.info.connected(chainId));
          }
      }
      /**
       * When the provider becomes disconnected, updates internal state and emits
       * required events. Idempotent with respect to the isRecoverable parameter.
       *
       * Error codes per the CloseEvent status codes as required by EIP-1193:
       * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
       *
       * @param isRecoverable - Whether the disconnection is recoverable.
       * @param errorMessage - A custom error message.
       * @emits MetaMaskInpageProvider#disconnect
       */
      _handleDisconnect(isRecoverable, errorMessage) {
          if (this._state.isConnected ||
              (!this._state.isPermanentlyDisconnected && !isRecoverable)) {
              this._state.isConnected = false;
              let error;
              if (isRecoverable) {
                  error = new eth_rpc_errors_1$1.EthereumRpcError(1013, // Try again later
                  errorMessage || messages_1$1.default.errors.disconnected());
                  this._log.debug(error);
              }
              else {
                  error = new eth_rpc_errors_1$1.EthereumRpcError(1011, // Internal error
                  errorMessage || messages_1$1.default.errors.permanentlyDisconnected());
                  this._log.error(error);
                  this.chainId = null;
                  this._state.accounts = null;
                  this.selectedAddress = null;
                  this._state.isUnlocked = false;
                  this._state.isPermanentlyDisconnected = true;
              }
              this.emit('disconnect', error);
          }
      }
      /**
       * Called when connection is lost to critical streams.
       *
       * @emits MetamaskInpageProvider#disconnect
       */
      _handleStreamDisconnect(streamName, error) {
          utils_1$1.logStreamDisconnectWarning(this._log, streamName, error, this);
          this._handleDisconnect(false, error ? error.message : undefined);
      }
      /**
       * Upon receipt of a new chainId and networkVersion, emits corresponding
       * events and sets relevant public state.
       * Does nothing if neither the chainId nor the networkVersion are different
       * from existing values.
       *
       * @emits MetamaskInpageProvider#chainChanged
       * @param networkInfo - An object with network info.
       * @param networkInfo.chainId - The latest chain ID.
       * @param networkInfo.networkVersion - The latest network ID.
       */
      _handleChainChanged({ chainId, networkVersion, } = {}) {
          if (!chainId ||
              typeof chainId !== 'string' ||
              !chainId.startsWith('0x') ||
              !networkVersion ||
              typeof networkVersion !== 'string') {
              this._log.error('MetaMask: Received invalid network parameters. Please report this bug.', { chainId, networkVersion });
              return;
          }
          if (networkVersion === 'loading') {
              this._handleDisconnect(true);
          }
          else {
              this._handleConnect(chainId);
              if (chainId !== this.chainId) {
                  this.chainId = chainId;
                  if (this._state.initialized) {
                      this.emit('chainChanged', this.chainId);
                  }
              }
          }
      }
      /**
       * Called when accounts may have changed. Diffs the new accounts value with
       * the current one, updates all state as necessary, and emits the
       * accountsChanged event.
       *
       * @param accounts - The new accounts value.
       * @param isEthAccounts - Whether the accounts value was returned by
       * a call to eth_accounts.
       */
      _handleAccountsChanged(accounts, isEthAccounts = false) {
          let _accounts = accounts;
          if (!Array.isArray(accounts)) {
              this._log.error('MetaMask: Received invalid accounts parameter. Please report this bug.', accounts);
              _accounts = [];
          }
          for (const account of accounts) {
              if (typeof account !== 'string') {
                  this._log.error('MetaMask: Received non-string account. Please report this bug.', accounts);
                  _accounts = [];
                  break;
              }
          }
          // emit accountsChanged if anything about the accounts array has changed
          if (!fast_deep_equal_1.default(this._state.accounts, _accounts)) {
              // we should always have the correct accounts even before eth_accounts
              // returns
              if (isEthAccounts && this._state.accounts !== null) {
                  this._log.error(`MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.`, _accounts);
              }
              this._state.accounts = _accounts;
              // handle selectedAddress
              if (this.selectedAddress !== _accounts[0]) {
                  this.selectedAddress = _accounts[0] || null;
              }
              // finally, after all state has been updated, emit the event
              if (this._state.initialized) {
                  this.emit('accountsChanged', _accounts);
              }
          }
      }
      /**
       * Upon receipt of a new isUnlocked state, sets relevant public state.
       * Calls the accounts changed handler with the received accounts, or an empty
       * array.
       *
       * Does nothing if the received value is equal to the existing value.
       * There are no lock/unlock events.
       *
       * @param opts - Options bag.
       * @param opts.accounts - The exposed accounts, if any.
       * @param opts.isUnlocked - The latest isUnlocked value.
       */
      _handleUnlockStateChanged({ accounts, isUnlocked, } = {}) {
          if (typeof isUnlocked !== 'boolean') {
              this._log.error('MetaMask: Received invalid isUnlocked parameter. Please report this bug.');
              return;
          }
          if (isUnlocked !== this._state.isUnlocked) {
              this._state.isUnlocked = isUnlocked;
              this._handleAccountsChanged(accounts || []);
          }
      }
  }
  BaseProvider$1.default = BaseProvider;
  BaseProvider._defaultState = {
      accounts: null,
      isConnected: false,
      isUnlocked: false,
      initialized: false,
      isPermanentlyDisconnected: false,
  };

  var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(MetaMaskInpageProvider$1, "__esModule", { value: true });
  const eth_rpc_errors_1 = dist$5;
  const siteMetadata_1 = __importDefault$4(siteMetadata);
  const messages_1 = __importDefault$4(messages$1);
  const utils_1 = utils;
  const BaseProvider_1$1 = __importDefault$4(BaseProvider$1);
  class MetaMaskInpageProvider extends BaseProvider_1$1.default {
      /**
       * @param connectionStream - A Node.js duplex stream
       * @param options - An options bag
       * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
       * Default: metamask-provider
       * @param options.logger - The logging API to use. Default: console
       * @param options.maxEventListeners - The maximum number of event
       * listeners. Default: 100
       * @param options.shouldSendMetadata - Whether the provider should
       * send page metadata. Default: true
       */
      constructor(connectionStream, { jsonRpcStreamName = 'metamask-provider', logger = console, maxEventListeners = 100, shouldSendMetadata = true, } = {}) {
          super(connectionStream, { jsonRpcStreamName, logger, maxEventListeners });
          this._sentWarnings = {
              // methods
              enable: false,
              experimentalMethods: false,
              send: false,
              // events
              events: {
                  close: false,
                  data: false,
                  networkChanged: false,
                  notification: false,
              },
          };
          this.networkVersion = null;
          this.isMetaMask = true;
          this._sendSync = this._sendSync.bind(this);
          this.enable = this.enable.bind(this);
          this.send = this.send.bind(this);
          this.sendAsync = this.sendAsync.bind(this);
          this._warnOfDeprecation = this._warnOfDeprecation.bind(this);
          this._metamask = this._getExperimentalApi();
          // handle JSON-RPC notifications
          this._jsonRpcConnection.events.on('notification', (payload) => {
              const { method } = payload;
              if (utils_1.EMITTED_NOTIFICATIONS.includes(method)) {
                  // deprecated
                  // emitted here because that was the original order
                  this.emit('data', payload);
                  // deprecated
                  this.emit('notification', payload.params.result);
              }
          });
          // send website metadata
          if (shouldSendMetadata) {
              if (document.readyState === 'complete') {
                  siteMetadata_1.default(this._rpcEngine, this._log);
              }
              else {
                  const domContentLoadedHandler = () => {
                      siteMetadata_1.default(this._rpcEngine, this._log);
                      window.removeEventListener('DOMContentLoaded', domContentLoadedHandler);
                  };
                  window.addEventListener('DOMContentLoaded', domContentLoadedHandler);
              }
          }
      }
      //====================
      // Public Methods
      //====================
      /**
       * Submits an RPC request per the given JSON-RPC request object.
       *
       * @param payload - The RPC request object.
       * @param cb - The callback function.
       */
      sendAsync(payload, callback) {
          this._rpcRequest(payload, callback);
      }
      /**
       * We override the following event methods so that we can warn consumers
       * about deprecated events:
       *   addListener, on, once, prependListener, prependOnceListener
       */
      addListener(eventName, listener) {
          this._warnOfDeprecation(eventName);
          return super.addListener(eventName, listener);
      }
      on(eventName, listener) {
          this._warnOfDeprecation(eventName);
          return super.on(eventName, listener);
      }
      once(eventName, listener) {
          this._warnOfDeprecation(eventName);
          return super.once(eventName, listener);
      }
      prependListener(eventName, listener) {
          this._warnOfDeprecation(eventName);
          return super.prependListener(eventName, listener);
      }
      prependOnceListener(eventName, listener) {
          this._warnOfDeprecation(eventName);
          return super.prependOnceListener(eventName, listener);
      }
      //====================
      // Private Methods
      //====================
      /**
       * When the provider becomes disconnected, updates internal state and emits
       * required events. Idempotent with respect to the isRecoverable parameter.
       *
       * Error codes per the CloseEvent status codes as required by EIP-1193:
       * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
       *
       * @param isRecoverable - Whether the disconnection is recoverable.
       * @param errorMessage - A custom error message.
       * @emits MetaMaskInpageProvider#disconnect
       */
      _handleDisconnect(isRecoverable, errorMessage) {
          super._handleDisconnect(isRecoverable, errorMessage);
          if (this.networkVersion && !isRecoverable) {
              this.networkVersion = null;
          }
      }
      /**
       * Warns of deprecation for the given event, if applicable.
       */
      _warnOfDeprecation(eventName) {
          var _a;
          if (((_a = this._sentWarnings) === null || _a === void 0 ? void 0 : _a.events[eventName]) === false) {
              this._log.warn(messages_1.default.warnings.events[eventName]);
              this._sentWarnings.events[eventName] = true;
          }
      }
      //====================
      // Deprecated Methods
      //====================
      /**
       * Equivalent to: ethereum.request('eth_requestAccounts')
       *
       * @deprecated Use request({ method: 'eth_requestAccounts' }) instead.
       * @returns A promise that resolves to an array of addresses.
       */
      enable() {
          if (!this._sentWarnings.enable) {
              this._log.warn(messages_1.default.warnings.enableDeprecation);
              this._sentWarnings.enable = true;
          }
          return new Promise((resolve, reject) => {
              try {
                  this._rpcRequest({ method: 'eth_requestAccounts', params: [] }, utils_1.getRpcPromiseCallback(resolve, reject));
              }
              catch (error) {
                  reject(error);
              }
          });
      }
      send(methodOrPayload, callbackOrArgs) {
          if (!this._sentWarnings.send) {
              this._log.warn(messages_1.default.warnings.sendDeprecation);
              this._sentWarnings.send = true;
          }
          if (typeof methodOrPayload === 'string' &&
              (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
              return new Promise((resolve, reject) => {
                  try {
                      this._rpcRequest({ method: methodOrPayload, params: callbackOrArgs }, utils_1.getRpcPromiseCallback(resolve, reject, false));
                  }
                  catch (error) {
                      reject(error);
                  }
              });
          }
          else if (methodOrPayload &&
              typeof methodOrPayload === 'object' &&
              typeof callbackOrArgs === 'function') {
              return this._rpcRequest(methodOrPayload, callbackOrArgs);
          }
          return this._sendSync(methodOrPayload);
      }
      /**
       * Internal backwards compatibility method, used in send.
       *
       * @deprecated
       */
      _sendSync(payload) {
          let result;
          switch (payload.method) {
              case 'eth_accounts':
                  result = this.selectedAddress ? [this.selectedAddress] : [];
                  break;
              case 'eth_coinbase':
                  result = this.selectedAddress || null;
                  break;
              case 'eth_uninstallFilter':
                  this._rpcRequest(payload, utils_1.NOOP);
                  result = true;
                  break;
              case 'net_version':
                  result = this.networkVersion || null;
                  break;
              default:
                  throw new Error(messages_1.default.errors.unsupportedSync(payload.method));
          }
          return {
              id: payload.id,
              jsonrpc: payload.jsonrpc,
              result,
          };
      }
      /**
       * Constructor helper.
       * Gets experimental _metamask API as Proxy, so that we can warn consumers
       * about its experiment nature.
       */
      _getExperimentalApi() {
          return new Proxy({
              /**
               * Determines if MetaMask is unlocked by the user.
               *
               * @returns Promise resolving to true if MetaMask is currently unlocked
               */
              isUnlocked: async () => {
                  if (!this._state.initialized) {
                      await new Promise((resolve) => {
                          this.on('_initialized', () => resolve());
                      });
                  }
                  return this._state.isUnlocked;
              },
              /**
               * Make a batch RPC request.
               */
              requestBatch: async (requests) => {
                  if (!Array.isArray(requests)) {
                      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                          message: 'Batch requests must be made with an array of request objects.',
                          data: requests,
                      });
                  }
                  return new Promise((resolve, reject) => {
                      this._rpcRequest(requests, utils_1.getRpcPromiseCallback(resolve, reject));
                  });
              },
          }, {
              get: (obj, prop, ...args) => {
                  if (!this._sentWarnings.experimentalMethods) {
                      this._log.warn(messages_1.default.warnings.experimentalMethods);
                      this._sentWarnings.experimentalMethods = true;
                  }
                  return Reflect.get(obj, prop, ...args);
              },
          });
      }
      /**
       * Upon receipt of a new chainId and networkVersion, emits corresponding
       * events and sets relevant public state.
       * Does nothing if neither the chainId nor the networkVersion are different
       * from existing values.
       *
       * @emits MetamaskInpageProvider#chainChanged
       * @emits MetamaskInpageProvider#networkChanged
       * @param networkInfo - An object with network info.
       * @param networkInfo.chainId - The latest chain ID.
       * @param networkInfo.networkVersion - The latest network ID.
       */
      _handleChainChanged({ chainId, networkVersion, } = {}) {
          super._handleChainChanged({ chainId, networkVersion });
          if (networkVersion &&
              networkVersion !== 'loading' &&
              networkVersion !== this.networkVersion) {
              this.networkVersion = networkVersion;
              if (this._state.initialized) {
                  this.emit('networkChanged', this.networkVersion);
              }
          }
      }
  }
  MetaMaskInpageProvider$1.default = MetaMaskInpageProvider;

  var createExternalExtensionProvider = {};

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined$1(global$1.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (browser$1$1.noDeprecation === true) {
      return fn;
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined$1(debugEnviron))
      debugEnviron = browser$1$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined$1(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined$1(ctx.depth)) ctx.depth = 2;
    if (isUndefined$1(ctx.colors)) ctx.colors = false;
    if (isUndefined$1(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined$1(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined$1(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isString(arg) {
    return typeof arg === 'string';
  }

  function isUndefined$1(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  function BufferList$1() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList$1.prototype.push = function (v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList$1.prototype.unshift = function (v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList$1.prototype.shift = function () {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList$1.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList$1.prototype.join = function (s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList$1.prototype.concat = function (n) {
    if (this.length === 0) return buffer.Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = buffer.Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  var string_decoderExports = requireString_decoder$1();

  Readable.ReadableState = ReadableState;

  var debug = debuglog('stream');
  inherits$1(Readable, EventEmitter);

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') {
      return emitter.prependListener(event, fn);
    } else {
      // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount (emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options, stream) {

    options = options || {};

    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex$2) this.objectMode = this.objectMode || !!options.readableObjectMode;

    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList$1();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // when piping, we only care about 'readable' events that happen
    // after read()ing all the bytes and not getting any pushback.
    this.ranOut = false;

    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;

    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;

    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new string_decoderExports.StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {

    if (!(this instanceof Readable)) return new Readable(options);

    this._readableState = new ReadableState(options, this);

    // legacy
    this.readable = true;

    if (options && typeof options.read === 'function') this._read = options.read;

    EventEmitter.call(this);
  }

  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;

    if (!state.objectMode && typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
    }

    return readableAddChunk(this, state, chunk, encoding, false);
  };

  // Unshift should *always* be something directly out of read()
  Readable.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, '', true);
  };

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error('stream.push() after EOF');
        stream.emit('error', e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error('stream.unshift() after end event');
        stream.emit('error', _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }

        if (!addToFront) state.reading = false;

        // Don't add to the buffer if we've decoded to an empty string chunk and
        // we're not in object mode
        if (!skipAdd) {
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

            if (state.needReadable) emitReadable(stream);
          }
        }

        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }

    return needMoreData(state);
  }

  // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }

  // backwards compatibility.
  Readable.prototype.setEncoding = function (enc) {
    this._readableState.decoder = new string_decoderExports.StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };

  // Don't raise the hwm > 8MB
  var MAX_HWM = 0x800000;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }

  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }

  // you can override either this method, or the async _read(n) below.
  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;

    if (n !== 0) state.emittedReadable = false;

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state);

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead);

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    }

    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);

    return ret;
  };

  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
  }

  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;

    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
  }

  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick$1(emitReadable_, stream);else emitReadable_(stream);
    }
  }

  function emitReadable_(stream) {
    debug('emit readable');
    stream.emit('readable');
    flow(stream);
  }

  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick$1(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;else len = state.length;
    }
    state.readingMore = false;
  }

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable.prototype._read = function (n) {
    this.emit('error', new Error('not implemented'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

    var doEnd = (!pipeOpts || pipeOpts.end !== false);

    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) nextTick$1(endFn);else src.once('end', endFn);

    dest.on('unpipe', onunpipe);
    function onunpipe(readable) {
      debug('onunpipe');
      if (readable === src) {
        cleanup();
      }
    }

    function onend() {
      debug('onend');
      dest.end();
    }

    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);

    var cleanedUp = false;
    function cleanup() {
      debug('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', cleanup);
      src.removeListener('data', ondata);

      cleanedUp = true;

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
      debug('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }

    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);

    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    }

    // tell the dest that it's being piped to
    dest.emit('pipe', src);

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function () {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners('data').length) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;

      if (!dest) dest = state.pipes;

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this);
      return this;
    }

    // slow case. multiple pipe destinations.

    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit('unpipe', this);
      }return this;
    }

    // try to find the right one.
    var i = indexOf(state.pipes, dest);
    if (i === -1) return this;

    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];

    dest.emit('unpipe', this);

    return this;
  };

  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable.prototype.on = function (ev, fn) {
    var res = EventEmitter.prototype.on.call(this, ev, fn);

    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          nextTick$1(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }

    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;

  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  }

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug('resume');
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };

  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick$1(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    if (!state.reading) {
      debug('resume read 0');
      stream.read(0);
    }

    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;

    var self = this;
    stream.on('end', function () {
      debug('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self.push(chunk);
      }

      self.push(null);
    });

    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = self.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }

    // proxy certain important events.
    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
    forEach(events, function (ev) {
      stream.on(ev, self.emit.bind(self, ev));
    });

    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    self._read = function (n) {
      debug('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return self;
  };

  // exposed for testing purposes only.
  Readable._fromList = fromList;

  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;

    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }

    return ret;
  }

  // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }

  // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;

    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

    if (!state.endEmitted) {
      state.ended = true;
      nextTick$1(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }

  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }

  // A bit simpler than readable streams.
  Writable.WritableState = WritableState;
  inherits$1(Writable, EventEmitter);

  function nop() {}

  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }

  function WritableState(options, stream) {
    Object.defineProperty(this, 'buffer', {
      get: deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
    options = options || {};

    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex$2) this.objectMode = this.objectMode || !!options.writableObjectMode;

    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;

    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // a flag to see when we're in the middle of a write.
    this.writing = false;

    // when true all writes will be buffered until .uncork() call
    this.corked = 0;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite(stream, er);
    };

    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;

    // the amount that is being written when _write is called.
    this.writelen = 0;

    this.bufferedRequest = null;
    this.lastBufferedRequest = null;

    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;

    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;

    // count buffered requests
    this.bufferedRequestCount = 0;

    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable(options) {

    // Writable ctor is applied to Duplexes, though they're not
    // instanceof Writable, they're instanceof Readable.
    if (!(this instanceof Writable) && !(this instanceof Duplex$2)) return new Writable(options);

    this._writableState = new WritableState(options, this);

    // legacy.
    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;

      if (typeof options.writev === 'function') this._writev = options.writev;
    }

    EventEmitter.call(this);
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };

  function writeAfterEnd(stream, cb) {
    var er = new Error('write after end');
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit('error', er);
    nextTick$1(cb, er);
  }

  // If we get something that is not a buffer, string, null, or undefined,
  // and we're not in objectMode, then that's an error.
  // Otherwise stream chunks are all considered to be of length=1, and the
  // watermarks determine how many objects to keep in the buffer, rather than
  // how many bytes or characters.
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    // Always throw error if a null is written
    // if we are not in object mode then throw
    // if it is not a buffer, string, or undefined.
    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (!buffer.Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
      stream.emit('error', er);
      nextTick$1(cb, er);
      valid = false;
    }
    return valid;
  }

  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (buffer.Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

    if (typeof cb !== 'function') cb = nop;

    if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }

    return ret;
  };

  Writable.prototype.cork = function () {
    var state = this._writableState;

    state.corked++;
  };

  Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;

      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = buffer.Buffer.from(chunk, encoding);
    }
    return chunk;
  }

  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);

    if (buffer.Buffer.isBuffer(chunk)) encoding = 'buffer';
    var len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick$1(cb, er);else cb(er);

    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;

    onwriteStateUpdate(state);

    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state);

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        /*<replacement>*/
          nextTick$1(afterWrite, stream, state, finished, cb);
        /*</replacement>*/
      } else {
          afterWrite(stream, state, finished, cb);
        }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }

  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }

  // if there's something in the buffer waiting, then process it
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;

      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }

      doWrite(stream, state, true, state.length, buffer, '', holder.finish);

      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;

        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('not implemented'));
  };

  Writable.prototype._writev = null;

  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }

    // ignore unnecessary end() calls.
    if (!state.ending && !state.finished) endWritable(this, state, cb);
  };

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit('finish');
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) nextTick$1(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }

  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function (err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }

  inherits$1(Duplex$2, Readable);

  var keys = Object.keys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex$2.prototype[method]) Duplex$2.prototype[method] = Writable.prototype[method];
  }
  function Duplex$2(options) {
    if (!(this instanceof Duplex$2)) return new Duplex$2(options);

    Readable.call(this, options);
    Writable.call(this, options);

    if (options && options.readable === false) this.readable = false;

    if (options && options.writable === false) this.writable = false;

    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

    this.once('end', onend);
  }

  // the no-half-open enforcer
  function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;

    // no more data can be written.
    // But allow more writes to happen in this tick.
    nextTick$1(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  // a transform stream is a readable/writable stream where you do
  inherits$1(Transform$2, Duplex$2);

  function TransformState$1(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform$1(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform$1(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;

    var cb = ts.writecb;

    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

    ts.writechunk = null;
    ts.writecb = null;

    if (data !== null && data !== undefined) stream.push(data);

    cb(er);

    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform$2(options) {
    if (!(this instanceof Transform$2)) return new Transform$2(options);

    Duplex$2.call(this, options);

    this._transformState = new TransformState$1(this);

    // when the writable side finishes, then flush out anything remaining.
    var stream = this;

    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;

    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;

      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er) {
        done$1(stream, er);
      });else done$1(stream);
    });
  }

  Transform$2.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex$2.prototype.push.call(this, chunk, encoding);
  };

  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform$2.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('Not implemented');
  };

  Transform$2.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };

  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform$2.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  function done$1(stream, er) {
    if (er) return stream.emit('error', er);

    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    var ws = stream._writableState;
    var ts = stream._transformState;

    if (ws.length) throw new Error('Calling transform done when ws.length != 0');

    if (ts.transforming) throw new Error('Calling transform done when still transforming');

    return stream.push(null);
  }

  inherits$1(PassThrough$1, Transform$2);
  function PassThrough$1(options) {
    if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);

    Transform$2.call(this, options);
  }

  PassThrough$1.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  inherits$1(Stream, EventEmitter);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex$2;
  Stream.Transform = Transform$2;
  Stream.PassThrough = PassThrough$1;

  // Backwards-compat with node 0.4.x
  Stream.Stream = Stream;

  // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.

  function Stream() {
    EventEmitter.call(this);
  }

  Stream.prototype.pipe = function(dest, options) {
    var source = this;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on('data', ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on('drain', ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }

    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;

      dest.end();
    }


    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;

      if (typeof dest.destroy === 'function') dest.destroy();
    }

    // don't leave dangling pipes when there are errors.
    function onerror(er) {
      cleanup();
      if (EventEmitter.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror);
    dest.on('error', onerror);

    // remove all the event listeners that were added.
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);

      source.removeListener('end', onend);
      source.removeListener('close', onclose);

      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);

      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);

      dest.removeListener('close', cleanup);
    }

    source.on('end', cleanup);
    source.on('close', cleanup);

    dest.on('close', cleanup);

    dest.emit('pipe', source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
  };

  var _polyfillNode_stream = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Stream,
    Readable: Readable,
    Writable: Writable,
    Duplex: Duplex$2,
    Transform: Transform$2,
    PassThrough: PassThrough$1,
    Stream: Stream
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);

  const stream_1 = require$$0;
  var dist$1 = class PortDuplexStream extends stream_1.Duplex {
      /**
       * @param port - An instance of WebExtensions Runtime.Port. See:
       * {@link https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/Port}
       */
      constructor(port) {
          super({ objectMode: true });
          this._port = port;
          this._port.onMessage.addListener((msg) => this._onMessage(msg));
          this._port.onDisconnect.addListener(() => this._onDisconnect());
      }
      /**
       * Callback triggered when a message is received from
       * the remote Port associated with this Stream.
       *
       * @param msg - Payload from the onMessage listener of the port
       */
      _onMessage(msg) {
          if (Buffer.isBuffer(msg)) {
              const data = Buffer.from(msg);
              this.push(data);
          }
          else {
              this.push(msg);
          }
      }
      /**
       * Callback triggered when the remote Port associated with this Stream
       * disconnects.
       */
      _onDisconnect() {
          this.destroy();
      }
      /**
       * Explicitly sets read operations to a no-op.
       */
      _read() {
          return undefined;
      }
      /**
       * Called internally when data should be written to this writable stream.
       *
       * @param msg - Arbitrary object to write
       * @param encoding - Encoding to use when writing payload
       * @param cb - Called when writing is complete or an error occurs
       */
      _write(msg, _encoding, cb) {
          try {
              if (Buffer.isBuffer(msg)) {
                  const data = msg.toJSON();
                  data._isBuffer = true;
                  this._port.postMessage(data);
              }
              else {
                  this._port.postMessage(msg);
              }
          }
          catch (error) {
              return cb(new Error('PortDuplexStream - disconnected'));
          }
          return cb();
      }
  };

  var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  };
  var BrowserInfo$1 = /** @class */ (function () {
      function BrowserInfo(name, version, os) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.type = 'browser';
      }
      return BrowserInfo;
  }());
  var NodeInfo$1 = /** @class */ (function () {
      function NodeInfo(version) {
          this.version = version;
          this.type = 'node';
          this.name = 'node';
          this.os = browser$1$1.platform;
      }
      return NodeInfo;
  }());
  var SearchBotDeviceInfo$1 = /** @class */ (function () {
      function SearchBotDeviceInfo(name, version, os, bot) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.bot = bot;
          this.type = 'bot-device';
      }
      return SearchBotDeviceInfo;
  }());
  var BotInfo$1 = /** @class */ (function () {
      function BotInfo() {
          this.type = 'bot';
          this.bot = true; // NOTE: deprecated test name instead
          this.name = 'bot';
          this.version = null;
          this.os = null;
      }
      return BotInfo;
  }());
  var ReactNativeInfo$1 = /** @class */ (function () {
      function ReactNativeInfo() {
          this.type = 'react-native';
          this.name = 'react-native';
          this.version = null;
          this.os = null;
      }
      return ReactNativeInfo;
  }());
  // tslint:disable-next-line:max-line-length
  var SEARCHBOX_UA_REGEX$1 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX$1 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS$1 = 3;
  var userAgentRules$1 = [
      ['aol', /AOLShield\/([0-9\._]+)/],
      ['edge', /Edge\/([0-9\._]+)/],
      ['edge-ios', /EdgiOS\/([0-9\._]+)/],
      ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
      ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
      ['samsung', /SamsungBrowser\/([0-9\.]+)/],
      ['silk', /\bSilk\/([0-9._-]+)\b/],
      ['miui', /MiuiBrowser\/([0-9\.]+)$/],
      ['beaker', /BeakerBrowser\/([0-9\.]+)/],
      ['edge-chromium', /EdgA?\/([0-9\.]+)/],
      [
          'chromium-webview',
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
      ],
      ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
      ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
      ['fxios', /FxiOS\/([0-9\.]+)/],
      ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
      ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
      ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
      ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
      ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
      ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
      ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ['ie', /MSIE\s(7\.0)/],
      ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ['android', /Android\s([0-9\.]+)/],
      ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ['safari', /Version\/([0-9\._]+).*Safari/],
      ['facebook', /FB[AS]V\/([0-9\.]+)/],
      ['instagram', /Instagram\s([0-9\.]+)/],
      ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
      ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ['curl', /^curl\/([0-9\.]+)$/],
      ['searchbot', SEARCHBOX_UA_REGEX$1],
  ];
  var operatingSystemRules$1 = [
      ['iOS', /iP(hone|od|ad)/],
      ['Android OS', /Android/],
      ['BlackBerry OS', /BlackBerry|BB10/],
      ['Windows Mobile', /IEMobile/],
      ['Amazon OS', /Kindle/],
      ['Windows 3.11', /Win16/],
      ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
      ['Windows 98', /(Windows 98)|(Win98)/],
      ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
      ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
      ['Windows Server 2003', /(Windows NT 5.2)/],
      ['Windows Vista', /(Windows NT 6.0)/],
      ['Windows 7', /(Windows NT 6.1)/],
      ['Windows 8', /(Windows NT 6.2)/],
      ['Windows 8.1', /(Windows NT 6.3)/],
      ['Windows 10', /(Windows NT 10.0)/],
      ['Windows ME', /Windows ME/],
      ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
      ['Open BSD', /OpenBSD/],
      ['Sun OS', /SunOS/],
      ['Chrome OS', /CrOS/],
      ['Linux', /(Linux)|(X11)/],
      ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
      ['QNX', /QNX/],
      ['BeOS', /BeOS/],
      ['OS/2', /OS\/2/],
  ];
  function detect$1(userAgent) {
      if (!!userAgent) {
          return parseUserAgent$1(userAgent);
      }
      if (typeof document === 'undefined' &&
          typeof navigator !== 'undefined' &&
          navigator.product === 'ReactNative') {
          return new ReactNativeInfo$1();
      }
      if (typeof navigator !== 'undefined') {
          return parseUserAgent$1(navigator.userAgent);
      }
      return getNodeVersion$1();
  }
  function matchUserAgent$1(ua) {
      // opted for using reduce here rather than Array#first with a regex.test call
      // this is primarily because using the reduce we only perform the regex
      // execution once rather than once for the test and for the exec again below
      // probably something that needs to be benchmarked though
      return (ua !== '' &&
          userAgentRules$1.reduce(function (matched, _a) {
              var browser = _a[0], regex = _a[1];
              if (matched) {
                  return matched;
              }
              var uaMatch = regex.exec(ua);
              return !!uaMatch && [browser, uaMatch];
          }, false));
  }
  function browserName(ua) {
      var data = matchUserAgent$1(ua);
      return data ? data[0] : null;
  }
  function parseUserAgent$1(ua) {
      var matchedRule = matchUserAgent$1(ua);
      if (!matchedRule) {
          return null;
      }
      var name = matchedRule[0], match = matchedRule[1];
      if (name === 'searchbot') {
          return new BotInfo$1();
      }
      // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
      var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
      if (versionParts) {
          if (versionParts.length < REQUIRED_VERSION_PARTS$1) {
              versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts$1(REQUIRED_VERSION_PARTS$1 - versionParts.length), true);
          }
      }
      else {
          versionParts = [];
      }
      var version = versionParts.join('.');
      var os = detectOS$2(ua);
      var searchBotMatch = SEARCHBOT_OS_REGEX$1.exec(ua);
      if (searchBotMatch && searchBotMatch[1]) {
          return new SearchBotDeviceInfo$1(name, version, os, searchBotMatch[1]);
      }
      return new BrowserInfo$1(name, version, os);
  }
  function detectOS$2(ua) {
      for (var ii = 0, count = operatingSystemRules$1.length; ii < count; ii++) {
          var _a = operatingSystemRules$1[ii], os = _a[0], regex = _a[1];
          var match = regex.exec(ua);
          if (match) {
              return os;
          }
      }
      return null;
  }
  function getNodeVersion$1() {
      var isNode = typeof browser$1$1 !== 'undefined' && browser$1$1.version;
      return isNode ? new NodeInfo$1(browser$1$1.version.slice(1)) : null;
  }
  function createVersionParts$1(count) {
      var output = [];
      for (var ii = 0; ii < count; ii++) {
          output.push('0');
      }
      return output;
  }

  var es = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BrowserInfo: BrowserInfo$1,
    NodeInfo: NodeInfo$1,
    SearchBotDeviceInfo: SearchBotDeviceInfo$1,
    BotInfo: BotInfo$1,
    ReactNativeInfo: ReactNativeInfo$1,
    detect: detect$1,
    browserName: browserName,
    parseUserAgent: parseUserAgent$1,
    detectOS: detectOS$2,
    getNodeVersion: getNodeVersion$1
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(es);

  var CHROME_ID = "nkbihfbeogaeaoehlefnkodbefgpgknn";
  var FIREFOX_ID = "webextension@metamask.io";
  var require$$3 = {
  	CHROME_ID: CHROME_ID,
  	FIREFOX_ID: FIREFOX_ID
  };

  var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(createExternalExtensionProvider, "__esModule", { value: true });
  const extension_port_stream_1 = __importDefault$3(dist$1);
  const detect_browser_1 = require$$1;
  const BaseProvider_1 = __importDefault$3(BaseProvider$1);
  const external_extension_config_json_1 = __importDefault$3(require$$3);
  const browser$1 = detect_browser_1.detect();
  function createMetaMaskExternalExtensionProvider() {
      let provider;
      try {
          const currentMetaMaskId = getMetaMaskId();
          const metamaskPort = chrome.runtime.connect(currentMetaMaskId);
          const pluginStream = new extension_port_stream_1.default(metamaskPort);
          provider = new BaseProvider_1.default(pluginStream);
      }
      catch (e) {
          console.dir(`Metamask connect error `, e);
          throw e;
      }
      return provider;
  }
  createExternalExtensionProvider.default = createMetaMaskExternalExtensionProvider;
  function getMetaMaskId() {
      switch (browser$1 === null || browser$1 === void 0 ? void 0 : browser$1.name) {
          case 'chrome':
              return external_extension_config_json_1.default.CHROME_ID;
          case 'firefox':
              return external_extension_config_json_1.default.FIREFOX_ID;
          default:
              return external_extension_config_json_1.default.CHROME_ID;
      }
  }

  var initializeInpageProvider = {};

  var shimWeb3$1 = {};

  Object.defineProperty(shimWeb3$1, "__esModule", { value: true });
  /**
   * If no existing window.web3 is found, this function injects a web3 "shim" to
   * not break dapps that rely on window.web3.currentProvider.
   *
   * @param provider - The provider to set as window.web3.currentProvider.
   * @param log - The logging API to use.
   */
  function shimWeb3(provider, log = console) {
      let loggedCurrentProvider = false;
      let loggedMissingProperty = false;
      if (!window.web3) {
          const SHIM_IDENTIFIER = '__isMetaMaskShim__';
          let web3Shim = { currentProvider: provider };
          Object.defineProperty(web3Shim, SHIM_IDENTIFIER, {
              value: true,
              enumerable: true,
              configurable: false,
              writable: false,
          });
          web3Shim = new Proxy(web3Shim, {
              get: (target, property, ...args) => {
                  if (property === 'currentProvider' && !loggedCurrentProvider) {
                      loggedCurrentProvider = true;
                      log.warn('You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3');
                  }
                  else if (property !== 'currentProvider' &&
                      property !== SHIM_IDENTIFIER &&
                      !loggedMissingProperty) {
                      loggedMissingProperty = true;
                      log.error(`MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3`);
                      provider
                          .request({ method: 'metamask_logWeb3ShimUsage' })
                          .catch((error) => {
                          log.debug('MetaMask: Failed to log web3 shim usage.', error);
                      });
                  }
                  return Reflect.get(target, property, ...args);
              },
              set: (...args) => {
                  log.warn('You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3');
                  return Reflect.set(...args);
              },
          });
          Object.defineProperty(window, 'web3', {
              value: web3Shim,
              enumerable: false,
              configurable: true,
              writable: true,
          });
      }
  }
  shimWeb3$1.default = shimWeb3;

  var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(initializeInpageProvider, "__esModule", { value: true });
  initializeInpageProvider.setGlobalProvider = initializeInpageProvider.initializeProvider = void 0;
  const MetaMaskInpageProvider_1 = __importDefault$2(MetaMaskInpageProvider$1);
  const shimWeb3_1 = __importDefault$2(shimWeb3$1);
  /**
   * Initializes a MetaMaskInpageProvider and (optionally) assigns it as window.ethereum.
   *
   * @param options - An options bag.
   * @param options.connectionStream - A Node.js stream.
   * @param options.jsonRpcStreamName - The name of the internal JSON-RPC stream.
   * @param options.maxEventListeners - The maximum number of event listeners.
   * @param options.shouldSendMetadata - Whether the provider should send page metadata.
   * @param options.shouldSetOnWindow - Whether the provider should be set as window.ethereum.
   * @param options.shouldShimWeb3 - Whether a window.web3 shim should be injected.
   * @returns The initialized provider (whether set or not).
   */
  function initializeProvider$1({ connectionStream, jsonRpcStreamName, logger = console, maxEventListeners = 100, shouldSendMetadata = true, shouldSetOnWindow = true, shouldShimWeb3 = false, }) {
      let provider = new MetaMaskInpageProvider_1.default(connectionStream, {
          jsonRpcStreamName,
          logger,
          maxEventListeners,
          shouldSendMetadata,
      });
      provider = new Proxy(provider, {
          // some common libraries, e.g. web3@1.x, mess with our API
          deleteProperty: () => true,
      });
      if (shouldSetOnWindow) {
          setGlobalProvider(provider);
      }
      if (shouldShimWeb3) {
          shimWeb3_1.default(provider, logger);
      }
      return provider;
  }
  initializeInpageProvider.initializeProvider = initializeProvider$1;
  /**
   * Sets the given provider instance as window.ethereum and dispatches the
   * 'ethereum#initialized' event on window.
   *
   * @param providerInstance - The provider instance.
   */
  function setGlobalProvider(providerInstance) {
      window.ethereum = providerInstance;
      window.dispatchEvent(new Event('ethereum#initialized'));
  }
  initializeInpageProvider.setGlobalProvider = setGlobalProvider;

  (function (exports) {
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.createExternalExtensionProvider = exports.shimWeb3 = exports.setGlobalProvider = exports.BaseProvider = exports.MetaMaskInpageProvider = exports.initializeProvider = void 0;
  	const MetaMaskInpageProvider_1 = __importDefault(MetaMaskInpageProvider$1);
  	exports.MetaMaskInpageProvider = MetaMaskInpageProvider_1.default;
  	const createExternalExtensionProvider_1 = __importDefault(createExternalExtensionProvider);
  	exports.createExternalExtensionProvider = createExternalExtensionProvider_1.default;
  	const BaseProvider_1 = __importDefault(BaseProvider$1);
  	exports.BaseProvider = BaseProvider_1.default;
  	const initializeInpageProvider_1 = initializeInpageProvider;
  	Object.defineProperty(exports, "initializeProvider", { enumerable: true, get: function () { return initializeInpageProvider_1.initializeProvider; } });
  	Object.defineProperty(exports, "setGlobalProvider", { enumerable: true, get: function () { return initializeInpageProvider_1.setGlobalProvider; } });
  	const shimWeb3_1 = __importDefault(shimWeb3$1);
  	exports.shimWeb3 = shimWeb3_1.default;
  	
  } (dist$6));

  var dist = {};

  var WindowPostMessageStream$1 = {};

  var BasePostMessageStream$1 = {};

  var readableBrowser = {exports: {}};

  var processNextickArgs = {exports: {}};

  if (!browser$1$1.version ||
      browser$1$1.version.indexOf('v0.') === 0 ||
      browser$1$1.version.indexOf('v1.') === 0 && browser$1$1.version.indexOf('v1.8.') !== 0) {
    processNextickArgs.exports = nextTick;
  } else {
    processNextickArgs.exports = browser$1$1.nextTick;
  }

  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== 'function') {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
    case 0:
    case 1:
      return browser$1$1.nextTick(fn);
    case 2:
      return browser$1$1.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return browser$1$1.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return browser$1$1.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return browser$1$1.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
  }

  var streamBrowser = require$$2.EventEmitter;

  var BufferList;
  var hasRequiredBufferList;

  function requireBufferList () {
  	if (hasRequiredBufferList) return BufferList;
  	hasRequiredBufferList = 1;

  	/*<replacement>*/

  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  	var Buffer = requireSafeBuffer().Buffer;
  	/*</replacement>*/

  	function copyBuffer(src, target, offset) {
  	  src.copy(target, offset);
  	}

  	BufferList = function () {
  	  function BufferList() {
  	    _classCallCheck(this, BufferList);

  	    this.head = null;
  	    this.tail = null;
  	    this.length = 0;
  	  }

  	  BufferList.prototype.push = function push(v) {
  	    var entry = { data: v, next: null };
  	    if (this.length > 0) this.tail.next = entry;else this.head = entry;
  	    this.tail = entry;
  	    ++this.length;
  	  };

  	  BufferList.prototype.unshift = function unshift(v) {
  	    var entry = { data: v, next: this.head };
  	    if (this.length === 0) this.tail = entry;
  	    this.head = entry;
  	    ++this.length;
  	  };

  	  BufferList.prototype.shift = function shift() {
  	    if (this.length === 0) return;
  	    var ret = this.head.data;
  	    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  	    --this.length;
  	    return ret;
  	  };

  	  BufferList.prototype.clear = function clear() {
  	    this.head = this.tail = null;
  	    this.length = 0;
  	  };

  	  BufferList.prototype.join = function join(s) {
  	    if (this.length === 0) return '';
  	    var p = this.head;
  	    var ret = '' + p.data;
  	    while (p = p.next) {
  	      ret += s + p.data;
  	    }return ret;
  	  };

  	  BufferList.prototype.concat = function concat(n) {
  	    if (this.length === 0) return Buffer.alloc(0);
  	    if (this.length === 1) return this.head.data;
  	    var ret = Buffer.allocUnsafe(n >>> 0);
  	    var p = this.head;
  	    var i = 0;
  	    while (p) {
  	      copyBuffer(p.data, ret, i);
  	      i += p.data.length;
  	      p = p.next;
  	    }
  	    return ret;
  	  };

  	  return BufferList;
  	}();
  	return BufferList;
  }

  /*<replacement>*/

  var processNextTick = processNextickArgs.exports;
  /*</replacement>*/

  // undocumented cb() API, needed for core, not for public API
  function destroy(err, cb) {
    var _this = this;

    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;

    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
        processNextTick(emitErrorNT, this, err);
      }
      return;
    }

    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks

    if (this._readableState) {
      this._readableState.destroyed = true;
    }

    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
      this._writableState.destroyed = true;
    }

    this._destroy(err || null, function (err) {
      if (!cb && err) {
        processNextTick(emitErrorNT, _this, err);
        if (_this._writableState) {
          _this._writableState.errorEmitted = true;
        }
      } else if (cb) {
        cb(err);
      }
    });
  }

  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }

    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }

  function emitErrorNT(self, err) {
    self.emit('error', err);
  }

  var destroy_1 = {
    destroy: destroy,
    undestroy: undestroy
  };

  var _stream_writable;
  var hasRequired_stream_writable;

  function require_stream_writable () {
  	if (hasRequired_stream_writable) return _stream_writable;
  	hasRequired_stream_writable = 1;

  	/*<replacement>*/

  	var processNextTick = processNextickArgs.exports;
  	/*</replacement>*/

  	_stream_writable = Writable;

  	// It seems a linked list but it is not
  	// there will be only 2 of these for each stream
  	function CorkedRequest(state) {
  	  var _this = this;

  	  this.next = null;
  	  this.entry = null;
  	  this.finish = function () {
  	    onCorkedFinish(_this, state);
  	  };
  	}
  	/* </replacement> */

  	/*<replacement>*/
  	var asyncWrite = !browser$1$1.browser && ['v0.10', 'v0.9.'].indexOf(browser$1$1.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
  	/*</replacement>*/

  	/*<replacement>*/
  	var Duplex;
  	/*</replacement>*/

  	Writable.WritableState = WritableState;

  	/*<replacement>*/
  	var util = requireUtil();
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	/*<replacement>*/
  	var internalUtil = {
  	  deprecate: requireBrowser()
  	};
  	/*</replacement>*/

  	/*<replacement>*/
  	var Stream = streamBrowser;
  	/*</replacement>*/

  	/*<replacement>*/
  	var Buffer = requireSafeBuffer().Buffer;
  	var OurUint8Array = commonjsGlobal.Uint8Array || function () {};
  	function _uint8ArrayToBuffer(chunk) {
  	  return Buffer.from(chunk);
  	}
  	function _isUint8Array(obj) {
  	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  	}
  	/*</replacement>*/

  	var destroyImpl = destroy_1;

  	util.inherits(Writable, Stream);

  	function nop() {}

  	function WritableState(options, stream) {
  	  Duplex = Duplex || require_stream_duplex();

  	  options = options || {};

  	  // object stream flag to indicate whether or not this stream
  	  // contains buffers or objects.
  	  this.objectMode = !!options.objectMode;

  	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  	  // the point at which write() starts returning false
  	  // Note: 0 is a valid value, means that we always return false if
  	  // the entire buffer is not flushed immediately on write()
  	  var hwm = options.highWaterMark;
  	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  	  // cast to ints.
  	  this.highWaterMark = Math.floor(this.highWaterMark);

  	  // if _final has been called
  	  this.finalCalled = false;

  	  // drain event flag.
  	  this.needDrain = false;
  	  // at the start of calling end()
  	  this.ending = false;
  	  // when end() has been called, and returned
  	  this.ended = false;
  	  // when 'finish' is emitted
  	  this.finished = false;

  	  // has it been destroyed
  	  this.destroyed = false;

  	  // should we decode strings into buffers before passing to _write?
  	  // this is here so that some node-core streams can optimize string
  	  // handling at a lower level.
  	  var noDecode = options.decodeStrings === false;
  	  this.decodeStrings = !noDecode;

  	  // Crypto is kind of old and crusty.  Historically, its default string
  	  // encoding is 'binary' so we have to make this configurable.
  	  // Everything else in the universe uses 'utf8', though.
  	  this.defaultEncoding = options.defaultEncoding || 'utf8';

  	  // not an actual buffer we keep track of, but a measurement
  	  // of how much we're waiting to get pushed to some underlying
  	  // socket or file.
  	  this.length = 0;

  	  // a flag to see when we're in the middle of a write.
  	  this.writing = false;

  	  // when true all writes will be buffered until .uncork() call
  	  this.corked = 0;

  	  // a flag to be able to tell if the onwrite cb is called immediately,
  	  // or on a later tick.  We set this to true at first, because any
  	  // actions that shouldn't happen until "later" should generally also
  	  // not happen before the first write call.
  	  this.sync = true;

  	  // a flag to know if we're processing previously buffered items, which
  	  // may call the _write() callback in the same tick, so that we don't
  	  // end up in an overlapped onwrite situation.
  	  this.bufferProcessing = false;

  	  // the callback that's passed to _write(chunk,cb)
  	  this.onwrite = function (er) {
  	    onwrite(stream, er);
  	  };

  	  // the callback that the user supplies to write(chunk,encoding,cb)
  	  this.writecb = null;

  	  // the amount that is being written when _write is called.
  	  this.writelen = 0;

  	  this.bufferedRequest = null;
  	  this.lastBufferedRequest = null;

  	  // number of pending user-supplied write callbacks
  	  // this must be 0 before 'finish' can be emitted
  	  this.pendingcb = 0;

  	  // emit prefinish if the only thing we're waiting for is _write cbs
  	  // This is relevant for synchronous Transform streams
  	  this.prefinished = false;

  	  // True if the error was already emitted and should not be thrown again
  	  this.errorEmitted = false;

  	  // count buffered requests
  	  this.bufferedRequestCount = 0;

  	  // allocate the first CorkedRequest, there is always
  	  // one allocated and free to use, and we maintain at most two
  	  this.corkedRequestsFree = new CorkedRequest(this);
  	}

  	WritableState.prototype.getBuffer = function getBuffer() {
  	  var current = this.bufferedRequest;
  	  var out = [];
  	  while (current) {
  	    out.push(current);
  	    current = current.next;
  	  }
  	  return out;
  	};

  	(function () {
  	  try {
  	    Object.defineProperty(WritableState.prototype, 'buffer', {
  	      get: internalUtil.deprecate(function () {
  	        return this.getBuffer();
  	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
  	    });
  	  } catch (_) {}
  	})();

  	// Test _writableState for inheritance to account for Duplex streams,
  	// whose prototype chain only points to Readable.
  	var realHasInstance;
  	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  	  realHasInstance = Function.prototype[Symbol.hasInstance];
  	  Object.defineProperty(Writable, Symbol.hasInstance, {
  	    value: function (object) {
  	      if (realHasInstance.call(this, object)) return true;

  	      return object && object._writableState instanceof WritableState;
  	    }
  	  });
  	} else {
  	  realHasInstance = function (object) {
  	    return object instanceof this;
  	  };
  	}

  	function Writable(options) {
  	  Duplex = Duplex || require_stream_duplex();

  	  // Writable ctor is applied to Duplexes, too.
  	  // `realHasInstance` is necessary because using plain `instanceof`
  	  // would return false, as no `_writableState` property is attached.

  	  // Trying to use the custom `instanceof` for Writable here will also break the
  	  // Node.js LazyTransform implementation, which has a non-trivial getter for
  	  // `_writableState` that would lead to infinite recursion.
  	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
  	    return new Writable(options);
  	  }

  	  this._writableState = new WritableState(options, this);

  	  // legacy.
  	  this.writable = true;

  	  if (options) {
  	    if (typeof options.write === 'function') this._write = options.write;

  	    if (typeof options.writev === 'function') this._writev = options.writev;

  	    if (typeof options.destroy === 'function') this._destroy = options.destroy;

  	    if (typeof options.final === 'function') this._final = options.final;
  	  }

  	  Stream.call(this);
  	}

  	// Otherwise people can pipe Writable streams, which is just wrong.
  	Writable.prototype.pipe = function () {
  	  this.emit('error', new Error('Cannot pipe, not readable'));
  	};

  	function writeAfterEnd(stream, cb) {
  	  var er = new Error('write after end');
  	  // TODO: defer error events consistently everywhere, not just the cb
  	  stream.emit('error', er);
  	  processNextTick(cb, er);
  	}

  	// Checks that a user-supplied chunk is valid, especially for the particular
  	// mode the stream is in. Currently this means that `null` is never accepted
  	// and undefined/non-string values are only allowed in object mode.
  	function validChunk(stream, state, chunk, cb) {
  	  var valid = true;
  	  var er = false;

  	  if (chunk === null) {
  	    er = new TypeError('May not write null values to stream');
  	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
  	    er = new TypeError('Invalid non-string/buffer chunk');
  	  }
  	  if (er) {
  	    stream.emit('error', er);
  	    processNextTick(cb, er);
  	    valid = false;
  	  }
  	  return valid;
  	}

  	Writable.prototype.write = function (chunk, encoding, cb) {
  	  var state = this._writableState;
  	  var ret = false;
  	  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  	  if (isBuf && !Buffer.isBuffer(chunk)) {
  	    chunk = _uint8ArrayToBuffer(chunk);
  	  }

  	  if (typeof encoding === 'function') {
  	    cb = encoding;
  	    encoding = null;
  	  }

  	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  	  if (typeof cb !== 'function') cb = nop;

  	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
  	    state.pendingcb++;
  	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  	  }

  	  return ret;
  	};

  	Writable.prototype.cork = function () {
  	  var state = this._writableState;

  	  state.corked++;
  	};

  	Writable.prototype.uncork = function () {
  	  var state = this._writableState;

  	  if (state.corked) {
  	    state.corked--;

  	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  	  }
  	};

  	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  	  // node::ParseEncoding() requires lower case.
  	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  	  this._writableState.defaultEncoding = encoding;
  	  return this;
  	};

  	function decodeChunk(state, chunk, encoding) {
  	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
  	    chunk = Buffer.from(chunk, encoding);
  	  }
  	  return chunk;
  	}

  	// if we're already writing something, then just put this
  	// in the queue, and wait our turn.  Otherwise, call _write
  	// If we return false, then we need a drain event, so set that flag.
  	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  	  if (!isBuf) {
  	    var newChunk = decodeChunk(state, chunk, encoding);
  	    if (chunk !== newChunk) {
  	      isBuf = true;
  	      encoding = 'buffer';
  	      chunk = newChunk;
  	    }
  	  }
  	  var len = state.objectMode ? 1 : chunk.length;

  	  state.length += len;

  	  var ret = state.length < state.highWaterMark;
  	  // we must ensure that previous needDrain will not be reset to false.
  	  if (!ret) state.needDrain = true;

  	  if (state.writing || state.corked) {
  	    var last = state.lastBufferedRequest;
  	    state.lastBufferedRequest = {
  	      chunk: chunk,
  	      encoding: encoding,
  	      isBuf: isBuf,
  	      callback: cb,
  	      next: null
  	    };
  	    if (last) {
  	      last.next = state.lastBufferedRequest;
  	    } else {
  	      state.bufferedRequest = state.lastBufferedRequest;
  	    }
  	    state.bufferedRequestCount += 1;
  	  } else {
  	    doWrite(stream, state, false, len, chunk, encoding, cb);
  	  }

  	  return ret;
  	}

  	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  	  state.writelen = len;
  	  state.writecb = cb;
  	  state.writing = true;
  	  state.sync = true;
  	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  	  state.sync = false;
  	}

  	function onwriteError(stream, state, sync, er, cb) {
  	  --state.pendingcb;

  	  if (sync) {
  	    // defer the callback if we are being called synchronously
  	    // to avoid piling up things on the stack
  	    processNextTick(cb, er);
  	    // this can emit finish, and it will always happen
  	    // after error
  	    processNextTick(finishMaybe, stream, state);
  	    stream._writableState.errorEmitted = true;
  	    stream.emit('error', er);
  	  } else {
  	    // the caller expect this to happen before if
  	    // it is async
  	    cb(er);
  	    stream._writableState.errorEmitted = true;
  	    stream.emit('error', er);
  	    // this can emit finish, but finish must
  	    // always follow error
  	    finishMaybe(stream, state);
  	  }
  	}

  	function onwriteStateUpdate(state) {
  	  state.writing = false;
  	  state.writecb = null;
  	  state.length -= state.writelen;
  	  state.writelen = 0;
  	}

  	function onwrite(stream, er) {
  	  var state = stream._writableState;
  	  var sync = state.sync;
  	  var cb = state.writecb;

  	  onwriteStateUpdate(state);

  	  if (er) onwriteError(stream, state, sync, er, cb);else {
  	    // Check if we're actually ready to finish, but don't emit yet
  	    var finished = needFinish(state);

  	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
  	      clearBuffer(stream, state);
  	    }

  	    if (sync) {
  	      /*<replacement>*/
  	      asyncWrite(afterWrite, stream, state, finished, cb);
  	      /*</replacement>*/
  	    } else {
  	      afterWrite(stream, state, finished, cb);
  	    }
  	  }
  	}

  	function afterWrite(stream, state, finished, cb) {
  	  if (!finished) onwriteDrain(stream, state);
  	  state.pendingcb--;
  	  cb();
  	  finishMaybe(stream, state);
  	}

  	// Must force callback to be called on nextTick, so that we don't
  	// emit 'drain' before the write() consumer gets the 'false' return
  	// value, and has a chance to attach a 'drain' listener.
  	function onwriteDrain(stream, state) {
  	  if (state.length === 0 && state.needDrain) {
  	    state.needDrain = false;
  	    stream.emit('drain');
  	  }
  	}

  	// if there's something in the buffer waiting, then process it
  	function clearBuffer(stream, state) {
  	  state.bufferProcessing = true;
  	  var entry = state.bufferedRequest;

  	  if (stream._writev && entry && entry.next) {
  	    // Fast case, write everything using _writev()
  	    var l = state.bufferedRequestCount;
  	    var buffer = new Array(l);
  	    var holder = state.corkedRequestsFree;
  	    holder.entry = entry;

  	    var count = 0;
  	    var allBuffers = true;
  	    while (entry) {
  	      buffer[count] = entry;
  	      if (!entry.isBuf) allBuffers = false;
  	      entry = entry.next;
  	      count += 1;
  	    }
  	    buffer.allBuffers = allBuffers;

  	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

  	    // doWrite is almost always async, defer these to save a bit of time
  	    // as the hot path ends with doWrite
  	    state.pendingcb++;
  	    state.lastBufferedRequest = null;
  	    if (holder.next) {
  	      state.corkedRequestsFree = holder.next;
  	      holder.next = null;
  	    } else {
  	      state.corkedRequestsFree = new CorkedRequest(state);
  	    }
  	  } else {
  	    // Slow case, write chunks one-by-one
  	    while (entry) {
  	      var chunk = entry.chunk;
  	      var encoding = entry.encoding;
  	      var cb = entry.callback;
  	      var len = state.objectMode ? 1 : chunk.length;

  	      doWrite(stream, state, false, len, chunk, encoding, cb);
  	      entry = entry.next;
  	      // if we didn't call the onwrite immediately, then
  	      // it means that we need to wait until it does.
  	      // also, that means that the chunk and cb are currently
  	      // being processed, so move the buffer counter past them.
  	      if (state.writing) {
  	        break;
  	      }
  	    }

  	    if (entry === null) state.lastBufferedRequest = null;
  	  }

  	  state.bufferedRequestCount = 0;
  	  state.bufferedRequest = entry;
  	  state.bufferProcessing = false;
  	}

  	Writable.prototype._write = function (chunk, encoding, cb) {
  	  cb(new Error('_write() is not implemented'));
  	};

  	Writable.prototype._writev = null;

  	Writable.prototype.end = function (chunk, encoding, cb) {
  	  var state = this._writableState;

  	  if (typeof chunk === 'function') {
  	    cb = chunk;
  	    chunk = null;
  	    encoding = null;
  	  } else if (typeof encoding === 'function') {
  	    cb = encoding;
  	    encoding = null;
  	  }

  	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  	  // .end() fully uncorks
  	  if (state.corked) {
  	    state.corked = 1;
  	    this.uncork();
  	  }

  	  // ignore unnecessary end() calls.
  	  if (!state.ending && !state.finished) endWritable(this, state, cb);
  	};

  	function needFinish(state) {
  	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  	}
  	function callFinal(stream, state) {
  	  stream._final(function (err) {
  	    state.pendingcb--;
  	    if (err) {
  	      stream.emit('error', err);
  	    }
  	    state.prefinished = true;
  	    stream.emit('prefinish');
  	    finishMaybe(stream, state);
  	  });
  	}
  	function prefinish(stream, state) {
  	  if (!state.prefinished && !state.finalCalled) {
  	    if (typeof stream._final === 'function') {
  	      state.pendingcb++;
  	      state.finalCalled = true;
  	      processNextTick(callFinal, stream, state);
  	    } else {
  	      state.prefinished = true;
  	      stream.emit('prefinish');
  	    }
  	  }
  	}

  	function finishMaybe(stream, state) {
  	  var need = needFinish(state);
  	  if (need) {
  	    prefinish(stream, state);
  	    if (state.pendingcb === 0) {
  	      state.finished = true;
  	      stream.emit('finish');
  	    }
  	  }
  	  return need;
  	}

  	function endWritable(stream, state, cb) {
  	  state.ending = true;
  	  finishMaybe(stream, state);
  	  if (cb) {
  	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  	  }
  	  state.ended = true;
  	  stream.writable = false;
  	}

  	function onCorkedFinish(corkReq, state, err) {
  	  var entry = corkReq.entry;
  	  corkReq.entry = null;
  	  while (entry) {
  	    var cb = entry.callback;
  	    state.pendingcb--;
  	    cb(err);
  	    entry = entry.next;
  	  }
  	  if (state.corkedRequestsFree) {
  	    state.corkedRequestsFree.next = corkReq;
  	  } else {
  	    state.corkedRequestsFree = corkReq;
  	  }
  	}

  	Object.defineProperty(Writable.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._writableState === undefined) {
  	      return false;
  	    }
  	    return this._writableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (!this._writableState) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._writableState.destroyed = value;
  	  }
  	});

  	Writable.prototype.destroy = destroyImpl.destroy;
  	Writable.prototype._undestroy = destroyImpl.undestroy;
  	Writable.prototype._destroy = function (err, cb) {
  	  this.end();
  	  cb(err);
  	};
  	return _stream_writable;
  }

  var _stream_duplex;
  var hasRequired_stream_duplex;

  function require_stream_duplex () {
  	if (hasRequired_stream_duplex) return _stream_duplex;
  	hasRequired_stream_duplex = 1;

  	/*<replacement>*/

  	var processNextTick = processNextickArgs.exports;
  	/*</replacement>*/

  	/*<replacement>*/
  	var objectKeys = Object.keys || function (obj) {
  	  var keys = [];
  	  for (var key in obj) {
  	    keys.push(key);
  	  }return keys;
  	};
  	/*</replacement>*/

  	_stream_duplex = Duplex;

  	/*<replacement>*/
  	var util = requireUtil();
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	var Readable = require_stream_readable();
  	var Writable = require_stream_writable();

  	util.inherits(Duplex, Readable);

  	var keys = objectKeys(Writable.prototype);
  	for (var v = 0; v < keys.length; v++) {
  	  var method = keys[v];
  	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  	}

  	function Duplex(options) {
  	  if (!(this instanceof Duplex)) return new Duplex(options);

  	  Readable.call(this, options);
  	  Writable.call(this, options);

  	  if (options && options.readable === false) this.readable = false;

  	  if (options && options.writable === false) this.writable = false;

  	  this.allowHalfOpen = true;
  	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  	  this.once('end', onend);
  	}

  	// the no-half-open enforcer
  	function onend() {
  	  // if we allow half-open state, or if the writable side ended,
  	  // then we're ok.
  	  if (this.allowHalfOpen || this._writableState.ended) return;

  	  // no more data can be written.
  	  // But allow more writes to happen in this tick.
  	  processNextTick(onEndNT, this);
  	}

  	function onEndNT(self) {
  	  self.end();
  	}

  	Object.defineProperty(Duplex.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._readableState === undefined || this._writableState === undefined) {
  	      return false;
  	    }
  	    return this._readableState.destroyed && this._writableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (this._readableState === undefined || this._writableState === undefined) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._readableState.destroyed = value;
  	    this._writableState.destroyed = value;
  	  }
  	});

  	Duplex.prototype._destroy = function (err, cb) {
  	  this.push(null);
  	  this.end();

  	  processNextTick(cb, err);
  	};
  	return _stream_duplex;
  }

  var string_decoder = {};

  var hasRequiredString_decoder;

  function requireString_decoder () {
  	if (hasRequiredString_decoder) return string_decoder;
  	hasRequiredString_decoder = 1;

  	var Buffer = requireSafeBuffer().Buffer;

  	var isEncoding = Buffer.isEncoding || function (encoding) {
  	  encoding = '' + encoding;
  	  switch (encoding && encoding.toLowerCase()) {
  	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
  	      return true;
  	    default:
  	      return false;
  	  }
  	};

  	function _normalizeEncoding(enc) {
  	  if (!enc) return 'utf8';
  	  var retried;
  	  while (true) {
  	    switch (enc) {
  	      case 'utf8':
  	      case 'utf-8':
  	        return 'utf8';
  	      case 'ucs2':
  	      case 'ucs-2':
  	      case 'utf16le':
  	      case 'utf-16le':
  	        return 'utf16le';
  	      case 'latin1':
  	      case 'binary':
  	        return 'latin1';
  	      case 'base64':
  	      case 'ascii':
  	      case 'hex':
  	        return enc;
  	      default:
  	        if (retried) return; // undefined
  	        enc = ('' + enc).toLowerCase();
  	        retried = true;
  	    }
  	  }
  	}
  	// Do not cache `Buffer.isEncoding` when checking encoding names as some
  	// modules monkey-patch it to support additional encodings
  	function normalizeEncoding(enc) {
  	  var nenc = _normalizeEncoding(enc);
  	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  	  return nenc || enc;
  	}

  	// StringDecoder provides an interface for efficiently splitting a series of
  	// buffers into a series of JS strings without breaking apart multi-byte
  	// characters.
  	string_decoder.StringDecoder = StringDecoder;
  	function StringDecoder(encoding) {
  	  this.encoding = normalizeEncoding(encoding);
  	  var nb;
  	  switch (this.encoding) {
  	    case 'utf16le':
  	      this.text = utf16Text;
  	      this.end = utf16End;
  	      nb = 4;
  	      break;
  	    case 'utf8':
  	      this.fillLast = utf8FillLast;
  	      nb = 4;
  	      break;
  	    case 'base64':
  	      this.text = base64Text;
  	      this.end = base64End;
  	      nb = 3;
  	      break;
  	    default:
  	      this.write = simpleWrite;
  	      this.end = simpleEnd;
  	      return;
  	  }
  	  this.lastNeed = 0;
  	  this.lastTotal = 0;
  	  this.lastChar = Buffer.allocUnsafe(nb);
  	}

  	StringDecoder.prototype.write = function (buf) {
  	  if (buf.length === 0) return '';
  	  var r;
  	  var i;
  	  if (this.lastNeed) {
  	    r = this.fillLast(buf);
  	    if (r === undefined) return '';
  	    i = this.lastNeed;
  	    this.lastNeed = 0;
  	  } else {
  	    i = 0;
  	  }
  	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  	  return r || '';
  	};

  	StringDecoder.prototype.end = utf8End;

  	// Returns only complete characters in a Buffer
  	StringDecoder.prototype.text = utf8Text;

  	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  	StringDecoder.prototype.fillLast = function (buf) {
  	  if (this.lastNeed <= buf.length) {
  	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
  	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  	  }
  	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  	  this.lastNeed -= buf.length;
  	};

  	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  	// continuation byte.
  	function utf8CheckByte(byte) {
  	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  	  return -1;
  	}

  	// Checks at most 3 bytes at the end of a Buffer in order to detect an
  	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  	// needed to complete the UTF-8 character (if applicable) are returned.
  	function utf8CheckIncomplete(self, buf, i) {
  	  var j = buf.length - 1;
  	  if (j < i) return 0;
  	  var nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) self.lastNeed = nb - 1;
  	    return nb;
  	  }
  	  if (--j < i) return 0;
  	  nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) self.lastNeed = nb - 2;
  	    return nb;
  	  }
  	  if (--j < i) return 0;
  	  nb = utf8CheckByte(buf[j]);
  	  if (nb >= 0) {
  	    if (nb > 0) {
  	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
  	    }
  	    return nb;
  	  }
  	  return 0;
  	}

  	// Validates as many continuation bytes for a multi-byte UTF-8 character as
  	// needed or are available. If we see a non-continuation byte where we expect
  	// one, we "replace" the validated continuation bytes we've seen so far with
  	// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
  	// behavior. The continuation byte check is included three times in the case
  	// where all of the continuation bytes for a character exist in the same buffer.
  	// It is also done this way as a slight performance increase instead of using a
  	// loop.
  	function utf8CheckExtraBytes(self, buf, p) {
  	  if ((buf[0] & 0xC0) !== 0x80) {
  	    self.lastNeed = 0;
  	    return '\ufffd'.repeat(p);
  	  }
  	  if (self.lastNeed > 1 && buf.length > 1) {
  	    if ((buf[1] & 0xC0) !== 0x80) {
  	      self.lastNeed = 1;
  	      return '\ufffd'.repeat(p + 1);
  	    }
  	    if (self.lastNeed > 2 && buf.length > 2) {
  	      if ((buf[2] & 0xC0) !== 0x80) {
  	        self.lastNeed = 2;
  	        return '\ufffd'.repeat(p + 2);
  	      }
  	    }
  	  }
  	}

  	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  	function utf8FillLast(buf) {
  	  var p = this.lastTotal - this.lastNeed;
  	  var r = utf8CheckExtraBytes(this, buf, p);
  	  if (r !== undefined) return r;
  	  if (this.lastNeed <= buf.length) {
  	    buf.copy(this.lastChar, p, 0, this.lastNeed);
  	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  	  }
  	  buf.copy(this.lastChar, p, 0, buf.length);
  	  this.lastNeed -= buf.length;
  	}

  	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  	// partial character, the character's bytes are buffered until the required
  	// number of bytes are available.
  	function utf8Text(buf, i) {
  	  var total = utf8CheckIncomplete(this, buf, i);
  	  if (!this.lastNeed) return buf.toString('utf8', i);
  	  this.lastTotal = total;
  	  var end = buf.length - (total - this.lastNeed);
  	  buf.copy(this.lastChar, 0, end);
  	  return buf.toString('utf8', i, end);
  	}

  	// For UTF-8, a replacement character for each buffered byte of a (partial)
  	// character needs to be added to the output.
  	function utf8End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  	  return r;
  	}

  	// UTF-16LE typically needs two bytes per character, but even if we have an even
  	// number of bytes available, we need to check if we end on a leading/high
  	// surrogate. In that case, we need to wait for the next two bytes in order to
  	// decode the last character properly.
  	function utf16Text(buf, i) {
  	  if ((buf.length - i) % 2 === 0) {
  	    var r = buf.toString('utf16le', i);
  	    if (r) {
  	      var c = r.charCodeAt(r.length - 1);
  	      if (c >= 0xD800 && c <= 0xDBFF) {
  	        this.lastNeed = 2;
  	        this.lastTotal = 4;
  	        this.lastChar[0] = buf[buf.length - 2];
  	        this.lastChar[1] = buf[buf.length - 1];
  	        return r.slice(0, -1);
  	      }
  	    }
  	    return r;
  	  }
  	  this.lastNeed = 1;
  	  this.lastTotal = 2;
  	  this.lastChar[0] = buf[buf.length - 1];
  	  return buf.toString('utf16le', i, buf.length - 1);
  	}

  	// For UTF-16LE we do not explicitly append special replacement characters if we
  	// end on a partial character, we simply let v8 handle that.
  	function utf16End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) {
  	    var end = this.lastTotal - this.lastNeed;
  	    return r + this.lastChar.toString('utf16le', 0, end);
  	  }
  	  return r;
  	}

  	function base64Text(buf, i) {
  	  var n = (buf.length - i) % 3;
  	  if (n === 0) return buf.toString('base64', i);
  	  this.lastNeed = 3 - n;
  	  this.lastTotal = 3;
  	  if (n === 1) {
  	    this.lastChar[0] = buf[buf.length - 1];
  	  } else {
  	    this.lastChar[0] = buf[buf.length - 2];
  	    this.lastChar[1] = buf[buf.length - 1];
  	  }
  	  return buf.toString('base64', i, buf.length - n);
  	}

  	function base64End(buf) {
  	  var r = buf && buf.length ? this.write(buf) : '';
  	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  	  return r;
  	}

  	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  	function simpleWrite(buf) {
  	  return buf.toString(this.encoding);
  	}

  	function simpleEnd(buf) {
  	  return buf && buf.length ? this.write(buf) : '';
  	}
  	return string_decoder;
  }

  var _stream_readable;
  var hasRequired_stream_readable;

  function require_stream_readable () {
  	if (hasRequired_stream_readable) return _stream_readable;
  	hasRequired_stream_readable = 1;

  	/*<replacement>*/

  	var processNextTick = processNextickArgs.exports;
  	/*</replacement>*/

  	_stream_readable = Readable;

  	/*<replacement>*/
  	var isArray = requireIsarray();
  	/*</replacement>*/

  	/*<replacement>*/
  	var Duplex;
  	/*</replacement>*/

  	Readable.ReadableState = ReadableState;

  	/*<replacement>*/
  	require$$2.EventEmitter;

  	var EElistenerCount = function (emitter, type) {
  	  return emitter.listeners(type).length;
  	};
  	/*</replacement>*/

  	/*<replacement>*/
  	var Stream = streamBrowser;
  	/*</replacement>*/

  	// TODO(bmeurer): Change this back to const once hole checks are
  	// properly optimized away early in Ignition+TurboFan.
  	/*<replacement>*/
  	var Buffer = requireSafeBuffer().Buffer;
  	var OurUint8Array = commonjsGlobal.Uint8Array || function () {};
  	function _uint8ArrayToBuffer(chunk) {
  	  return Buffer.from(chunk);
  	}
  	function _isUint8Array(obj) {
  	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  	}
  	/*</replacement>*/

  	/*<replacement>*/
  	var util = requireUtil();
  	util.inherits = requireInherits_browser();
  	/*</replacement>*/

  	/*<replacement>*/
  	var debugUtil = require$$0$1;
  	var debug = void 0;
  	if (debugUtil && debugUtil.debuglog) {
  	  debug = debugUtil.debuglog('stream');
  	} else {
  	  debug = function () {};
  	}
  	/*</replacement>*/

  	var BufferList = requireBufferList();
  	var destroyImpl = destroy_1;
  	var StringDecoder;

  	util.inherits(Readable, Stream);

  	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

  	function prependListener(emitter, event, fn) {
  	  // Sadly this is not cacheable as some libraries bundle their own
  	  // event emitter implementation with them.
  	  if (typeof emitter.prependListener === 'function') {
  	    return emitter.prependListener(event, fn);
  	  } else {
  	    // This is a hack to make sure that our error handler is attached before any
  	    // userland ones.  NEVER DO THIS. This is here only because this code needs
  	    // to continue to work with older versions of Node.js that do not include
  	    // the prependListener() method. The goal is to eventually remove this hack.
  	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  	  }
  	}

  	function ReadableState(options, stream) {
  	  Duplex = Duplex || require_stream_duplex();

  	  options = options || {};

  	  // object stream flag. Used to make read(n) ignore n and to
  	  // make all the buffer merging and length checks go away
  	  this.objectMode = !!options.objectMode;

  	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  	  // the point at which it stops calling _read() to fill the buffer
  	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  	  var hwm = options.highWaterMark;
  	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  	  // cast to ints.
  	  this.highWaterMark = Math.floor(this.highWaterMark);

  	  // A linked list is used to store data chunks instead of an array because the
  	  // linked list can remove elements from the beginning faster than
  	  // array.shift()
  	  this.buffer = new BufferList();
  	  this.length = 0;
  	  this.pipes = null;
  	  this.pipesCount = 0;
  	  this.flowing = null;
  	  this.ended = false;
  	  this.endEmitted = false;
  	  this.reading = false;

  	  // a flag to be able to tell if the event 'readable'/'data' is emitted
  	  // immediately, or on a later tick.  We set this to true at first, because
  	  // any actions that shouldn't happen until "later" should generally also
  	  // not happen before the first read call.
  	  this.sync = true;

  	  // whenever we return null, then we set a flag to say
  	  // that we're awaiting a 'readable' event emission.
  	  this.needReadable = false;
  	  this.emittedReadable = false;
  	  this.readableListening = false;
  	  this.resumeScheduled = false;

  	  // has it been destroyed
  	  this.destroyed = false;

  	  // Crypto is kind of old and crusty.  Historically, its default string
  	  // encoding is 'binary' so we have to make this configurable.
  	  // Everything else in the universe uses 'utf8', though.
  	  this.defaultEncoding = options.defaultEncoding || 'utf8';

  	  // the number of writers that are awaiting a drain event in .pipe()s
  	  this.awaitDrain = 0;

  	  // if true, a maybeReadMore has been scheduled
  	  this.readingMore = false;

  	  this.decoder = null;
  	  this.encoding = null;
  	  if (options.encoding) {
  	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
  	    this.decoder = new StringDecoder(options.encoding);
  	    this.encoding = options.encoding;
  	  }
  	}

  	function Readable(options) {
  	  Duplex = Duplex || require_stream_duplex();

  	  if (!(this instanceof Readable)) return new Readable(options);

  	  this._readableState = new ReadableState(options, this);

  	  // legacy
  	  this.readable = true;

  	  if (options) {
  	    if (typeof options.read === 'function') this._read = options.read;

  	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  	  }

  	  Stream.call(this);
  	}

  	Object.defineProperty(Readable.prototype, 'destroyed', {
  	  get: function () {
  	    if (this._readableState === undefined) {
  	      return false;
  	    }
  	    return this._readableState.destroyed;
  	  },
  	  set: function (value) {
  	    // we ignore the value if the stream
  	    // has not been initialized yet
  	    if (!this._readableState) {
  	      return;
  	    }

  	    // backward compatibility, the user is explicitly
  	    // managing destroyed
  	    this._readableState.destroyed = value;
  	  }
  	});

  	Readable.prototype.destroy = destroyImpl.destroy;
  	Readable.prototype._undestroy = destroyImpl.undestroy;
  	Readable.prototype._destroy = function (err, cb) {
  	  this.push(null);
  	  cb(err);
  	};

  	// Manually shove something into the read() buffer.
  	// This returns true if the highWaterMark has not been hit yet,
  	// similar to how Writable.write() returns true if you should
  	// write() some more.
  	Readable.prototype.push = function (chunk, encoding) {
  	  var state = this._readableState;
  	  var skipChunkCheck;

  	  if (!state.objectMode) {
  	    if (typeof chunk === 'string') {
  	      encoding = encoding || state.defaultEncoding;
  	      if (encoding !== state.encoding) {
  	        chunk = Buffer.from(chunk, encoding);
  	        encoding = '';
  	      }
  	      skipChunkCheck = true;
  	    }
  	  } else {
  	    skipChunkCheck = true;
  	  }

  	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  	};

  	// Unshift should *always* be something directly out of read()
  	Readable.prototype.unshift = function (chunk) {
  	  return readableAddChunk(this, chunk, null, true, false);
  	};

  	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  	  var state = stream._readableState;
  	  if (chunk === null) {
  	    state.reading = false;
  	    onEofChunk(stream, state);
  	  } else {
  	    var er;
  	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
  	    if (er) {
  	      stream.emit('error', er);
  	    } else if (state.objectMode || chunk && chunk.length > 0) {
  	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
  	        chunk = _uint8ArrayToBuffer(chunk);
  	      }

  	      if (addToFront) {
  	        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
  	      } else if (state.ended) {
  	        stream.emit('error', new Error('stream.push() after EOF'));
  	      } else {
  	        state.reading = false;
  	        if (state.decoder && !encoding) {
  	          chunk = state.decoder.write(chunk);
  	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
  	        } else {
  	          addChunk(stream, state, chunk, false);
  	        }
  	      }
  	    } else if (!addToFront) {
  	      state.reading = false;
  	    }
  	  }

  	  return needMoreData(state);
  	}

  	function addChunk(stream, state, chunk, addToFront) {
  	  if (state.flowing && state.length === 0 && !state.sync) {
  	    stream.emit('data', chunk);
  	    stream.read(0);
  	  } else {
  	    // update the buffer info.
  	    state.length += state.objectMode ? 1 : chunk.length;
  	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

  	    if (state.needReadable) emitReadable(stream);
  	  }
  	  maybeReadMore(stream, state);
  	}

  	function chunkInvalid(state, chunk) {
  	  var er;
  	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
  	    er = new TypeError('Invalid non-string/buffer chunk');
  	  }
  	  return er;
  	}

  	// if it's past the high water mark, we can push in some more.
  	// Also, if we have no data yet, we can stand some
  	// more bytes.  This is to work around cases where hwm=0,
  	// such as the repl.  Also, if the push() triggered a
  	// readable event, and the user called read(largeNumber) such that
  	// needReadable was set, then we ought to push more, so that another
  	// 'readable' event will be triggered.
  	function needMoreData(state) {
  	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  	}

  	Readable.prototype.isPaused = function () {
  	  return this._readableState.flowing === false;
  	};

  	// backwards compatibility.
  	Readable.prototype.setEncoding = function (enc) {
  	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
  	  this._readableState.decoder = new StringDecoder(enc);
  	  this._readableState.encoding = enc;
  	  return this;
  	};

  	// Don't raise the hwm > 8MB
  	var MAX_HWM = 0x800000;
  	function computeNewHighWaterMark(n) {
  	  if (n >= MAX_HWM) {
  	    n = MAX_HWM;
  	  } else {
  	    // Get the next highest power of 2 to prevent increasing hwm excessively in
  	    // tiny amounts
  	    n--;
  	    n |= n >>> 1;
  	    n |= n >>> 2;
  	    n |= n >>> 4;
  	    n |= n >>> 8;
  	    n |= n >>> 16;
  	    n++;
  	  }
  	  return n;
  	}

  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function howMuchToRead(n, state) {
  	  if (n <= 0 || state.length === 0 && state.ended) return 0;
  	  if (state.objectMode) return 1;
  	  if (n !== n) {
  	    // Only flow one buffer at a time
  	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  	  }
  	  // If we're asking for more than the current hwm, then raise the hwm.
  	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  	  if (n <= state.length) return n;
  	  // Don't have enough
  	  if (!state.ended) {
  	    state.needReadable = true;
  	    return 0;
  	  }
  	  return state.length;
  	}

  	// you can override either this method, or the async _read(n) below.
  	Readable.prototype.read = function (n) {
  	  debug('read', n);
  	  n = parseInt(n, 10);
  	  var state = this._readableState;
  	  var nOrig = n;

  	  if (n !== 0) state.emittedReadable = false;

  	  // if we're doing read(0) to trigger a readable event, but we
  	  // already have a bunch of data in the buffer, then just trigger
  	  // the 'readable' event and move on.
  	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
  	    debug('read: emitReadable', state.length, state.ended);
  	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
  	    return null;
  	  }

  	  n = howMuchToRead(n, state);

  	  // if we've ended, and we're now clear, then finish it up.
  	  if (n === 0 && state.ended) {
  	    if (state.length === 0) endReadable(this);
  	    return null;
  	  }

  	  // All the actual chunk generation logic needs to be
  	  // *below* the call to _read.  The reason is that in certain
  	  // synthetic stream cases, such as passthrough streams, _read
  	  // may be a completely synchronous operation which may change
  	  // the state of the read buffer, providing enough data when
  	  // before there was *not* enough.
  	  //
  	  // So, the steps are:
  	  // 1. Figure out what the state of things will be after we do
  	  // a read from the buffer.
  	  //
  	  // 2. If that resulting state will trigger a _read, then call _read.
  	  // Note that this may be asynchronous, or synchronous.  Yes, it is
  	  // deeply ugly to write APIs this way, but that still doesn't mean
  	  // that the Readable class should behave improperly, as streams are
  	  // designed to be sync/async agnostic.
  	  // Take note if the _read call is sync or async (ie, if the read call
  	  // has returned yet), so that we know whether or not it's safe to emit
  	  // 'readable' etc.
  	  //
  	  // 3. Actually pull the requested chunks out of the buffer and return.

  	  // if we need a readable event, then we need to do some reading.
  	  var doRead = state.needReadable;
  	  debug('need readable', doRead);

  	  // if we currently have less than the highWaterMark, then also read some
  	  if (state.length === 0 || state.length - n < state.highWaterMark) {
  	    doRead = true;
  	    debug('length less than watermark', doRead);
  	  }

  	  // however, if we've ended, then there's no point, and if we're already
  	  // reading, then it's unnecessary.
  	  if (state.ended || state.reading) {
  	    doRead = false;
  	    debug('reading or ended', doRead);
  	  } else if (doRead) {
  	    debug('do read');
  	    state.reading = true;
  	    state.sync = true;
  	    // if the length is currently zero, then we *need* a readable event.
  	    if (state.length === 0) state.needReadable = true;
  	    // call internal read method
  	    this._read(state.highWaterMark);
  	    state.sync = false;
  	    // If _read pushed data synchronously, then `reading` will be false,
  	    // and we need to re-evaluate how much data we can return to the user.
  	    if (!state.reading) n = howMuchToRead(nOrig, state);
  	  }

  	  var ret;
  	  if (n > 0) ret = fromList(n, state);else ret = null;

  	  if (ret === null) {
  	    state.needReadable = true;
  	    n = 0;
  	  } else {
  	    state.length -= n;
  	  }

  	  if (state.length === 0) {
  	    // If we have nothing in the buffer, then we want to know
  	    // as soon as we *do* get something into the buffer.
  	    if (!state.ended) state.needReadable = true;

  	    // If we tried to read() past the EOF, then emit end on the next tick.
  	    if (nOrig !== n && state.ended) endReadable(this);
  	  }

  	  if (ret !== null) this.emit('data', ret);

  	  return ret;
  	};

  	function onEofChunk(stream, state) {
  	  if (state.ended) return;
  	  if (state.decoder) {
  	    var chunk = state.decoder.end();
  	    if (chunk && chunk.length) {
  	      state.buffer.push(chunk);
  	      state.length += state.objectMode ? 1 : chunk.length;
  	    }
  	  }
  	  state.ended = true;

  	  // emit 'readable' now to make sure it gets picked up.
  	  emitReadable(stream);
  	}

  	// Don't emit readable right away in sync mode, because this can trigger
  	// another read() call => stack overflow.  This way, it might trigger
  	// a nextTick recursion warning, but that's not so bad.
  	function emitReadable(stream) {
  	  var state = stream._readableState;
  	  state.needReadable = false;
  	  if (!state.emittedReadable) {
  	    debug('emitReadable', state.flowing);
  	    state.emittedReadable = true;
  	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  	  }
  	}

  	function emitReadable_(stream) {
  	  debug('emit readable');
  	  stream.emit('readable');
  	  flow(stream);
  	}

  	// at this point, the user has presumably seen the 'readable' event,
  	// and called read() to consume some data.  that may have triggered
  	// in turn another _read(n) call, in which case reading = true if
  	// it's in progress.
  	// However, if we're not ended, or reading, and the length < hwm,
  	// then go ahead and try to read some more preemptively.
  	function maybeReadMore(stream, state) {
  	  if (!state.readingMore) {
  	    state.readingMore = true;
  	    processNextTick(maybeReadMore_, stream, state);
  	  }
  	}

  	function maybeReadMore_(stream, state) {
  	  var len = state.length;
  	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
  	    debug('maybeReadMore read 0');
  	    stream.read(0);
  	    if (len === state.length)
  	      // didn't get any data, stop spinning.
  	      break;else len = state.length;
  	  }
  	  state.readingMore = false;
  	}

  	// abstract method.  to be overridden in specific implementation classes.
  	// call cb(er, data) where data is <= n in length.
  	// for virtual (non-string, non-buffer) streams, "length" is somewhat
  	// arbitrary, and perhaps not very meaningful.
  	Readable.prototype._read = function (n) {
  	  this.emit('error', new Error('_read() is not implemented'));
  	};

  	Readable.prototype.pipe = function (dest, pipeOpts) {
  	  var src = this;
  	  var state = this._readableState;

  	  switch (state.pipesCount) {
  	    case 0:
  	      state.pipes = dest;
  	      break;
  	    case 1:
  	      state.pipes = [state.pipes, dest];
  	      break;
  	    default:
  	      state.pipes.push(dest);
  	      break;
  	  }
  	  state.pipesCount += 1;
  	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;

  	  var endFn = doEnd ? onend : unpipe;
  	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  	  dest.on('unpipe', onunpipe);
  	  function onunpipe(readable, unpipeInfo) {
  	    debug('onunpipe');
  	    if (readable === src) {
  	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
  	        unpipeInfo.hasUnpiped = true;
  	        cleanup();
  	      }
  	    }
  	  }

  	  function onend() {
  	    debug('onend');
  	    dest.end();
  	  }

  	  // when the dest drains, it reduces the awaitDrain counter
  	  // on the source.  This would be more elegant with a .once()
  	  // handler in flow(), but adding and removing repeatedly is
  	  // too slow.
  	  var ondrain = pipeOnDrain(src);
  	  dest.on('drain', ondrain);

  	  var cleanedUp = false;
  	  function cleanup() {
  	    debug('cleanup');
  	    // cleanup event handlers once the pipe is broken
  	    dest.removeListener('close', onclose);
  	    dest.removeListener('finish', onfinish);
  	    dest.removeListener('drain', ondrain);
  	    dest.removeListener('error', onerror);
  	    dest.removeListener('unpipe', onunpipe);
  	    src.removeListener('end', onend);
  	    src.removeListener('end', unpipe);
  	    src.removeListener('data', ondata);

  	    cleanedUp = true;

  	    // if the reader is waiting for a drain event from this
  	    // specific writer, then it would cause it to never start
  	    // flowing again.
  	    // So, if this is awaiting a drain, then we just call it now.
  	    // If we don't know, then assume that we are waiting for one.
  	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  	  }

  	  // If the user pushes more data while we're writing to dest then we'll end up
  	  // in ondata again. However, we only want to increase awaitDrain once because
  	  // dest will only emit one 'drain' event for the multiple writes.
  	  // => Introduce a guard on increasing awaitDrain.
  	  var increasedAwaitDrain = false;
  	  src.on('data', ondata);
  	  function ondata(chunk) {
  	    debug('ondata');
  	    increasedAwaitDrain = false;
  	    var ret = dest.write(chunk);
  	    if (false === ret && !increasedAwaitDrain) {
  	      // If the user unpiped during `dest.write()`, it is possible
  	      // to get stuck in a permanently paused state if that write
  	      // also returned false.
  	      // => Check whether `dest` is still a piping destination.
  	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
  	        debug('false write response, pause', src._readableState.awaitDrain);
  	        src._readableState.awaitDrain++;
  	        increasedAwaitDrain = true;
  	      }
  	      src.pause();
  	    }
  	  }

  	  // if the dest has an error, then stop piping into it.
  	  // however, don't suppress the throwing behavior for this.
  	  function onerror(er) {
  	    debug('onerror', er);
  	    unpipe();
  	    dest.removeListener('error', onerror);
  	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  	  }

  	  // Make sure our error handler is attached before userland ones.
  	  prependListener(dest, 'error', onerror);

  	  // Both close and finish should trigger unpipe, but only once.
  	  function onclose() {
  	    dest.removeListener('finish', onfinish);
  	    unpipe();
  	  }
  	  dest.once('close', onclose);
  	  function onfinish() {
  	    debug('onfinish');
  	    dest.removeListener('close', onclose);
  	    unpipe();
  	  }
  	  dest.once('finish', onfinish);

  	  function unpipe() {
  	    debug('unpipe');
  	    src.unpipe(dest);
  	  }

  	  // tell the dest that it's being piped to
  	  dest.emit('pipe', src);

  	  // start the flow if it hasn't been started already.
  	  if (!state.flowing) {
  	    debug('pipe resume');
  	    src.resume();
  	  }

  	  return dest;
  	};

  	function pipeOnDrain(src) {
  	  return function () {
  	    var state = src._readableState;
  	    debug('pipeOnDrain', state.awaitDrain);
  	    if (state.awaitDrain) state.awaitDrain--;
  	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
  	      state.flowing = true;
  	      flow(src);
  	    }
  	  };
  	}

  	Readable.prototype.unpipe = function (dest) {
  	  var state = this._readableState;
  	  var unpipeInfo = { hasUnpiped: false };

  	  // if we're not piping anywhere, then do nothing.
  	  if (state.pipesCount === 0) return this;

  	  // just one destination.  most common case.
  	  if (state.pipesCount === 1) {
  	    // passed in one, but it's not the right one.
  	    if (dest && dest !== state.pipes) return this;

  	    if (!dest) dest = state.pipes;

  	    // got a match.
  	    state.pipes = null;
  	    state.pipesCount = 0;
  	    state.flowing = false;
  	    if (dest) dest.emit('unpipe', this, unpipeInfo);
  	    return this;
  	  }

  	  // slow case. multiple pipe destinations.

  	  if (!dest) {
  	    // remove all.
  	    var dests = state.pipes;
  	    var len = state.pipesCount;
  	    state.pipes = null;
  	    state.pipesCount = 0;
  	    state.flowing = false;

  	    for (var i = 0; i < len; i++) {
  	      dests[i].emit('unpipe', this, unpipeInfo);
  	    }return this;
  	  }

  	  // try to find the right one.
  	  var index = indexOf(state.pipes, dest);
  	  if (index === -1) return this;

  	  state.pipes.splice(index, 1);
  	  state.pipesCount -= 1;
  	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  	  dest.emit('unpipe', this, unpipeInfo);

  	  return this;
  	};

  	// set up data events if they are asked for
  	// Ensure readable listeners eventually get something
  	Readable.prototype.on = function (ev, fn) {
  	  var res = Stream.prototype.on.call(this, ev, fn);

  	  if (ev === 'data') {
  	    // Start flowing on next tick if stream isn't explicitly paused
  	    if (this._readableState.flowing !== false) this.resume();
  	  } else if (ev === 'readable') {
  	    var state = this._readableState;
  	    if (!state.endEmitted && !state.readableListening) {
  	      state.readableListening = state.needReadable = true;
  	      state.emittedReadable = false;
  	      if (!state.reading) {
  	        processNextTick(nReadingNextTick, this);
  	      } else if (state.length) {
  	        emitReadable(this);
  	      }
  	    }
  	  }

  	  return res;
  	};
  	Readable.prototype.addListener = Readable.prototype.on;

  	function nReadingNextTick(self) {
  	  debug('readable nexttick read 0');
  	  self.read(0);
  	}

  	// pause() and resume() are remnants of the legacy readable stream API
  	// If the user uses them, then switch into old mode.
  	Readable.prototype.resume = function () {
  	  var state = this._readableState;
  	  if (!state.flowing) {
  	    debug('resume');
  	    state.flowing = true;
  	    resume(this, state);
  	  }
  	  return this;
  	};

  	function resume(stream, state) {
  	  if (!state.resumeScheduled) {
  	    state.resumeScheduled = true;
  	    processNextTick(resume_, stream, state);
  	  }
  	}

  	function resume_(stream, state) {
  	  if (!state.reading) {
  	    debug('resume read 0');
  	    stream.read(0);
  	  }

  	  state.resumeScheduled = false;
  	  state.awaitDrain = 0;
  	  stream.emit('resume');
  	  flow(stream);
  	  if (state.flowing && !state.reading) stream.read(0);
  	}

  	Readable.prototype.pause = function () {
  	  debug('call pause flowing=%j', this._readableState.flowing);
  	  if (false !== this._readableState.flowing) {
  	    debug('pause');
  	    this._readableState.flowing = false;
  	    this.emit('pause');
  	  }
  	  return this;
  	};

  	function flow(stream) {
  	  var state = stream._readableState;
  	  debug('flow', state.flowing);
  	  while (state.flowing && stream.read() !== null) {}
  	}

  	// wrap an old-style stream as the async data source.
  	// This is *not* part of the readable stream interface.
  	// It is an ugly unfortunate mess of history.
  	Readable.prototype.wrap = function (stream) {
  	  var state = this._readableState;
  	  var paused = false;

  	  var self = this;
  	  stream.on('end', function () {
  	    debug('wrapped end');
  	    if (state.decoder && !state.ended) {
  	      var chunk = state.decoder.end();
  	      if (chunk && chunk.length) self.push(chunk);
  	    }

  	    self.push(null);
  	  });

  	  stream.on('data', function (chunk) {
  	    debug('wrapped data');
  	    if (state.decoder) chunk = state.decoder.write(chunk);

  	    // don't skip over falsy values in objectMode
  	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

  	    var ret = self.push(chunk);
  	    if (!ret) {
  	      paused = true;
  	      stream.pause();
  	    }
  	  });

  	  // proxy all the other methods.
  	  // important when wrapping filters and duplexes.
  	  for (var i in stream) {
  	    if (this[i] === undefined && typeof stream[i] === 'function') {
  	      this[i] = function (method) {
  	        return function () {
  	          return stream[method].apply(stream, arguments);
  	        };
  	      }(i);
  	    }
  	  }

  	  // proxy certain important events.
  	  for (var n = 0; n < kProxyEvents.length; n++) {
  	    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  	  }

  	  // when we try to consume some more bytes, simply unpause the
  	  // underlying stream.
  	  self._read = function (n) {
  	    debug('wrapped _read', n);
  	    if (paused) {
  	      paused = false;
  	      stream.resume();
  	    }
  	  };

  	  return self;
  	};

  	// exposed for testing purposes only.
  	Readable._fromList = fromList;

  	// Pluck off n bytes from an array of buffers.
  	// Length is the combined lengths of all the buffers in the list.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function fromList(n, state) {
  	  // nothing buffered
  	  if (state.length === 0) return null;

  	  var ret;
  	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
  	    // read it all, truncate the list
  	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
  	    state.buffer.clear();
  	  } else {
  	    // read part of list
  	    ret = fromListPartial(n, state.buffer, state.decoder);
  	  }

  	  return ret;
  	}

  	// Extracts only enough buffered data to satisfy the amount requested.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function fromListPartial(n, list, hasStrings) {
  	  var ret;
  	  if (n < list.head.data.length) {
  	    // slice is the same for buffers and strings
  	    ret = list.head.data.slice(0, n);
  	    list.head.data = list.head.data.slice(n);
  	  } else if (n === list.head.data.length) {
  	    // first chunk is a perfect match
  	    ret = list.shift();
  	  } else {
  	    // result spans more than one buffer
  	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  	  }
  	  return ret;
  	}

  	// Copies a specified amount of characters from the list of buffered data
  	// chunks.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function copyFromBufferString(n, list) {
  	  var p = list.head;
  	  var c = 1;
  	  var ret = p.data;
  	  n -= ret.length;
  	  while (p = p.next) {
  	    var str = p.data;
  	    var nb = n > str.length ? str.length : n;
  	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
  	    n -= nb;
  	    if (n === 0) {
  	      if (nb === str.length) {
  	        ++c;
  	        if (p.next) list.head = p.next;else list.head = list.tail = null;
  	      } else {
  	        list.head = p;
  	        p.data = str.slice(nb);
  	      }
  	      break;
  	    }
  	    ++c;
  	  }
  	  list.length -= c;
  	  return ret;
  	}

  	// Copies a specified amount of bytes from the list of buffered data chunks.
  	// This function is designed to be inlinable, so please take care when making
  	// changes to the function body.
  	function copyFromBuffer(n, list) {
  	  var ret = Buffer.allocUnsafe(n);
  	  var p = list.head;
  	  var c = 1;
  	  p.data.copy(ret);
  	  n -= p.data.length;
  	  while (p = p.next) {
  	    var buf = p.data;
  	    var nb = n > buf.length ? buf.length : n;
  	    buf.copy(ret, ret.length - n, 0, nb);
  	    n -= nb;
  	    if (n === 0) {
  	      if (nb === buf.length) {
  	        ++c;
  	        if (p.next) list.head = p.next;else list.head = list.tail = null;
  	      } else {
  	        list.head = p;
  	        p.data = buf.slice(nb);
  	      }
  	      break;
  	    }
  	    ++c;
  	  }
  	  list.length -= c;
  	  return ret;
  	}

  	function endReadable(stream) {
  	  var state = stream._readableState;

  	  // If we get here before consuming all the bytes, then that is a
  	  // bug in node.  Should never happen.
  	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  	  if (!state.endEmitted) {
  	    state.ended = true;
  	    processNextTick(endReadableNT, state, stream);
  	  }
  	}

  	function endReadableNT(state, stream) {
  	  // Check that we didn't get one last unshift.
  	  if (!state.endEmitted && state.length === 0) {
  	    state.endEmitted = true;
  	    stream.readable = false;
  	    stream.emit('end');
  	  }
  	}

  	function indexOf(xs, x) {
  	  for (var i = 0, l = xs.length; i < l; i++) {
  	    if (xs[i] === x) return i;
  	  }
  	  return -1;
  	}
  	return _stream_readable;
  }

  var _stream_transform = Transform$1;

  var Duplex$1 = require_stream_duplex();

  /*<replacement>*/
  var util$1 = requireUtil();
  util$1.inherits = requireInherits_browser();
  /*</replacement>*/

  util$1.inherits(Transform$1, Duplex$1);

  function TransformState(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;

    var cb = ts.writecb;

    if (!cb) {
      return stream.emit('error', new Error('write callback called multiple times'));
    }

    ts.writechunk = null;
    ts.writecb = null;

    if (data !== null && data !== undefined) stream.push(data);

    cb(er);

    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }

  function Transform$1(options) {
    if (!(this instanceof Transform$1)) return new Transform$1(options);

    Duplex$1.call(this, options);

    this._transformState = new TransformState(this);

    var stream = this;

    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;

    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;

      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    // When the writable side finishes, then flush out anything remaining.
    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er, data) {
        done(stream, er, data);
      });else done(stream);
    });
  }

  Transform$1.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex$1.prototype.push.call(this, chunk, encoding);
  };

  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform$1.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('_transform() is not implemented');
  };

  Transform$1.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };

  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform$1.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  Transform$1.prototype._destroy = function (err, cb) {
    var _this = this;

    Duplex$1.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
      _this.emit('close');
    });
  };

  function done(stream, er, data) {
    if (er) return stream.emit('error', er);

    if (data !== null && data !== undefined) stream.push(data);

    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    var ws = stream._writableState;
    var ts = stream._transformState;

    if (ws.length) throw new Error('Calling transform done when ws.length != 0');

    if (ts.transforming) throw new Error('Calling transform done when still transforming');

    return stream.push(null);
  }

  var _stream_passthrough = PassThrough;

  var Transform = _stream_transform;

  /*<replacement>*/
  var util = requireUtil();
  util.inherits = requireInherits_browser();
  /*</replacement>*/

  util.inherits(PassThrough, Transform);

  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);

    Transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  (function (module, exports) {
  	exports = module.exports = require_stream_readable();
  	exports.Stream = exports;
  	exports.Readable = exports;
  	exports.Writable = require_stream_writable();
  	exports.Duplex = require_stream_duplex();
  	exports.Transform = _stream_transform;
  	exports.PassThrough = _stream_passthrough;
  } (readableBrowser, readableBrowser.exports));

  Object.defineProperty(BasePostMessageStream$1, "__esModule", { value: true });
  BasePostMessageStream$1.BasePostMessageStream = void 0;
  const readable_stream_1 = readableBrowser.exports;
  function noop$2() {
      return undefined;
  }
  const SYN = 'SYN';
  const ACK = 'ACK';
  /**
   * Abstract base class for postMessage streams.
   */
  class BasePostMessageStream extends readable_stream_1.Duplex {
      constructor() {
          super({
              objectMode: true,
          });
          // Initialization flags
          this._init = false;
          this._haveSyn = false;
      }
      /**
       * Must be called at end of child constructor to initiate
       * communication with other end.
       */
      _handshake() {
          // Send synchronization message
          this._write(SYN, null, noop$2);
          this.cork();
      }
      _onData(data) {
          if (this._init) {
              // Forward message
              try {
                  this.push(data);
              }
              catch (err) {
                  this.emit('error', err);
              }
          }
          else if (data === SYN) {
              // Listen for handshake
              this._haveSyn = true;
              this._write(ACK, null, noop$2);
          }
          else if (data === ACK) {
              this._init = true;
              if (!this._haveSyn) {
                  this._write(ACK, null, noop$2);
              }
              this.uncork();
          }
      }
      _read() {
          return undefined;
      }
      _write(data, _encoding, cb) {
          this._postMessage(data);
          cb();
      }
  }
  BasePostMessageStream$1.BasePostMessageStream = BasePostMessageStream;

  Object.defineProperty(WindowPostMessageStream$1, "__esModule", { value: true });
  WindowPostMessageStream$1.WindowPostMessageStream = void 0;
  const BasePostMessageStream_1$2 = BasePostMessageStream$1;
  /**
   * Window.postMessage stream.
   */
  class WindowPostMessageStream extends BasePostMessageStream_1$2.BasePostMessageStream {
      /**
       * Creates a stream for communicating with other streams across the same or
       * different window objects.
       *
       * @param args.name - The name of the stream. Used to differentiate between
       * multiple streams sharing the same window object.
       * @param args.target - The name of the stream to exchange messages with.
       * @param args.targetWindow - The window object of the target stream. Defaults
       * to `window`.
       */
      constructor({ name, target, targetWindow }) {
          if (!name || !target) {
              throw new Error('Invalid input.');
          }
          super();
          this._name = name;
          this._target = target;
          this._targetOrigin = targetWindow ? '*' : location.origin;
          this._targetWindow = targetWindow || window;
          this._onMessage = this._onMessage.bind(this);
          window.addEventListener('message', this._onMessage, false);
          this._handshake();
      }
      _postMessage(data) {
          this._targetWindow.postMessage({
              target: this._target,
              data,
          }, this._targetOrigin);
      }
      _onMessage(event) {
          const message = event.data;
          // validate message
          if ((this._targetOrigin !== '*' && event.origin !== this._targetOrigin) ||
              event.source !== this._targetWindow ||
              typeof message !== 'object' ||
              message.target !== this._name ||
              !message.data) {
              return;
          }
          this._onData(message.data);
      }
      _destroy() {
          window.removeEventListener('message', this._onMessage, false);
      }
  }
  WindowPostMessageStream$1.WindowPostMessageStream = WindowPostMessageStream;

  var WorkerPostMessageStream$1 = {};

  var enums = {};

  Object.defineProperty(enums, "__esModule", { value: true });
  enums.DEDICATED_WORKER_NAME = void 0;
  enums.DEDICATED_WORKER_NAME = 'dedicatedWorker';

  Object.defineProperty(WorkerPostMessageStream$1, "__esModule", { value: true });
  WorkerPostMessageStream$1.WorkerPostMessageStream = void 0;
  /* istanbul ignore file */
  // We ignore coverage for the entire file due to limits on our instrumentation,
  // but it is in fact covered by our tests.
  const BasePostMessageStream_1$1 = BasePostMessageStream$1;
  const enums_1$1 = enums;
  /**
   * Worker-side dedicated web worker `postMessage` stream.
   */
  class WorkerPostMessageStream extends BasePostMessageStream_1$1.BasePostMessageStream {
      /**
       * Note: Designed for use in web workers only.
       *
       * Creates a stream for communicating with the window that created this web
       * worker.
       */
      constructor() {
          super();
          this._name = enums_1$1.DEDICATED_WORKER_NAME;
          self.onmessage = this._onMessage.bind(this);
          this._handshake();
      }
      _postMessage(data) {
          // Cast of self.postMessage due to usage of DOM lib
          self.postMessage({ data });
      }
      _onMessage(event) {
          const message = event.data;
          // validate message
          if (typeof message !== 'object' ||
              message.target !== this._name ||
              !message.data) {
              return;
          }
          this._onData(message.data);
      }
      // worker stream lifecycle assumed to be coterminous with global scope
      _destroy() {
          return undefined;
      }
  }
  WorkerPostMessageStream$1.WorkerPostMessageStream = WorkerPostMessageStream;

  var WorkerParentPostMessageStream$1 = {};

  Object.defineProperty(WorkerParentPostMessageStream$1, "__esModule", { value: true });
  WorkerParentPostMessageStream$1.WorkerParentPostMessageStream = void 0;
  const BasePostMessageStream_1 = BasePostMessageStream$1;
  const enums_1 = enums;
  /**
   * Parent-side dedicated web worker `postMessage` stream.
   */
  class WorkerParentPostMessageStream extends BasePostMessageStream_1.BasePostMessageStream {
      /**
       * Creates a stream for communicating with a dedicated web worker.
       *
       * @param args.worker - The Web Worker to exchange messages with. The worker
       * must instantiate a WorkerPostMessageStream.
       */
      constructor({ worker }) {
          if (!worker) {
              throw new Error('Invalid input.');
          }
          super();
          this._target = enums_1.DEDICATED_WORKER_NAME;
          this._worker = worker;
          this._worker.onmessage = this._onMessage.bind(this);
          this._handshake();
      }
      _postMessage(data) {
          this._worker.postMessage({
              target: this._target,
              data,
          });
      }
      _onMessage(event) {
          const message = event.data;
          // validate message
          if (typeof message !== 'object' || !message.data) {
              return;
          }
          this._onData(message.data);
      }
      _destroy() {
          this._worker.onmessage = null;
          this._worker = null;
      }
  }
  WorkerParentPostMessageStream$1.WorkerParentPostMessageStream = WorkerParentPostMessageStream;

  (function (exports) {
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.WorkerParentPostMessageStream = exports.WorkerPostMessageStream = exports.WindowPostMessageStream = void 0;
  	var WindowPostMessageStream_1 = WindowPostMessageStream$1;
  	Object.defineProperty(exports, "WindowPostMessageStream", { enumerable: true, get: function () { return WindowPostMessageStream_1.WindowPostMessageStream; } });
  	var WorkerPostMessageStream_1 = WorkerPostMessageStream$1;
  	Object.defineProperty(exports, "WorkerPostMessageStream", { enumerable: true, get: function () { return WorkerPostMessageStream_1.WorkerPostMessageStream; } });
  	var WorkerParentPostMessageStream_1 = WorkerParentPostMessageStream$1;
  	Object.defineProperty(exports, "WorkerParentPostMessageStream", { enumerable: true, get: function () { return WorkerParentPostMessageStream_1.WorkerParentPostMessageStream; } });
  	
  } (dist));

  var ProviderConstants;
  (function (ProviderConstants) {
      ProviderConstants["INPAGE"] = "metamask-inpage";
      ProviderConstants["CONTENT_SCRIPT"] = "metamask-contentscript";
      ProviderConstants["PROVIDER"] = "metamask-provider";
  })(ProviderConstants || (ProviderConstants = {}));

  var es5 = {exports: {}};

  (function (module, exports) {
  	!function(e,t){module.exports=t();}(commonjsGlobal,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return "NT";case"XP":return "XP";case"NT 5.0":return "2000";case"NT 5.1":return "XP";case"NT 5.2":return "2003";case"NT 6.0":return "Vista";case"NT 6.1":return "7";case"NT 6.2":return "8";case"NT 6.3":return "8.1";case"NT 10.0":return "10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return "Leopard";case 6:return "Snow Leopard";case 7:return "Lion";case 8:return "Mountain Lion";case 9:return "Mavericks";case 10:return "Yosemite";case 11:return "El Capitan";case 12:return "Sierra";case 13:return "High Sierra";case 14:return "Mojave";case 15:return "Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),o=Math.max(i,s),a=0,u=e.map([t,r],(function(t){var r=o-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(n&&(a=o-Math.min(i,s)),o-=1;o>=a;){if(u[0][o]>u[1][o])return 1;if(u[0][o]===u[1][o]){if(o===a)return 0;o-=1;}else if(u[0][o]<u[1][o])return -1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),o=1;o<i;o++)s[o-1]=arguments[o];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var a=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t];}));};for(t=0,r=s.length;t<r;t+=1)a();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default;},18:function(e,t,r){t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};},90:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var a=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&o(t.prototype,r),n&&o(t,n),e}();t.default=a,e.exports=t.default;},91:function(e,t,r){t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),o=u(r(95)),a=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse();}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=a.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=a.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=a.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=a.default.find(o.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return a.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var o=e[t];"string"==typeof o?(i[t]=o,s+=1):"object"==typeof o&&(r[t]=o,n+=1);})),n>0){var o=Object.keys(r),u=a.default.find(o,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=a.default.find(o,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=a.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=a.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return ">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(a.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e){return this.isBrowser(e)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default;},92:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,o=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return {name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=o,e.exports=t.default;},93:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return {name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return {name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?) Version\//],describe:function(e){var t=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return {name:s.OS_MAP.iOS,version:t}}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return {name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return {name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return {name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return {name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return {name:s.OS_MAP.PlayStation4,version:t}}}];t.default=o,e.exports=t.default;},94:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:[/googlebot/i],describe:function(){return {type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?) Version\//],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return {type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "blackberry"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return "bada"===e.getBrowserName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "windows phone"===e.getBrowserName()},describe:function(){return {type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return "android"===e.getOSName(!0)&&t>=3},describe:function(){return {type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return "android"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return "macos"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return "windows"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "linux"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return "playstation 4"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}},{test:function(e){return "roku"===e.getOSName(!0)},describe:function(){return {type:s.PLATFORMS_MAP.tv}}}];t.default=o,e.exports=t.default;},95:function(e,t,r){t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var o=[{test:function(e){return "microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return {name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return {name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return {name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=o,e.exports=t.default;}})}));
  } (es5));

  var Bowser = /*@__PURE__*/getDefaultExportFromCjs(es5.exports);

  var isMetaMaskInstalled = function () {
      var _a, _b;
      return ((_a = window.ethereum) === null || _a === void 0 ? void 0 : _a.isMetaMask) && ((_b = window.ethereum) === null || _b === void 0 ? void 0 : _b.isConnected());
  };
  var isMobile$1 = function () {
      var _a, _b;
      var browser = Bowser.parse(window.navigator.userAgent);
      return (((_a = browser === null || browser === void 0 ? void 0 : browser.platform) === null || _a === void 0 ? void 0 : _a.type) === 'mobile' || ((_b = browser === null || browser === void 0 ? void 0 : browser.platform) === null || _b === void 0 ? void 0 : _b.type) === 'tablet');
  };
  var isMetaMaskMobileWebView = function () {
      return (Boolean(window.ReactNativeWebView) &&
          Boolean(navigator.userAgent.endsWith('MetaMaskMobile')));
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __awaiter$1(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator$1(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  var ONBOARDING_STATE = {
      INSTALLED: 'INSTALLED',
      NOT_INSTALLED: 'NOT_INSTALLED',
      REGISTERED: 'REGISTERED',
      REGISTERING: 'REGISTERING',
      RELOADING: 'RELOADING',
  };
  var EXTENSION_DOWNLOAD_URL = {
      CHROME: 'https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn',
      FIREFOX: 'https://addons.mozilla.org/firefox/addon/ether-metamask/',
      DEFAULT: 'https://metamask.io',
  };
  // sessionStorage key
  var REGISTRATION_IN_PROGRESS = 'REGISTRATION_IN_PROGRESS';
  // forwarder iframe id
  var FORWARDER_ID = 'FORWARDER_ID';
  var Onboarding = /** @class */ (function () {
      function Onboarding(_a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.forwarderOrigin, forwarderOrigin = _c === void 0 ? 'https://fwd.metamask.io' : _c, _d = _b.forwarderMode, forwarderMode = _d === void 0 ? Onboarding.FORWARDER_MODE.INJECT : _d;
          this.forwarderOrigin = forwarderOrigin;
          this.forwarderMode = forwarderMode;
          this.state = Onboarding.isMetaMaskInstalled()
              ? ONBOARDING_STATE.INSTALLED
              : ONBOARDING_STATE.NOT_INSTALLED;
          var browser = Onboarding._detectBrowser();
          if (browser) {
              this.downloadUrl = EXTENSION_DOWNLOAD_URL[browser];
          }
          else {
              this.downloadUrl = EXTENSION_DOWNLOAD_URL.DEFAULT;
          }
          this._onMessage = this._onMessage.bind(this);
          this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this);
          this._openForwarder = this._openForwarder.bind(this);
          this._openDownloadPage = this._openDownloadPage.bind(this);
          this.startOnboarding = this.startOnboarding.bind(this);
          this.stopOnboarding = this.stopOnboarding.bind(this);
          window.addEventListener('message', this._onMessage);
          if (forwarderMode === Onboarding.FORWARDER_MODE.INJECT &&
              sessionStorage.getItem(REGISTRATION_IN_PROGRESS) === 'true') {
              Onboarding._injectForwarder(this.forwarderOrigin);
          }
      }
      Onboarding.prototype._onMessage = function (event) {
          if (event.origin !== this.forwarderOrigin) {
              // Ignoring non-forwarder message
              return undefined;
          }
          if (event.data.type === 'metamask:reload') {
              return this._onMessageFromForwarder(event);
          }
          console.debug("Unknown message from '" + event.origin + "' with data " + JSON.stringify(event.data));
          return undefined;
      };
      Onboarding.prototype._onMessageUnknownStateError = function (state) {
          throw new Error("Unknown state: '" + state + "'");
      };
      Onboarding.prototype._onMessageFromForwarder = function (event) {
          return __awaiter$1(this, void 0, void 0, function () {
              var _a;
              return __generator$1(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          _a = this.state;
                          switch (_a) {
                              case ONBOARDING_STATE.RELOADING: return [3 /*break*/, 1];
                              case ONBOARDING_STATE.NOT_INSTALLED: return [3 /*break*/, 2];
                              case ONBOARDING_STATE.INSTALLED: return [3 /*break*/, 3];
                              case ONBOARDING_STATE.REGISTERING: return [3 /*break*/, 5];
                              case ONBOARDING_STATE.REGISTERED: return [3 /*break*/, 6];
                          }
                          return [3 /*break*/, 7];
                      case 1:
                          console.debug('Ignoring message while reloading');
                          return [3 /*break*/, 8];
                      case 2:
                          console.debug('Reloading now to register with MetaMask');
                          this.state = ONBOARDING_STATE.RELOADING;
                          location.reload();
                          return [3 /*break*/, 8];
                      case 3:
                          console.debug('Registering with MetaMask');
                          this.state = ONBOARDING_STATE.REGISTERING;
                          return [4 /*yield*/, Onboarding._register()];
                      case 4:
                          _b.sent();
                          this.state = ONBOARDING_STATE.REGISTERED;
                          event.source.postMessage({ type: 'metamask:registrationCompleted' }, event.origin);
                          this.stopOnboarding();
                          return [3 /*break*/, 8];
                      case 5:
                          console.debug('Already registering - ignoring reload message');
                          return [3 /*break*/, 8];
                      case 6:
                          console.debug('Already registered - ignoring reload message');
                          return [3 /*break*/, 8];
                      case 7:
                          this._onMessageUnknownStateError(this.state);
                          _b.label = 8;
                      case 8: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Starts onboarding by opening the MetaMask download page and the Onboarding forwarder
       */
      Onboarding.prototype.startOnboarding = function () {
          sessionStorage.setItem(REGISTRATION_IN_PROGRESS, 'true');
          this._openDownloadPage();
          this._openForwarder();
      };
      /**
       * Stops onboarding registration, including removing the injected forwarder (if any)
       *
       * Typically this function is not necessary, but it can be useful for cases where
       * onboarding completes before the forwarder has registered.
       */
      Onboarding.prototype.stopOnboarding = function () {
          if (sessionStorage.getItem(REGISTRATION_IN_PROGRESS) === 'true') {
              if (this.forwarderMode === Onboarding.FORWARDER_MODE.INJECT) {
                  console.debug('Removing forwarder');
                  Onboarding._removeForwarder();
              }
              sessionStorage.setItem(REGISTRATION_IN_PROGRESS, 'false');
          }
      };
      Onboarding.prototype._openForwarder = function () {
          if (this.forwarderMode === Onboarding.FORWARDER_MODE.OPEN_TAB) {
             
              window.open(this.forwarderOrigin, '_blank');
          }
          else {
              Onboarding._injectForwarder(this.forwarderOrigin);
          }
      };
      Onboarding.prototype._openDownloadPage = function () {
          window.open(this.downloadUrl, '_blank');
      };
      /**
       * Checks whether the MetaMask extension is installed
       */
      Onboarding.isMetaMaskInstalled = function () {
          return Boolean(window.ethereum && window.ethereum.isMetaMask);
      };
      Onboarding._register = function () {
          return window.ethereum.request({
              method: 'wallet_registerOnboarding',
          });
      };
      Onboarding._injectForwarder = function (forwarderOrigin) {
          var container = document.body;
          var iframe = document.createElement('iframe');
          iframe.setAttribute('height', '0');
          iframe.setAttribute('width', '0');
          iframe.setAttribute('style', 'display: none;');
          iframe.setAttribute('src', forwarderOrigin);
          iframe.setAttribute('id', FORWARDER_ID);
          container.insertBefore(iframe, container.children[0]);
      };
      Onboarding._removeForwarder = function () {
          var _a;
          (_a = document.getElementById(FORWARDER_ID)) === null || _a === void 0 ? void 0 : _a.remove();
      };
      Onboarding._detectBrowser = function () {
          var browserInfo = Bowser.parse(window.navigator.userAgent);
          if (browserInfo.browser.name === 'Firefox') {
              return 'FIREFOX';
          }
          else if (['Chrome', 'Chromium'].includes(browserInfo.browser.name || '')) {
              return 'CHROME';
          }
          return null;
      };
      Onboarding.FORWARDER_MODE = {
          INJECT: 'INJECT',
          OPEN_TAB: 'OPEN_TAB',
      };
      return Onboarding;
  }());

  var cjs$3 = {};

  var cjs$2 = {};

  Object.defineProperty(cjs$2, "__esModule", { value: true });
  var getLocalStorage_1 = cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = getLocation_1 = cjs$2.getLocation = cjs$2.getLocationOrThrow = getNavigator_1 = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
  function getFromWindow(name) {
      let res = undefined;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
          res = window[name];
      }
      return res;
  }
  cjs$2.getFromWindow = getFromWindow;
  function getFromWindowOrThrow(name) {
      const res = getFromWindow(name);
      if (!res) {
          throw new Error(`${name} is not defined in Window`);
      }
      return res;
  }
  cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
  function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
  }
  cjs$2.getDocumentOrThrow = getDocumentOrThrow;
  function getDocument() {
      return getFromWindow("document");
  }
  cjs$2.getDocument = getDocument;
  function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
  }
  cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
  function getNavigator$1() {
      return getFromWindow("navigator");
  }
  var getNavigator_1 = cjs$2.getNavigator = getNavigator$1;
  function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
  }
  cjs$2.getLocationOrThrow = getLocationOrThrow;
  function getLocation$1() {
      return getFromWindow("location");
  }
  var getLocation_1 = cjs$2.getLocation = getLocation$1;
  function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
  }
  cjs$2.getCryptoOrThrow = getCryptoOrThrow;
  function getCrypto() {
      return getFromWindow("crypto");
  }
  cjs$2.getCrypto = getCrypto;
  function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
  }
  cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
  function getLocalStorage$1() {
      return getFromWindow("localStorage");
  }
  getLocalStorage_1 = cjs$2.getLocalStorage = getLocalStorage$1;

  Object.defineProperty(cjs$3, "__esModule", { value: true });
  var getWindowMetadata_1 = cjs$3.getWindowMetadata = void 0;
  const window_getters_1 = cjs$2;
  function getWindowMetadata() {
      let doc;
      let loc;
      try {
          doc = window_getters_1.getDocumentOrThrow();
          loc = window_getters_1.getLocationOrThrow();
      }
      catch (e) {
          return null;
      }
      function getIcons() {
          const links = doc.getElementsByTagName("link");
          const icons = [];
          for (let i = 0; i < links.length; i++) {
              const link = links[i];
              const rel = link.getAttribute("rel");
              if (rel) {
                  if (rel.toLowerCase().indexOf("icon") > -1) {
                      const href = link.getAttribute("href");
                      if (href) {
                          if (href.toLowerCase().indexOf("https:") === -1 &&
                              href.toLowerCase().indexOf("http:") === -1 &&
                              href.indexOf("//") !== 0) {
                              let absoluteHref = loc.protocol + "//" + loc.host;
                              if (href.indexOf("/") === 0) {
                                  absoluteHref += href;
                              }
                              else {
                                  const path = loc.pathname.split("/");
                                  path.pop();
                                  const finalPath = path.join("/");
                                  absoluteHref += finalPath + "/" + href;
                              }
                              icons.push(absoluteHref);
                          }
                          else if (href.indexOf("//") === 0) {
                              const absoluteUrl = loc.protocol + href;
                              icons.push(absoluteUrl);
                          }
                          else {
                              icons.push(href);
                          }
                      }
                  }
              }
          }
          return icons;
      }
      function getWindowMetadataOfAny(...args) {
          const metaTags = doc.getElementsByTagName("meta");
          for (let i = 0; i < metaTags.length; i++) {
              const tag = metaTags[i];
              const attributes = ["itemprop", "property", "name"]
                  .map((target) => tag.getAttribute(target))
                  .filter((attr) => {
                  if (attr) {
                      return args.includes(attr);
                  }
                  return false;
              });
              if (attributes.length && attributes) {
                  const content = tag.getAttribute("content");
                  if (content) {
                      return content;
                  }
              }
          }
          return "";
      }
      function getName() {
          let name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
          if (!name) {
              name = doc.title;
          }
          return name;
      }
      function getDescription() {
          const description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
          return description;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
          description,
          url,
          icons,
          name,
      };
      return meta;
  }
  getWindowMetadata_1 = cjs$3.getWindowMetadata = getWindowMetadata;

  var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  };
  var BrowserInfo = /** @class */ (function () {
      function BrowserInfo(name, version, os) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.type = 'browser';
      }
      return BrowserInfo;
  }());
  var NodeInfo = /** @class */ (function () {
      function NodeInfo(version) {
          this.version = version;
          this.type = 'node';
          this.name = 'node';
          this.os = browser$1$1.platform;
      }
      return NodeInfo;
  }());
  var SearchBotDeviceInfo = /** @class */ (function () {
      function SearchBotDeviceInfo(name, version, os, bot) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.bot = bot;
          this.type = 'bot-device';
      }
      return SearchBotDeviceInfo;
  }());
  var BotInfo = /** @class */ (function () {
      function BotInfo() {
          this.type = 'bot';
          this.bot = true; // NOTE: deprecated test name instead
          this.name = 'bot';
          this.version = null;
          this.os = null;
      }
      return BotInfo;
  }());
  var ReactNativeInfo = /** @class */ (function () {
      function ReactNativeInfo() {
          this.type = 'react-native';
          this.name = 'react-native';
          this.version = null;
          this.os = null;
      }
      return ReactNativeInfo;
  }());
  // tslint:disable-next-line:max-line-length
  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [
      ['aol', /AOLShield\/([0-9\._]+)/],
      ['edge', /Edge\/([0-9\._]+)/],
      ['edge-ios', /EdgiOS\/([0-9\._]+)/],
      ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
      ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
      ['samsung', /SamsungBrowser\/([0-9\.]+)/],
      ['silk', /\bSilk\/([0-9._-]+)\b/],
      ['miui', /MiuiBrowser\/([0-9\.]+)$/],
      ['beaker', /BeakerBrowser\/([0-9\.]+)/],
      ['edge-chromium', /EdgA?\/([0-9\.]+)/],
      [
          'chromium-webview',
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
      ],
      ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
      ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
      ['fxios', /FxiOS\/([0-9\.]+)/],
      ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
      ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
      ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
      ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ['ie', /MSIE\s(7\.0)/],
      ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ['android', /Android\s([0-9\.]+)/],
      ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ['safari', /Version\/([0-9\._]+).*Safari/],
      ['facebook', /FBAV\/([0-9\.]+)/],
      ['instagram', /Instagram\s([0-9\.]+)/],
      ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
      ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ['searchbot', SEARCHBOX_UA_REGEX],
  ];
  var operatingSystemRules = [
      ['iOS', /iP(hone|od|ad)/],
      ['Android OS', /Android/],
      ['BlackBerry OS', /BlackBerry|BB10/],
      ['Windows Mobile', /IEMobile/],
      ['Amazon OS', /Kindle/],
      ['Windows 3.11', /Win16/],
      ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
      ['Windows 98', /(Windows 98)|(Win98)/],
      ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
      ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
      ['Windows Server 2003', /(Windows NT 5.2)/],
      ['Windows Vista', /(Windows NT 6.0)/],
      ['Windows 7', /(Windows NT 6.1)/],
      ['Windows 8', /(Windows NT 6.2)/],
      ['Windows 8.1', /(Windows NT 6.3)/],
      ['Windows 10', /(Windows NT 10.0)/],
      ['Windows ME', /Windows ME/],
      ['Open BSD', /OpenBSD/],
      ['Sun OS', /SunOS/],
      ['Chrome OS', /CrOS/],
      ['Linux', /(Linux)|(X11)/],
      ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
      ['QNX', /QNX/],
      ['BeOS', /BeOS/],
      ['OS/2', /OS\/2/],
  ];
  function detect(userAgent) {
      if (!!userAgent) {
          return parseUserAgent(userAgent);
      }
      if (typeof document === 'undefined' &&
          typeof navigator !== 'undefined' &&
          navigator.product === 'ReactNative') {
          return new ReactNativeInfo();
      }
      if (typeof navigator !== 'undefined') {
          return parseUserAgent(navigator.userAgent);
      }
      return getNodeVersion();
  }
  function matchUserAgent(ua) {
      // opted for using reduce here rather than Array#first with a regex.test call
      // this is primarily because using the reduce we only perform the regex
      // execution once rather than once for the test and for the exec again below
      // probably something that needs to be benchmarked though
      return (ua !== '' &&
          userAgentRules.reduce(function (matched, _a) {
              var browser = _a[0], regex = _a[1];
              if (matched) {
                  return matched;
              }
              var uaMatch = regex.exec(ua);
              return !!uaMatch && [browser, uaMatch];
          }, false));
  }
  function parseUserAgent(ua) {
      var matchedRule = matchUserAgent(ua);
      if (!matchedRule) {
          return null;
      }
      var name = matchedRule[0], match = matchedRule[1];
      if (name === 'searchbot') {
          return new BotInfo();
      }
      var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
      if (versionParts) {
          if (versionParts.length < REQUIRED_VERSION_PARTS) {
              versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
          }
      }
      else {
          versionParts = [];
      }
      var version = versionParts.join('.');
      var os = detectOS$1(ua);
      var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
      if (searchBotMatch && searchBotMatch[1]) {
          return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
      }
      return new BrowserInfo(name, version, os);
  }
  function detectOS$1(ua) {
      for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
          var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
          var match = regex.exec(ua);
          if (match) {
              return os;
          }
      }
      return null;
  }
  function getNodeVersion() {
      var isNode = typeof browser$1$1 !== 'undefined' && browser$1$1.version;
      return isNode ? new NodeInfo(browser$1$1.version.slice(1)) : null;
  }
  function createVersionParts(count) {
      var output = [];
      for (var ii = 0; ii < count; ii++) {
          output.push('0');
      }
      return output;
  }

  function detectEnv(userAgent) {
      return detect(userAgent);
  }
  function detectOS() {
      const env = detectEnv();
      return env && env.os ? env.os : undefined;
  }
  function isAndroid() {
      const os = detectOS();
      return os ? os.toLowerCase().includes("android") : false;
  }
  function isIOS() {
      const os = detectOS();
      return os
          ? os.toLowerCase().includes("ios") ||
              (os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
          : false;
  }
  function isMobile() {
      const os = detectOS();
      return os ? isAndroid() || isIOS() : false;
  }
  function isNode$1() {
      const env = detectEnv();
      const result = env && env.name ? env.name.toLowerCase() === "node" : false;
      return result;
  }
  function isBrowser$1() {
      const result = !isNode$1() && !!getNavigator();
      return result;
  }
  const getNavigator = getNavigator_1;
  const getLocation = getLocation_1;
  const getLocalStorage = getLocalStorage_1;
  function getClientMeta() {
      return getWindowMetadata_1();
  }

  function safeJsonParse$1(value) {
      if (typeof value !== "string") {
          throw new Error(`Cannot safe json parse value of type ${typeof value}`);
      }
      try {
          return JSON.parse(value);
      }
      catch (_a) {
          return value;
      }
  }
  function safeJsonStringify$1(value) {
      return typeof value === "string" ? value : JSON.stringify(value);
  }

  const safeJsonParse = safeJsonParse$1;
  const safeJsonStringify = safeJsonStringify$1;

  function setLocal(key, data) {
      const raw = safeJsonStringify(data);
      const local = getLocalStorage();
      if (local) {
          local.setItem(key, raw);
      }
  }
  function getLocal(key) {
      let data = null;
      let raw = null;
      const local = getLocalStorage();
      if (local) {
          raw = local.getItem(key);
      }
      data = raw ? safeJsonParse(raw) : raw;
      return data;
  }
  function removeLocal(key) {
      const local = getLocalStorage();
      if (local) {
          local.removeItem(key);
      }
  }

  const mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";

  const reservedEvents = [
      "session_request",
      "session_update",
      "exchange_key",
      "connect",
      "disconnect",
      "display_uri",
      "modal_closed",
      "transport_open",
      "transport_close",
      "transport_error",
  ];
  const signingMethods = [
      "eth_sendTransaction",
      "eth_signTransaction",
      "eth_sign",
      "eth_signTypedData",
      "eth_signTypedData_v1",
      "eth_signTypedData_v2",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "personal_sign",
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode",
  ];

  var bn = {exports: {}};

  (function (module) {
  	(function (module, exports) {

  	  // Utils
  	  function assert (val, msg) {
  	    if (!val) throw new Error(msg || 'Assertion failed');
  	  }

  	  // Could use `inherits` module, but don't want to move from single file
  	  // architecture yet.
  	  function inherits (ctor, superCtor) {
  	    ctor.super_ = superCtor;
  	    var TempCtor = function () {};
  	    TempCtor.prototype = superCtor.prototype;
  	    ctor.prototype = new TempCtor();
  	    ctor.prototype.constructor = ctor;
  	  }

  	  // BN

  	  function BN (number, base, endian) {
  	    if (BN.isBN(number)) {
  	      return number;
  	    }

  	    this.negative = 0;
  	    this.words = null;
  	    this.length = 0;

  	    // Reduction context
  	    this.red = null;

  	    if (number !== null) {
  	      if (base === 'le' || base === 'be') {
  	        endian = base;
  	        base = 10;
  	      }

  	      this._init(number || 0, base || 10, endian || 'be');
  	    }
  	  }
  	  if (typeof module === 'object') {
  	    module.exports = BN;
  	  } else {
  	    exports.BN = BN;
  	  }

  	  BN.BN = BN;
  	  BN.wordSize = 26;

  	  var Buffer;
  	  try {
  	    Buffer = require$$0$1.Buffer;
  	  } catch (e) {
  	  }

  	  BN.isBN = function isBN (num) {
  	    if (num instanceof BN) {
  	      return true;
  	    }

  	    return num !== null && typeof num === 'object' &&
  	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  	  };

  	  BN.max = function max (left, right) {
  	    if (left.cmp(right) > 0) return left;
  	    return right;
  	  };

  	  BN.min = function min (left, right) {
  	    if (left.cmp(right) < 0) return left;
  	    return right;
  	  };

  	  BN.prototype._init = function init (number, base, endian) {
  	    if (typeof number === 'number') {
  	      return this._initNumber(number, base, endian);
  	    }

  	    if (typeof number === 'object') {
  	      return this._initArray(number, base, endian);
  	    }

  	    if (base === 'hex') {
  	      base = 16;
  	    }
  	    assert(base === (base | 0) && base >= 2 && base <= 36);

  	    number = number.toString().replace(/\s+/g, '');
  	    var start = 0;
  	    if (number[0] === '-') {
  	      start++;
  	    }

  	    if (base === 16) {
  	      this._parseHex(number, start);
  	    } else {
  	      this._parseBase(number, base, start);
  	    }

  	    if (number[0] === '-') {
  	      this.negative = 1;
  	    }

  	    this.strip();

  	    if (endian !== 'le') return;

  	    this._initArray(this.toArray(), base, endian);
  	  };

  	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
  	    if (number < 0) {
  	      this.negative = 1;
  	      number = -number;
  	    }
  	    if (number < 0x4000000) {
  	      this.words = [ number & 0x3ffffff ];
  	      this.length = 1;
  	    } else if (number < 0x10000000000000) {
  	      this.words = [
  	        number & 0x3ffffff,
  	        (number / 0x4000000) & 0x3ffffff
  	      ];
  	      this.length = 2;
  	    } else {
  	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
  	      this.words = [
  	        number & 0x3ffffff,
  	        (number / 0x4000000) & 0x3ffffff,
  	        1
  	      ];
  	      this.length = 3;
  	    }

  	    if (endian !== 'le') return;

  	    // Reverse the bytes
  	    this._initArray(this.toArray(), base, endian);
  	  };

  	  BN.prototype._initArray = function _initArray (number, base, endian) {
  	    // Perhaps a Uint8Array
  	    assert(typeof number.length === 'number');
  	    if (number.length <= 0) {
  	      this.words = [ 0 ];
  	      this.length = 1;
  	      return this;
  	    }

  	    this.length = Math.ceil(number.length / 3);
  	    this.words = new Array(this.length);
  	    for (var i = 0; i < this.length; i++) {
  	      this.words[i] = 0;
  	    }

  	    var j, w;
  	    var off = 0;
  	    if (endian === 'be') {
  	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
  	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
  	        this.words[j] |= (w << off) & 0x3ffffff;
  	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
  	        off += 24;
  	        if (off >= 26) {
  	          off -= 26;
  	          j++;
  	        }
  	      }
  	    } else if (endian === 'le') {
  	      for (i = 0, j = 0; i < number.length; i += 3) {
  	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
  	        this.words[j] |= (w << off) & 0x3ffffff;
  	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
  	        off += 24;
  	        if (off >= 26) {
  	          off -= 26;
  	          j++;
  	        }
  	      }
  	    }
  	    return this.strip();
  	  };

  	  function parseHex (str, start, end) {
  	    var r = 0;
  	    var len = Math.min(str.length, end);
  	    for (var i = start; i < len; i++) {
  	      var c = str.charCodeAt(i) - 48;

  	      r <<= 4;

  	      // 'a' - 'f'
  	      if (c >= 49 && c <= 54) {
  	        r |= c - 49 + 0xa;

  	      // 'A' - 'F'
  	      } else if (c >= 17 && c <= 22) {
  	        r |= c - 17 + 0xa;

  	      // '0' - '9'
  	      } else {
  	        r |= c & 0xf;
  	      }
  	    }
  	    return r;
  	  }

  	  BN.prototype._parseHex = function _parseHex (number, start) {
  	    // Create possibly bigger array to ensure that it fits the number
  	    this.length = Math.ceil((number.length - start) / 6);
  	    this.words = new Array(this.length);
  	    for (var i = 0; i < this.length; i++) {
  	      this.words[i] = 0;
  	    }

  	    var j, w;
  	    // Scan 24-bit chunks and add them to the number
  	    var off = 0;
  	    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
  	      w = parseHex(number, i, i + 6);
  	      this.words[j] |= (w << off) & 0x3ffffff;
  	      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
  	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  	      off += 24;
  	      if (off >= 26) {
  	        off -= 26;
  	        j++;
  	      }
  	    }
  	    if (i + 6 !== start) {
  	      w = parseHex(number, start, i + 6);
  	      this.words[j] |= (w << off) & 0x3ffffff;
  	      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  	    }
  	    this.strip();
  	  };

  	  function parseBase (str, start, end, mul) {
  	    var r = 0;
  	    var len = Math.min(str.length, end);
  	    for (var i = start; i < len; i++) {
  	      var c = str.charCodeAt(i) - 48;

  	      r *= mul;

  	      // 'a'
  	      if (c >= 49) {
  	        r += c - 49 + 0xa;

  	      // 'A'
  	      } else if (c >= 17) {
  	        r += c - 17 + 0xa;

  	      // '0' - '9'
  	      } else {
  	        r += c;
  	      }
  	    }
  	    return r;
  	  }

  	  BN.prototype._parseBase = function _parseBase (number, base, start) {
  	    // Initialize as zero
  	    this.words = [ 0 ];
  	    this.length = 1;

  	    // Find length of limb in base
  	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
  	      limbLen++;
  	    }
  	    limbLen--;
  	    limbPow = (limbPow / base) | 0;

  	    var total = number.length - start;
  	    var mod = total % limbLen;
  	    var end = Math.min(total, total - mod) + start;

  	    var word = 0;
  	    for (var i = start; i < end; i += limbLen) {
  	      word = parseBase(number, i, i + limbLen, base);

  	      this.imuln(limbPow);
  	      if (this.words[0] + word < 0x4000000) {
  	        this.words[0] += word;
  	      } else {
  	        this._iaddn(word);
  	      }
  	    }

  	    if (mod !== 0) {
  	      var pow = 1;
  	      word = parseBase(number, i, number.length, base);

  	      for (i = 0; i < mod; i++) {
  	        pow *= base;
  	      }

  	      this.imuln(pow);
  	      if (this.words[0] + word < 0x4000000) {
  	        this.words[0] += word;
  	      } else {
  	        this._iaddn(word);
  	      }
  	    }
  	  };

  	  BN.prototype.copy = function copy (dest) {
  	    dest.words = new Array(this.length);
  	    for (var i = 0; i < this.length; i++) {
  	      dest.words[i] = this.words[i];
  	    }
  	    dest.length = this.length;
  	    dest.negative = this.negative;
  	    dest.red = this.red;
  	  };

  	  BN.prototype.clone = function clone () {
  	    var r = new BN(null);
  	    this.copy(r);
  	    return r;
  	  };

  	  BN.prototype._expand = function _expand (size) {
  	    while (this.length < size) {
  	      this.words[this.length++] = 0;
  	    }
  	    return this;
  	  };

  	  // Remove leading `0` from `this`
  	  BN.prototype.strip = function strip () {
  	    while (this.length > 1 && this.words[this.length - 1] === 0) {
  	      this.length--;
  	    }
  	    return this._normSign();
  	  };

  	  BN.prototype._normSign = function _normSign () {
  	    // -0 = 0
  	    if (this.length === 1 && this.words[0] === 0) {
  	      this.negative = 0;
  	    }
  	    return this;
  	  };

  	  BN.prototype.inspect = function inspect () {
  	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  	  };

  	  /*

  	  var zeros = [];
  	  var groupSizes = [];
  	  var groupBases = [];

  	  var s = '';
  	  var i = -1;
  	  while (++i < BN.wordSize) {
  	    zeros[i] = s;
  	    s += '0';
  	  }
  	  groupSizes[0] = 0;
  	  groupSizes[1] = 0;
  	  groupBases[0] = 0;
  	  groupBases[1] = 0;
  	  var base = 2 - 1;
  	  while (++base < 36 + 1) {
  	    var groupSize = 0;
  	    var groupBase = 1;
  	    while (groupBase < (1 << BN.wordSize) / base) {
  	      groupBase *= base;
  	      groupSize += 1;
  	    }
  	    groupSizes[base] = groupSize;
  	    groupBases[base] = groupBase;
  	  }

  	  */

  	  var zeros = [
  	    '',
  	    '0',
  	    '00',
  	    '000',
  	    '0000',
  	    '00000',
  	    '000000',
  	    '0000000',
  	    '00000000',
  	    '000000000',
  	    '0000000000',
  	    '00000000000',
  	    '000000000000',
  	    '0000000000000',
  	    '00000000000000',
  	    '000000000000000',
  	    '0000000000000000',
  	    '00000000000000000',
  	    '000000000000000000',
  	    '0000000000000000000',
  	    '00000000000000000000',
  	    '000000000000000000000',
  	    '0000000000000000000000',
  	    '00000000000000000000000',
  	    '000000000000000000000000',
  	    '0000000000000000000000000'
  	  ];

  	  var groupSizes = [
  	    0, 0,
  	    25, 16, 12, 11, 10, 9, 8,
  	    8, 7, 7, 7, 7, 6, 6,
  	    6, 6, 6, 6, 6, 5, 5,
  	    5, 5, 5, 5, 5, 5, 5,
  	    5, 5, 5, 5, 5, 5, 5
  	  ];

  	  var groupBases = [
  	    0, 0,
  	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  	  ];

  	  BN.prototype.toString = function toString (base, padding) {
  	    base = base || 10;
  	    padding = padding | 0 || 1;

  	    var out;
  	    if (base === 16 || base === 'hex') {
  	      out = '';
  	      var off = 0;
  	      var carry = 0;
  	      for (var i = 0; i < this.length; i++) {
  	        var w = this.words[i];
  	        var word = (((w << off) | carry) & 0xffffff).toString(16);
  	        carry = (w >>> (24 - off)) & 0xffffff;
  	        if (carry !== 0 || i !== this.length - 1) {
  	          out = zeros[6 - word.length] + word + out;
  	        } else {
  	          out = word + out;
  	        }
  	        off += 2;
  	        if (off >= 26) {
  	          off -= 26;
  	          i--;
  	        }
  	      }
  	      if (carry !== 0) {
  	        out = carry.toString(16) + out;
  	      }
  	      while (out.length % padding !== 0) {
  	        out = '0' + out;
  	      }
  	      if (this.negative !== 0) {
  	        out = '-' + out;
  	      }
  	      return out;
  	    }

  	    if (base === (base | 0) && base >= 2 && base <= 36) {
  	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
  	      var groupSize = groupSizes[base];
  	      // var groupBase = Math.pow(base, groupSize);
  	      var groupBase = groupBases[base];
  	      out = '';
  	      var c = this.clone();
  	      c.negative = 0;
  	      while (!c.isZero()) {
  	        var r = c.modn(groupBase).toString(base);
  	        c = c.idivn(groupBase);

  	        if (!c.isZero()) {
  	          out = zeros[groupSize - r.length] + r + out;
  	        } else {
  	          out = r + out;
  	        }
  	      }
  	      if (this.isZero()) {
  	        out = '0' + out;
  	      }
  	      while (out.length % padding !== 0) {
  	        out = '0' + out;
  	      }
  	      if (this.negative !== 0) {
  	        out = '-' + out;
  	      }
  	      return out;
  	    }

  	    assert(false, 'Base should be between 2 and 36');
  	  };

  	  BN.prototype.toNumber = function toNumber () {
  	    var ret = this.words[0];
  	    if (this.length === 2) {
  	      ret += this.words[1] * 0x4000000;
  	    } else if (this.length === 3 && this.words[2] === 0x01) {
  	      // NOTE: at this stage it is known that the top bit is set
  	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
  	    } else if (this.length > 2) {
  	      assert(false, 'Number can only safely store up to 53 bits');
  	    }
  	    return (this.negative !== 0) ? -ret : ret;
  	  };

  	  BN.prototype.toJSON = function toJSON () {
  	    return this.toString(16);
  	  };

  	  BN.prototype.toBuffer = function toBuffer (endian, length) {
  	    assert(typeof Buffer !== 'undefined');
  	    return this.toArrayLike(Buffer, endian, length);
  	  };

  	  BN.prototype.toArray = function toArray (endian, length) {
  	    return this.toArrayLike(Array, endian, length);
  	  };

  	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
  	    var byteLength = this.byteLength();
  	    var reqLength = length || Math.max(1, byteLength);
  	    assert(byteLength <= reqLength, 'byte array longer than desired length');
  	    assert(reqLength > 0, 'Requested array length <= 0');

  	    this.strip();
  	    var littleEndian = endian === 'le';
  	    var res = new ArrayType(reqLength);

  	    var b, i;
  	    var q = this.clone();
  	    if (!littleEndian) {
  	      // Assume big-endian
  	      for (i = 0; i < reqLength - byteLength; i++) {
  	        res[i] = 0;
  	      }

  	      for (i = 0; !q.isZero(); i++) {
  	        b = q.andln(0xff);
  	        q.iushrn(8);

  	        res[reqLength - i - 1] = b;
  	      }
  	    } else {
  	      for (i = 0; !q.isZero(); i++) {
  	        b = q.andln(0xff);
  	        q.iushrn(8);

  	        res[i] = b;
  	      }

  	      for (; i < reqLength; i++) {
  	        res[i] = 0;
  	      }
  	    }

  	    return res;
  	  };

  	  if (Math.clz32) {
  	    BN.prototype._countBits = function _countBits (w) {
  	      return 32 - Math.clz32(w);
  	    };
  	  } else {
  	    BN.prototype._countBits = function _countBits (w) {
  	      var t = w;
  	      var r = 0;
  	      if (t >= 0x1000) {
  	        r += 13;
  	        t >>>= 13;
  	      }
  	      if (t >= 0x40) {
  	        r += 7;
  	        t >>>= 7;
  	      }
  	      if (t >= 0x8) {
  	        r += 4;
  	        t >>>= 4;
  	      }
  	      if (t >= 0x02) {
  	        r += 2;
  	        t >>>= 2;
  	      }
  	      return r + t;
  	    };
  	  }

  	  BN.prototype._zeroBits = function _zeroBits (w) {
  	    // Short-cut
  	    if (w === 0) return 26;

  	    var t = w;
  	    var r = 0;
  	    if ((t & 0x1fff) === 0) {
  	      r += 13;
  	      t >>>= 13;
  	    }
  	    if ((t & 0x7f) === 0) {
  	      r += 7;
  	      t >>>= 7;
  	    }
  	    if ((t & 0xf) === 0) {
  	      r += 4;
  	      t >>>= 4;
  	    }
  	    if ((t & 0x3) === 0) {
  	      r += 2;
  	      t >>>= 2;
  	    }
  	    if ((t & 0x1) === 0) {
  	      r++;
  	    }
  	    return r;
  	  };

  	  // Return number of used bits in a BN
  	  BN.prototype.bitLength = function bitLength () {
  	    var w = this.words[this.length - 1];
  	    var hi = this._countBits(w);
  	    return (this.length - 1) * 26 + hi;
  	  };

  	  function toBitArray (num) {
  	    var w = new Array(num.bitLength());

  	    for (var bit = 0; bit < w.length; bit++) {
  	      var off = (bit / 26) | 0;
  	      var wbit = bit % 26;

  	      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
  	    }

  	    return w;
  	  }

  	  // Number of trailing zero bits
  	  BN.prototype.zeroBits = function zeroBits () {
  	    if (this.isZero()) return 0;

  	    var r = 0;
  	    for (var i = 0; i < this.length; i++) {
  	      var b = this._zeroBits(this.words[i]);
  	      r += b;
  	      if (b !== 26) break;
  	    }
  	    return r;
  	  };

  	  BN.prototype.byteLength = function byteLength () {
  	    return Math.ceil(this.bitLength() / 8);
  	  };

  	  BN.prototype.toTwos = function toTwos (width) {
  	    if (this.negative !== 0) {
  	      return this.abs().inotn(width).iaddn(1);
  	    }
  	    return this.clone();
  	  };

  	  BN.prototype.fromTwos = function fromTwos (width) {
  	    if (this.testn(width - 1)) {
  	      return this.notn(width).iaddn(1).ineg();
  	    }
  	    return this.clone();
  	  };

  	  BN.prototype.isNeg = function isNeg () {
  	    return this.negative !== 0;
  	  };

  	  // Return negative clone of `this`
  	  BN.prototype.neg = function neg () {
  	    return this.clone().ineg();
  	  };

  	  BN.prototype.ineg = function ineg () {
  	    if (!this.isZero()) {
  	      this.negative ^= 1;
  	    }

  	    return this;
  	  };

  	  // Or `num` with `this` in-place
  	  BN.prototype.iuor = function iuor (num) {
  	    while (this.length < num.length) {
  	      this.words[this.length++] = 0;
  	    }

  	    for (var i = 0; i < num.length; i++) {
  	      this.words[i] = this.words[i] | num.words[i];
  	    }

  	    return this.strip();
  	  };

  	  BN.prototype.ior = function ior (num) {
  	    assert((this.negative | num.negative) === 0);
  	    return this.iuor(num);
  	  };

  	  // Or `num` with `this`
  	  BN.prototype.or = function or (num) {
  	    if (this.length > num.length) return this.clone().ior(num);
  	    return num.clone().ior(this);
  	  };

  	  BN.prototype.uor = function uor (num) {
  	    if (this.length > num.length) return this.clone().iuor(num);
  	    return num.clone().iuor(this);
  	  };

  	  // And `num` with `this` in-place
  	  BN.prototype.iuand = function iuand (num) {
  	    // b = min-length(num, this)
  	    var b;
  	    if (this.length > num.length) {
  	      b = num;
  	    } else {
  	      b = this;
  	    }

  	    for (var i = 0; i < b.length; i++) {
  	      this.words[i] = this.words[i] & num.words[i];
  	    }

  	    this.length = b.length;

  	    return this.strip();
  	  };

  	  BN.prototype.iand = function iand (num) {
  	    assert((this.negative | num.negative) === 0);
  	    return this.iuand(num);
  	  };

  	  // And `num` with `this`
  	  BN.prototype.and = function and (num) {
  	    if (this.length > num.length) return this.clone().iand(num);
  	    return num.clone().iand(this);
  	  };

  	  BN.prototype.uand = function uand (num) {
  	    if (this.length > num.length) return this.clone().iuand(num);
  	    return num.clone().iuand(this);
  	  };

  	  // Xor `num` with `this` in-place
  	  BN.prototype.iuxor = function iuxor (num) {
  	    // a.length > b.length
  	    var a;
  	    var b;
  	    if (this.length > num.length) {
  	      a = this;
  	      b = num;
  	    } else {
  	      a = num;
  	      b = this;
  	    }

  	    for (var i = 0; i < b.length; i++) {
  	      this.words[i] = a.words[i] ^ b.words[i];
  	    }

  	    if (this !== a) {
  	      for (; i < a.length; i++) {
  	        this.words[i] = a.words[i];
  	      }
  	    }

  	    this.length = a.length;

  	    return this.strip();
  	  };

  	  BN.prototype.ixor = function ixor (num) {
  	    assert((this.negative | num.negative) === 0);
  	    return this.iuxor(num);
  	  };

  	  // Xor `num` with `this`
  	  BN.prototype.xor = function xor (num) {
  	    if (this.length > num.length) return this.clone().ixor(num);
  	    return num.clone().ixor(this);
  	  };

  	  BN.prototype.uxor = function uxor (num) {
  	    if (this.length > num.length) return this.clone().iuxor(num);
  	    return num.clone().iuxor(this);
  	  };

  	  // Not ``this`` with ``width`` bitwidth
  	  BN.prototype.inotn = function inotn (width) {
  	    assert(typeof width === 'number' && width >= 0);

  	    var bytesNeeded = Math.ceil(width / 26) | 0;
  	    var bitsLeft = width % 26;

  	    // Extend the buffer with leading zeroes
  	    this._expand(bytesNeeded);

  	    if (bitsLeft > 0) {
  	      bytesNeeded--;
  	    }

  	    // Handle complete words
  	    for (var i = 0; i < bytesNeeded; i++) {
  	      this.words[i] = ~this.words[i] & 0x3ffffff;
  	    }

  	    // Handle the residue
  	    if (bitsLeft > 0) {
  	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
  	    }

  	    // And remove leading zeroes
  	    return this.strip();
  	  };

  	  BN.prototype.notn = function notn (width) {
  	    return this.clone().inotn(width);
  	  };

  	  // Set `bit` of `this`
  	  BN.prototype.setn = function setn (bit, val) {
  	    assert(typeof bit === 'number' && bit >= 0);

  	    var off = (bit / 26) | 0;
  	    var wbit = bit % 26;

  	    this._expand(off + 1);

  	    if (val) {
  	      this.words[off] = this.words[off] | (1 << wbit);
  	    } else {
  	      this.words[off] = this.words[off] & ~(1 << wbit);
  	    }

  	    return this.strip();
  	  };

  	  // Add `num` to `this` in-place
  	  BN.prototype.iadd = function iadd (num) {
  	    var r;

  	    // negative + positive
  	    if (this.negative !== 0 && num.negative === 0) {
  	      this.negative = 0;
  	      r = this.isub(num);
  	      this.negative ^= 1;
  	      return this._normSign();

  	    // positive + negative
  	    } else if (this.negative === 0 && num.negative !== 0) {
  	      num.negative = 0;
  	      r = this.isub(num);
  	      num.negative = 1;
  	      return r._normSign();
  	    }

  	    // a.length > b.length
  	    var a, b;
  	    if (this.length > num.length) {
  	      a = this;
  	      b = num;
  	    } else {
  	      a = num;
  	      b = this;
  	    }

  	    var carry = 0;
  	    for (var i = 0; i < b.length; i++) {
  	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
  	      this.words[i] = r & 0x3ffffff;
  	      carry = r >>> 26;
  	    }
  	    for (; carry !== 0 && i < a.length; i++) {
  	      r = (a.words[i] | 0) + carry;
  	      this.words[i] = r & 0x3ffffff;
  	      carry = r >>> 26;
  	    }

  	    this.length = a.length;
  	    if (carry !== 0) {
  	      this.words[this.length] = carry;
  	      this.length++;
  	    // Copy the rest of the words
  	    } else if (a !== this) {
  	      for (; i < a.length; i++) {
  	        this.words[i] = a.words[i];
  	      }
  	    }

  	    return this;
  	  };

  	  // Add `num` to `this`
  	  BN.prototype.add = function add (num) {
  	    var res;
  	    if (num.negative !== 0 && this.negative === 0) {
  	      num.negative = 0;
  	      res = this.sub(num);
  	      num.negative ^= 1;
  	      return res;
  	    } else if (num.negative === 0 && this.negative !== 0) {
  	      this.negative = 0;
  	      res = num.sub(this);
  	      this.negative = 1;
  	      return res;
  	    }

  	    if (this.length > num.length) return this.clone().iadd(num);

  	    return num.clone().iadd(this);
  	  };

  	  // Subtract `num` from `this` in-place
  	  BN.prototype.isub = function isub (num) {
  	    // this - (-num) = this + num
  	    if (num.negative !== 0) {
  	      num.negative = 0;
  	      var r = this.iadd(num);
  	      num.negative = 1;
  	      return r._normSign();

  	    // -this - num = -(this + num)
  	    } else if (this.negative !== 0) {
  	      this.negative = 0;
  	      this.iadd(num);
  	      this.negative = 1;
  	      return this._normSign();
  	    }

  	    // At this point both numbers are positive
  	    var cmp = this.cmp(num);

  	    // Optimization - zeroify
  	    if (cmp === 0) {
  	      this.negative = 0;
  	      this.length = 1;
  	      this.words[0] = 0;
  	      return this;
  	    }

  	    // a > b
  	    var a, b;
  	    if (cmp > 0) {
  	      a = this;
  	      b = num;
  	    } else {
  	      a = num;
  	      b = this;
  	    }

  	    var carry = 0;
  	    for (var i = 0; i < b.length; i++) {
  	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
  	      carry = r >> 26;
  	      this.words[i] = r & 0x3ffffff;
  	    }
  	    for (; carry !== 0 && i < a.length; i++) {
  	      r = (a.words[i] | 0) + carry;
  	      carry = r >> 26;
  	      this.words[i] = r & 0x3ffffff;
  	    }

  	    // Copy rest of the words
  	    if (carry === 0 && i < a.length && a !== this) {
  	      for (; i < a.length; i++) {
  	        this.words[i] = a.words[i];
  	      }
  	    }

  	    this.length = Math.max(this.length, i);

  	    if (a !== this) {
  	      this.negative = 1;
  	    }

  	    return this.strip();
  	  };

  	  // Subtract `num` from `this`
  	  BN.prototype.sub = function sub (num) {
  	    return this.clone().isub(num);
  	  };

  	  function smallMulTo (self, num, out) {
  	    out.negative = num.negative ^ self.negative;
  	    var len = (self.length + num.length) | 0;
  	    out.length = len;
  	    len = (len - 1) | 0;

  	    // Peel one iteration (compiler can't do it, because of code complexity)
  	    var a = self.words[0] | 0;
  	    var b = num.words[0] | 0;
  	    var r = a * b;

  	    var lo = r & 0x3ffffff;
  	    var carry = (r / 0x4000000) | 0;
  	    out.words[0] = lo;

  	    for (var k = 1; k < len; k++) {
  	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
  	      // note that ncarry could be >= 0x3ffffff
  	      var ncarry = carry >>> 26;
  	      var rword = carry & 0x3ffffff;
  	      var maxJ = Math.min(k, num.length - 1);
  	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
  	        var i = (k - j) | 0;
  	        a = self.words[i] | 0;
  	        b = num.words[j] | 0;
  	        r = a * b + rword;
  	        ncarry += (r / 0x4000000) | 0;
  	        rword = r & 0x3ffffff;
  	      }
  	      out.words[k] = rword | 0;
  	      carry = ncarry | 0;
  	    }
  	    if (carry !== 0) {
  	      out.words[k] = carry | 0;
  	    } else {
  	      out.length--;
  	    }

  	    return out.strip();
  	  }

  	  // TODO(indutny): it may be reasonable to omit it for users who don't need
  	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  	  // multiplication (like elliptic secp256k1).
  	  var comb10MulTo = function comb10MulTo (self, num, out) {
  	    var a = self.words;
  	    var b = num.words;
  	    var o = out.words;
  	    var c = 0;
  	    var lo;
  	    var mid;
  	    var hi;
  	    var a0 = a[0] | 0;
  	    var al0 = a0 & 0x1fff;
  	    var ah0 = a0 >>> 13;
  	    var a1 = a[1] | 0;
  	    var al1 = a1 & 0x1fff;
  	    var ah1 = a1 >>> 13;
  	    var a2 = a[2] | 0;
  	    var al2 = a2 & 0x1fff;
  	    var ah2 = a2 >>> 13;
  	    var a3 = a[3] | 0;
  	    var al3 = a3 & 0x1fff;
  	    var ah3 = a3 >>> 13;
  	    var a4 = a[4] | 0;
  	    var al4 = a4 & 0x1fff;
  	    var ah4 = a4 >>> 13;
  	    var a5 = a[5] | 0;
  	    var al5 = a5 & 0x1fff;
  	    var ah5 = a5 >>> 13;
  	    var a6 = a[6] | 0;
  	    var al6 = a6 & 0x1fff;
  	    var ah6 = a6 >>> 13;
  	    var a7 = a[7] | 0;
  	    var al7 = a7 & 0x1fff;
  	    var ah7 = a7 >>> 13;
  	    var a8 = a[8] | 0;
  	    var al8 = a8 & 0x1fff;
  	    var ah8 = a8 >>> 13;
  	    var a9 = a[9] | 0;
  	    var al9 = a9 & 0x1fff;
  	    var ah9 = a9 >>> 13;
  	    var b0 = b[0] | 0;
  	    var bl0 = b0 & 0x1fff;
  	    var bh0 = b0 >>> 13;
  	    var b1 = b[1] | 0;
  	    var bl1 = b1 & 0x1fff;
  	    var bh1 = b1 >>> 13;
  	    var b2 = b[2] | 0;
  	    var bl2 = b2 & 0x1fff;
  	    var bh2 = b2 >>> 13;
  	    var b3 = b[3] | 0;
  	    var bl3 = b3 & 0x1fff;
  	    var bh3 = b3 >>> 13;
  	    var b4 = b[4] | 0;
  	    var bl4 = b4 & 0x1fff;
  	    var bh4 = b4 >>> 13;
  	    var b5 = b[5] | 0;
  	    var bl5 = b5 & 0x1fff;
  	    var bh5 = b5 >>> 13;
  	    var b6 = b[6] | 0;
  	    var bl6 = b6 & 0x1fff;
  	    var bh6 = b6 >>> 13;
  	    var b7 = b[7] | 0;
  	    var bl7 = b7 & 0x1fff;
  	    var bh7 = b7 >>> 13;
  	    var b8 = b[8] | 0;
  	    var bl8 = b8 & 0x1fff;
  	    var bh8 = b8 >>> 13;
  	    var b9 = b[9] | 0;
  	    var bl9 = b9 & 0x1fff;
  	    var bh9 = b9 >>> 13;

  	    out.negative = self.negative ^ num.negative;
  	    out.length = 19;
  	    /* k = 0 */
  	    lo = Math.imul(al0, bl0);
  	    mid = Math.imul(al0, bh0);
  	    mid = (mid + Math.imul(ah0, bl0)) | 0;
  	    hi = Math.imul(ah0, bh0);
  	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
  	    w0 &= 0x3ffffff;
  	    /* k = 1 */
  	    lo = Math.imul(al1, bl0);
  	    mid = Math.imul(al1, bh0);
  	    mid = (mid + Math.imul(ah1, bl0)) | 0;
  	    hi = Math.imul(ah1, bh0);
  	    lo = (lo + Math.imul(al0, bl1)) | 0;
  	    mid = (mid + Math.imul(al0, bh1)) | 0;
  	    mid = (mid + Math.imul(ah0, bl1)) | 0;
  	    hi = (hi + Math.imul(ah0, bh1)) | 0;
  	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
  	    w1 &= 0x3ffffff;
  	    /* k = 2 */
  	    lo = Math.imul(al2, bl0);
  	    mid = Math.imul(al2, bh0);
  	    mid = (mid + Math.imul(ah2, bl0)) | 0;
  	    hi = Math.imul(ah2, bh0);
  	    lo = (lo + Math.imul(al1, bl1)) | 0;
  	    mid = (mid + Math.imul(al1, bh1)) | 0;
  	    mid = (mid + Math.imul(ah1, bl1)) | 0;
  	    hi = (hi + Math.imul(ah1, bh1)) | 0;
  	    lo = (lo + Math.imul(al0, bl2)) | 0;
  	    mid = (mid + Math.imul(al0, bh2)) | 0;
  	    mid = (mid + Math.imul(ah0, bl2)) | 0;
  	    hi = (hi + Math.imul(ah0, bh2)) | 0;
  	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
  	    w2 &= 0x3ffffff;
  	    /* k = 3 */
  	    lo = Math.imul(al3, bl0);
  	    mid = Math.imul(al3, bh0);
  	    mid = (mid + Math.imul(ah3, bl0)) | 0;
  	    hi = Math.imul(ah3, bh0);
  	    lo = (lo + Math.imul(al2, bl1)) | 0;
  	    mid = (mid + Math.imul(al2, bh1)) | 0;
  	    mid = (mid + Math.imul(ah2, bl1)) | 0;
  	    hi = (hi + Math.imul(ah2, bh1)) | 0;
  	    lo = (lo + Math.imul(al1, bl2)) | 0;
  	    mid = (mid + Math.imul(al1, bh2)) | 0;
  	    mid = (mid + Math.imul(ah1, bl2)) | 0;
  	    hi = (hi + Math.imul(ah1, bh2)) | 0;
  	    lo = (lo + Math.imul(al0, bl3)) | 0;
  	    mid = (mid + Math.imul(al0, bh3)) | 0;
  	    mid = (mid + Math.imul(ah0, bl3)) | 0;
  	    hi = (hi + Math.imul(ah0, bh3)) | 0;
  	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
  	    w3 &= 0x3ffffff;
  	    /* k = 4 */
  	    lo = Math.imul(al4, bl0);
  	    mid = Math.imul(al4, bh0);
  	    mid = (mid + Math.imul(ah4, bl0)) | 0;
  	    hi = Math.imul(ah4, bh0);
  	    lo = (lo + Math.imul(al3, bl1)) | 0;
  	    mid = (mid + Math.imul(al3, bh1)) | 0;
  	    mid = (mid + Math.imul(ah3, bl1)) | 0;
  	    hi = (hi + Math.imul(ah3, bh1)) | 0;
  	    lo = (lo + Math.imul(al2, bl2)) | 0;
  	    mid = (mid + Math.imul(al2, bh2)) | 0;
  	    mid = (mid + Math.imul(ah2, bl2)) | 0;
  	    hi = (hi + Math.imul(ah2, bh2)) | 0;
  	    lo = (lo + Math.imul(al1, bl3)) | 0;
  	    mid = (mid + Math.imul(al1, bh3)) | 0;
  	    mid = (mid + Math.imul(ah1, bl3)) | 0;
  	    hi = (hi + Math.imul(ah1, bh3)) | 0;
  	    lo = (lo + Math.imul(al0, bl4)) | 0;
  	    mid = (mid + Math.imul(al0, bh4)) | 0;
  	    mid = (mid + Math.imul(ah0, bl4)) | 0;
  	    hi = (hi + Math.imul(ah0, bh4)) | 0;
  	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
  	    w4 &= 0x3ffffff;
  	    /* k = 5 */
  	    lo = Math.imul(al5, bl0);
  	    mid = Math.imul(al5, bh0);
  	    mid = (mid + Math.imul(ah5, bl0)) | 0;
  	    hi = Math.imul(ah5, bh0);
  	    lo = (lo + Math.imul(al4, bl1)) | 0;
  	    mid = (mid + Math.imul(al4, bh1)) | 0;
  	    mid = (mid + Math.imul(ah4, bl1)) | 0;
  	    hi = (hi + Math.imul(ah4, bh1)) | 0;
  	    lo = (lo + Math.imul(al3, bl2)) | 0;
  	    mid = (mid + Math.imul(al3, bh2)) | 0;
  	    mid = (mid + Math.imul(ah3, bl2)) | 0;
  	    hi = (hi + Math.imul(ah3, bh2)) | 0;
  	    lo = (lo + Math.imul(al2, bl3)) | 0;
  	    mid = (mid + Math.imul(al2, bh3)) | 0;
  	    mid = (mid + Math.imul(ah2, bl3)) | 0;
  	    hi = (hi + Math.imul(ah2, bh3)) | 0;
  	    lo = (lo + Math.imul(al1, bl4)) | 0;
  	    mid = (mid + Math.imul(al1, bh4)) | 0;
  	    mid = (mid + Math.imul(ah1, bl4)) | 0;
  	    hi = (hi + Math.imul(ah1, bh4)) | 0;
  	    lo = (lo + Math.imul(al0, bl5)) | 0;
  	    mid = (mid + Math.imul(al0, bh5)) | 0;
  	    mid = (mid + Math.imul(ah0, bl5)) | 0;
  	    hi = (hi + Math.imul(ah0, bh5)) | 0;
  	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
  	    w5 &= 0x3ffffff;
  	    /* k = 6 */
  	    lo = Math.imul(al6, bl0);
  	    mid = Math.imul(al6, bh0);
  	    mid = (mid + Math.imul(ah6, bl0)) | 0;
  	    hi = Math.imul(ah6, bh0);
  	    lo = (lo + Math.imul(al5, bl1)) | 0;
  	    mid = (mid + Math.imul(al5, bh1)) | 0;
  	    mid = (mid + Math.imul(ah5, bl1)) | 0;
  	    hi = (hi + Math.imul(ah5, bh1)) | 0;
  	    lo = (lo + Math.imul(al4, bl2)) | 0;
  	    mid = (mid + Math.imul(al4, bh2)) | 0;
  	    mid = (mid + Math.imul(ah4, bl2)) | 0;
  	    hi = (hi + Math.imul(ah4, bh2)) | 0;
  	    lo = (lo + Math.imul(al3, bl3)) | 0;
  	    mid = (mid + Math.imul(al3, bh3)) | 0;
  	    mid = (mid + Math.imul(ah3, bl3)) | 0;
  	    hi = (hi + Math.imul(ah3, bh3)) | 0;
  	    lo = (lo + Math.imul(al2, bl4)) | 0;
  	    mid = (mid + Math.imul(al2, bh4)) | 0;
  	    mid = (mid + Math.imul(ah2, bl4)) | 0;
  	    hi = (hi + Math.imul(ah2, bh4)) | 0;
  	    lo = (lo + Math.imul(al1, bl5)) | 0;
  	    mid = (mid + Math.imul(al1, bh5)) | 0;
  	    mid = (mid + Math.imul(ah1, bl5)) | 0;
  	    hi = (hi + Math.imul(ah1, bh5)) | 0;
  	    lo = (lo + Math.imul(al0, bl6)) | 0;
  	    mid = (mid + Math.imul(al0, bh6)) | 0;
  	    mid = (mid + Math.imul(ah0, bl6)) | 0;
  	    hi = (hi + Math.imul(ah0, bh6)) | 0;
  	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
  	    w6 &= 0x3ffffff;
  	    /* k = 7 */
  	    lo = Math.imul(al7, bl0);
  	    mid = Math.imul(al7, bh0);
  	    mid = (mid + Math.imul(ah7, bl0)) | 0;
  	    hi = Math.imul(ah7, bh0);
  	    lo = (lo + Math.imul(al6, bl1)) | 0;
  	    mid = (mid + Math.imul(al6, bh1)) | 0;
  	    mid = (mid + Math.imul(ah6, bl1)) | 0;
  	    hi = (hi + Math.imul(ah6, bh1)) | 0;
  	    lo = (lo + Math.imul(al5, bl2)) | 0;
  	    mid = (mid + Math.imul(al5, bh2)) | 0;
  	    mid = (mid + Math.imul(ah5, bl2)) | 0;
  	    hi = (hi + Math.imul(ah5, bh2)) | 0;
  	    lo = (lo + Math.imul(al4, bl3)) | 0;
  	    mid = (mid + Math.imul(al4, bh3)) | 0;
  	    mid = (mid + Math.imul(ah4, bl3)) | 0;
  	    hi = (hi + Math.imul(ah4, bh3)) | 0;
  	    lo = (lo + Math.imul(al3, bl4)) | 0;
  	    mid = (mid + Math.imul(al3, bh4)) | 0;
  	    mid = (mid + Math.imul(ah3, bl4)) | 0;
  	    hi = (hi + Math.imul(ah3, bh4)) | 0;
  	    lo = (lo + Math.imul(al2, bl5)) | 0;
  	    mid = (mid + Math.imul(al2, bh5)) | 0;
  	    mid = (mid + Math.imul(ah2, bl5)) | 0;
  	    hi = (hi + Math.imul(ah2, bh5)) | 0;
  	    lo = (lo + Math.imul(al1, bl6)) | 0;
  	    mid = (mid + Math.imul(al1, bh6)) | 0;
  	    mid = (mid + Math.imul(ah1, bl6)) | 0;
  	    hi = (hi + Math.imul(ah1, bh6)) | 0;
  	    lo = (lo + Math.imul(al0, bl7)) | 0;
  	    mid = (mid + Math.imul(al0, bh7)) | 0;
  	    mid = (mid + Math.imul(ah0, bl7)) | 0;
  	    hi = (hi + Math.imul(ah0, bh7)) | 0;
  	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
  	    w7 &= 0x3ffffff;
  	    /* k = 8 */
  	    lo = Math.imul(al8, bl0);
  	    mid = Math.imul(al8, bh0);
  	    mid = (mid + Math.imul(ah8, bl0)) | 0;
  	    hi = Math.imul(ah8, bh0);
  	    lo = (lo + Math.imul(al7, bl1)) | 0;
  	    mid = (mid + Math.imul(al7, bh1)) | 0;
  	    mid = (mid + Math.imul(ah7, bl1)) | 0;
  	    hi = (hi + Math.imul(ah7, bh1)) | 0;
  	    lo = (lo + Math.imul(al6, bl2)) | 0;
  	    mid = (mid + Math.imul(al6, bh2)) | 0;
  	    mid = (mid + Math.imul(ah6, bl2)) | 0;
  	    hi = (hi + Math.imul(ah6, bh2)) | 0;
  	    lo = (lo + Math.imul(al5, bl3)) | 0;
  	    mid = (mid + Math.imul(al5, bh3)) | 0;
  	    mid = (mid + Math.imul(ah5, bl3)) | 0;
  	    hi = (hi + Math.imul(ah5, bh3)) | 0;
  	    lo = (lo + Math.imul(al4, bl4)) | 0;
  	    mid = (mid + Math.imul(al4, bh4)) | 0;
  	    mid = (mid + Math.imul(ah4, bl4)) | 0;
  	    hi = (hi + Math.imul(ah4, bh4)) | 0;
  	    lo = (lo + Math.imul(al3, bl5)) | 0;
  	    mid = (mid + Math.imul(al3, bh5)) | 0;
  	    mid = (mid + Math.imul(ah3, bl5)) | 0;
  	    hi = (hi + Math.imul(ah3, bh5)) | 0;
  	    lo = (lo + Math.imul(al2, bl6)) | 0;
  	    mid = (mid + Math.imul(al2, bh6)) | 0;
  	    mid = (mid + Math.imul(ah2, bl6)) | 0;
  	    hi = (hi + Math.imul(ah2, bh6)) | 0;
  	    lo = (lo + Math.imul(al1, bl7)) | 0;
  	    mid = (mid + Math.imul(al1, bh7)) | 0;
  	    mid = (mid + Math.imul(ah1, bl7)) | 0;
  	    hi = (hi + Math.imul(ah1, bh7)) | 0;
  	    lo = (lo + Math.imul(al0, bl8)) | 0;
  	    mid = (mid + Math.imul(al0, bh8)) | 0;
  	    mid = (mid + Math.imul(ah0, bl8)) | 0;
  	    hi = (hi + Math.imul(ah0, bh8)) | 0;
  	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
  	    w8 &= 0x3ffffff;
  	    /* k = 9 */
  	    lo = Math.imul(al9, bl0);
  	    mid = Math.imul(al9, bh0);
  	    mid = (mid + Math.imul(ah9, bl0)) | 0;
  	    hi = Math.imul(ah9, bh0);
  	    lo = (lo + Math.imul(al8, bl1)) | 0;
  	    mid = (mid + Math.imul(al8, bh1)) | 0;
  	    mid = (mid + Math.imul(ah8, bl1)) | 0;
  	    hi = (hi + Math.imul(ah8, bh1)) | 0;
  	    lo = (lo + Math.imul(al7, bl2)) | 0;
  	    mid = (mid + Math.imul(al7, bh2)) | 0;
  	    mid = (mid + Math.imul(ah7, bl2)) | 0;
  	    hi = (hi + Math.imul(ah7, bh2)) | 0;
  	    lo = (lo + Math.imul(al6, bl3)) | 0;
  	    mid = (mid + Math.imul(al6, bh3)) | 0;
  	    mid = (mid + Math.imul(ah6, bl3)) | 0;
  	    hi = (hi + Math.imul(ah6, bh3)) | 0;
  	    lo = (lo + Math.imul(al5, bl4)) | 0;
  	    mid = (mid + Math.imul(al5, bh4)) | 0;
  	    mid = (mid + Math.imul(ah5, bl4)) | 0;
  	    hi = (hi + Math.imul(ah5, bh4)) | 0;
  	    lo = (lo + Math.imul(al4, bl5)) | 0;
  	    mid = (mid + Math.imul(al4, bh5)) | 0;
  	    mid = (mid + Math.imul(ah4, bl5)) | 0;
  	    hi = (hi + Math.imul(ah4, bh5)) | 0;
  	    lo = (lo + Math.imul(al3, bl6)) | 0;
  	    mid = (mid + Math.imul(al3, bh6)) | 0;
  	    mid = (mid + Math.imul(ah3, bl6)) | 0;
  	    hi = (hi + Math.imul(ah3, bh6)) | 0;
  	    lo = (lo + Math.imul(al2, bl7)) | 0;
  	    mid = (mid + Math.imul(al2, bh7)) | 0;
  	    mid = (mid + Math.imul(ah2, bl7)) | 0;
  	    hi = (hi + Math.imul(ah2, bh7)) | 0;
  	    lo = (lo + Math.imul(al1, bl8)) | 0;
  	    mid = (mid + Math.imul(al1, bh8)) | 0;
  	    mid = (mid + Math.imul(ah1, bl8)) | 0;
  	    hi = (hi + Math.imul(ah1, bh8)) | 0;
  	    lo = (lo + Math.imul(al0, bl9)) | 0;
  	    mid = (mid + Math.imul(al0, bh9)) | 0;
  	    mid = (mid + Math.imul(ah0, bl9)) | 0;
  	    hi = (hi + Math.imul(ah0, bh9)) | 0;
  	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
  	    w9 &= 0x3ffffff;
  	    /* k = 10 */
  	    lo = Math.imul(al9, bl1);
  	    mid = Math.imul(al9, bh1);
  	    mid = (mid + Math.imul(ah9, bl1)) | 0;
  	    hi = Math.imul(ah9, bh1);
  	    lo = (lo + Math.imul(al8, bl2)) | 0;
  	    mid = (mid + Math.imul(al8, bh2)) | 0;
  	    mid = (mid + Math.imul(ah8, bl2)) | 0;
  	    hi = (hi + Math.imul(ah8, bh2)) | 0;
  	    lo = (lo + Math.imul(al7, bl3)) | 0;
  	    mid = (mid + Math.imul(al7, bh3)) | 0;
  	    mid = (mid + Math.imul(ah7, bl3)) | 0;
  	    hi = (hi + Math.imul(ah7, bh3)) | 0;
  	    lo = (lo + Math.imul(al6, bl4)) | 0;
  	    mid = (mid + Math.imul(al6, bh4)) | 0;
  	    mid = (mid + Math.imul(ah6, bl4)) | 0;
  	    hi = (hi + Math.imul(ah6, bh4)) | 0;
  	    lo = (lo + Math.imul(al5, bl5)) | 0;
  	    mid = (mid + Math.imul(al5, bh5)) | 0;
  	    mid = (mid + Math.imul(ah5, bl5)) | 0;
  	    hi = (hi + Math.imul(ah5, bh5)) | 0;
  	    lo = (lo + Math.imul(al4, bl6)) | 0;
  	    mid = (mid + Math.imul(al4, bh6)) | 0;
  	    mid = (mid + Math.imul(ah4, bl6)) | 0;
  	    hi = (hi + Math.imul(ah4, bh6)) | 0;
  	    lo = (lo + Math.imul(al3, bl7)) | 0;
  	    mid = (mid + Math.imul(al3, bh7)) | 0;
  	    mid = (mid + Math.imul(ah3, bl7)) | 0;
  	    hi = (hi + Math.imul(ah3, bh7)) | 0;
  	    lo = (lo + Math.imul(al2, bl8)) | 0;
  	    mid = (mid + Math.imul(al2, bh8)) | 0;
  	    mid = (mid + Math.imul(ah2, bl8)) | 0;
  	    hi = (hi + Math.imul(ah2, bh8)) | 0;
  	    lo = (lo + Math.imul(al1, bl9)) | 0;
  	    mid = (mid + Math.imul(al1, bh9)) | 0;
  	    mid = (mid + Math.imul(ah1, bl9)) | 0;
  	    hi = (hi + Math.imul(ah1, bh9)) | 0;
  	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
  	    w10 &= 0x3ffffff;
  	    /* k = 11 */
  	    lo = Math.imul(al9, bl2);
  	    mid = Math.imul(al9, bh2);
  	    mid = (mid + Math.imul(ah9, bl2)) | 0;
  	    hi = Math.imul(ah9, bh2);
  	    lo = (lo + Math.imul(al8, bl3)) | 0;
  	    mid = (mid + Math.imul(al8, bh3)) | 0;
  	    mid = (mid + Math.imul(ah8, bl3)) | 0;
  	    hi = (hi + Math.imul(ah8, bh3)) | 0;
  	    lo = (lo + Math.imul(al7, bl4)) | 0;
  	    mid = (mid + Math.imul(al7, bh4)) | 0;
  	    mid = (mid + Math.imul(ah7, bl4)) | 0;
  	    hi = (hi + Math.imul(ah7, bh4)) | 0;
  	    lo = (lo + Math.imul(al6, bl5)) | 0;
  	    mid = (mid + Math.imul(al6, bh5)) | 0;
  	    mid = (mid + Math.imul(ah6, bl5)) | 0;
  	    hi = (hi + Math.imul(ah6, bh5)) | 0;
  	    lo = (lo + Math.imul(al5, bl6)) | 0;
  	    mid = (mid + Math.imul(al5, bh6)) | 0;
  	    mid = (mid + Math.imul(ah5, bl6)) | 0;
  	    hi = (hi + Math.imul(ah5, bh6)) | 0;
  	    lo = (lo + Math.imul(al4, bl7)) | 0;
  	    mid = (mid + Math.imul(al4, bh7)) | 0;
  	    mid = (mid + Math.imul(ah4, bl7)) | 0;
  	    hi = (hi + Math.imul(ah4, bh7)) | 0;
  	    lo = (lo + Math.imul(al3, bl8)) | 0;
  	    mid = (mid + Math.imul(al3, bh8)) | 0;
  	    mid = (mid + Math.imul(ah3, bl8)) | 0;
  	    hi = (hi + Math.imul(ah3, bh8)) | 0;
  	    lo = (lo + Math.imul(al2, bl9)) | 0;
  	    mid = (mid + Math.imul(al2, bh9)) | 0;
  	    mid = (mid + Math.imul(ah2, bl9)) | 0;
  	    hi = (hi + Math.imul(ah2, bh9)) | 0;
  	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
  	    w11 &= 0x3ffffff;
  	    /* k = 12 */
  	    lo = Math.imul(al9, bl3);
  	    mid = Math.imul(al9, bh3);
  	    mid = (mid + Math.imul(ah9, bl3)) | 0;
  	    hi = Math.imul(ah9, bh3);
  	    lo = (lo + Math.imul(al8, bl4)) | 0;
  	    mid = (mid + Math.imul(al8, bh4)) | 0;
  	    mid = (mid + Math.imul(ah8, bl4)) | 0;
  	    hi = (hi + Math.imul(ah8, bh4)) | 0;
  	    lo = (lo + Math.imul(al7, bl5)) | 0;
  	    mid = (mid + Math.imul(al7, bh5)) | 0;
  	    mid = (mid + Math.imul(ah7, bl5)) | 0;
  	    hi = (hi + Math.imul(ah7, bh5)) | 0;
  	    lo = (lo + Math.imul(al6, bl6)) | 0;
  	    mid = (mid + Math.imul(al6, bh6)) | 0;
  	    mid = (mid + Math.imul(ah6, bl6)) | 0;
  	    hi = (hi + Math.imul(ah6, bh6)) | 0;
  	    lo = (lo + Math.imul(al5, bl7)) | 0;
  	    mid = (mid + Math.imul(al5, bh7)) | 0;
  	    mid = (mid + Math.imul(ah5, bl7)) | 0;
  	    hi = (hi + Math.imul(ah5, bh7)) | 0;
  	    lo = (lo + Math.imul(al4, bl8)) | 0;
  	    mid = (mid + Math.imul(al4, bh8)) | 0;
  	    mid = (mid + Math.imul(ah4, bl8)) | 0;
  	    hi = (hi + Math.imul(ah4, bh8)) | 0;
  	    lo = (lo + Math.imul(al3, bl9)) | 0;
  	    mid = (mid + Math.imul(al3, bh9)) | 0;
  	    mid = (mid + Math.imul(ah3, bl9)) | 0;
  	    hi = (hi + Math.imul(ah3, bh9)) | 0;
  	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
  	    w12 &= 0x3ffffff;
  	    /* k = 13 */
  	    lo = Math.imul(al9, bl4);
  	    mid = Math.imul(al9, bh4);
  	    mid = (mid + Math.imul(ah9, bl4)) | 0;
  	    hi = Math.imul(ah9, bh4);
  	    lo = (lo + Math.imul(al8, bl5)) | 0;
  	    mid = (mid + Math.imul(al8, bh5)) | 0;
  	    mid = (mid + Math.imul(ah8, bl5)) | 0;
  	    hi = (hi + Math.imul(ah8, bh5)) | 0;
  	    lo = (lo + Math.imul(al7, bl6)) | 0;
  	    mid = (mid + Math.imul(al7, bh6)) | 0;
  	    mid = (mid + Math.imul(ah7, bl6)) | 0;
  	    hi = (hi + Math.imul(ah7, bh6)) | 0;
  	    lo = (lo + Math.imul(al6, bl7)) | 0;
  	    mid = (mid + Math.imul(al6, bh7)) | 0;
  	    mid = (mid + Math.imul(ah6, bl7)) | 0;
  	    hi = (hi + Math.imul(ah6, bh7)) | 0;
  	    lo = (lo + Math.imul(al5, bl8)) | 0;
  	    mid = (mid + Math.imul(al5, bh8)) | 0;
  	    mid = (mid + Math.imul(ah5, bl8)) | 0;
  	    hi = (hi + Math.imul(ah5, bh8)) | 0;
  	    lo = (lo + Math.imul(al4, bl9)) | 0;
  	    mid = (mid + Math.imul(al4, bh9)) | 0;
  	    mid = (mid + Math.imul(ah4, bl9)) | 0;
  	    hi = (hi + Math.imul(ah4, bh9)) | 0;
  	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
  	    w13 &= 0x3ffffff;
  	    /* k = 14 */
  	    lo = Math.imul(al9, bl5);
  	    mid = Math.imul(al9, bh5);
  	    mid = (mid + Math.imul(ah9, bl5)) | 0;
  	    hi = Math.imul(ah9, bh5);
  	    lo = (lo + Math.imul(al8, bl6)) | 0;
  	    mid = (mid + Math.imul(al8, bh6)) | 0;
  	    mid = (mid + Math.imul(ah8, bl6)) | 0;
  	    hi = (hi + Math.imul(ah8, bh6)) | 0;
  	    lo = (lo + Math.imul(al7, bl7)) | 0;
  	    mid = (mid + Math.imul(al7, bh7)) | 0;
  	    mid = (mid + Math.imul(ah7, bl7)) | 0;
  	    hi = (hi + Math.imul(ah7, bh7)) | 0;
  	    lo = (lo + Math.imul(al6, bl8)) | 0;
  	    mid = (mid + Math.imul(al6, bh8)) | 0;
  	    mid = (mid + Math.imul(ah6, bl8)) | 0;
  	    hi = (hi + Math.imul(ah6, bh8)) | 0;
  	    lo = (lo + Math.imul(al5, bl9)) | 0;
  	    mid = (mid + Math.imul(al5, bh9)) | 0;
  	    mid = (mid + Math.imul(ah5, bl9)) | 0;
  	    hi = (hi + Math.imul(ah5, bh9)) | 0;
  	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
  	    w14 &= 0x3ffffff;
  	    /* k = 15 */
  	    lo = Math.imul(al9, bl6);
  	    mid = Math.imul(al9, bh6);
  	    mid = (mid + Math.imul(ah9, bl6)) | 0;
  	    hi = Math.imul(ah9, bh6);
  	    lo = (lo + Math.imul(al8, bl7)) | 0;
  	    mid = (mid + Math.imul(al8, bh7)) | 0;
  	    mid = (mid + Math.imul(ah8, bl7)) | 0;
  	    hi = (hi + Math.imul(ah8, bh7)) | 0;
  	    lo = (lo + Math.imul(al7, bl8)) | 0;
  	    mid = (mid + Math.imul(al7, bh8)) | 0;
  	    mid = (mid + Math.imul(ah7, bl8)) | 0;
  	    hi = (hi + Math.imul(ah7, bh8)) | 0;
  	    lo = (lo + Math.imul(al6, bl9)) | 0;
  	    mid = (mid + Math.imul(al6, bh9)) | 0;
  	    mid = (mid + Math.imul(ah6, bl9)) | 0;
  	    hi = (hi + Math.imul(ah6, bh9)) | 0;
  	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
  	    w15 &= 0x3ffffff;
  	    /* k = 16 */
  	    lo = Math.imul(al9, bl7);
  	    mid = Math.imul(al9, bh7);
  	    mid = (mid + Math.imul(ah9, bl7)) | 0;
  	    hi = Math.imul(ah9, bh7);
  	    lo = (lo + Math.imul(al8, bl8)) | 0;
  	    mid = (mid + Math.imul(al8, bh8)) | 0;
  	    mid = (mid + Math.imul(ah8, bl8)) | 0;
  	    hi = (hi + Math.imul(ah8, bh8)) | 0;
  	    lo = (lo + Math.imul(al7, bl9)) | 0;
  	    mid = (mid + Math.imul(al7, bh9)) | 0;
  	    mid = (mid + Math.imul(ah7, bl9)) | 0;
  	    hi = (hi + Math.imul(ah7, bh9)) | 0;
  	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
  	    w16 &= 0x3ffffff;
  	    /* k = 17 */
  	    lo = Math.imul(al9, bl8);
  	    mid = Math.imul(al9, bh8);
  	    mid = (mid + Math.imul(ah9, bl8)) | 0;
  	    hi = Math.imul(ah9, bh8);
  	    lo = (lo + Math.imul(al8, bl9)) | 0;
  	    mid = (mid + Math.imul(al8, bh9)) | 0;
  	    mid = (mid + Math.imul(ah8, bl9)) | 0;
  	    hi = (hi + Math.imul(ah8, bh9)) | 0;
  	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
  	    w17 &= 0x3ffffff;
  	    /* k = 18 */
  	    lo = Math.imul(al9, bl9);
  	    mid = Math.imul(al9, bh9);
  	    mid = (mid + Math.imul(ah9, bl9)) | 0;
  	    hi = Math.imul(ah9, bh9);
  	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
  	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
  	    w18 &= 0x3ffffff;
  	    o[0] = w0;
  	    o[1] = w1;
  	    o[2] = w2;
  	    o[3] = w3;
  	    o[4] = w4;
  	    o[5] = w5;
  	    o[6] = w6;
  	    o[7] = w7;
  	    o[8] = w8;
  	    o[9] = w9;
  	    o[10] = w10;
  	    o[11] = w11;
  	    o[12] = w12;
  	    o[13] = w13;
  	    o[14] = w14;
  	    o[15] = w15;
  	    o[16] = w16;
  	    o[17] = w17;
  	    o[18] = w18;
  	    if (c !== 0) {
  	      o[19] = c;
  	      out.length++;
  	    }
  	    return out;
  	  };

  	  // Polyfill comb
  	  if (!Math.imul) {
  	    comb10MulTo = smallMulTo;
  	  }

  	  function bigMulTo (self, num, out) {
  	    out.negative = num.negative ^ self.negative;
  	    out.length = self.length + num.length;

  	    var carry = 0;
  	    var hncarry = 0;
  	    for (var k = 0; k < out.length - 1; k++) {
  	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
  	      // note that ncarry could be >= 0x3ffffff
  	      var ncarry = hncarry;
  	      hncarry = 0;
  	      var rword = carry & 0x3ffffff;
  	      var maxJ = Math.min(k, num.length - 1);
  	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
  	        var i = k - j;
  	        var a = self.words[i] | 0;
  	        var b = num.words[j] | 0;
  	        var r = a * b;

  	        var lo = r & 0x3ffffff;
  	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
  	        lo = (lo + rword) | 0;
  	        rword = lo & 0x3ffffff;
  	        ncarry = (ncarry + (lo >>> 26)) | 0;

  	        hncarry += ncarry >>> 26;
  	        ncarry &= 0x3ffffff;
  	      }
  	      out.words[k] = rword;
  	      carry = ncarry;
  	      ncarry = hncarry;
  	    }
  	    if (carry !== 0) {
  	      out.words[k] = carry;
  	    } else {
  	      out.length--;
  	    }

  	    return out.strip();
  	  }

  	  function jumboMulTo (self, num, out) {
  	    var fftm = new FFTM();
  	    return fftm.mulp(self, num, out);
  	  }

  	  BN.prototype.mulTo = function mulTo (num, out) {
  	    var res;
  	    var len = this.length + num.length;
  	    if (this.length === 10 && num.length === 10) {
  	      res = comb10MulTo(this, num, out);
  	    } else if (len < 63) {
  	      res = smallMulTo(this, num, out);
  	    } else if (len < 1024) {
  	      res = bigMulTo(this, num, out);
  	    } else {
  	      res = jumboMulTo(this, num, out);
  	    }

  	    return res;
  	  };

  	  // Cooley-Tukey algorithm for FFT
  	  // slightly revisited to rely on looping instead of recursion

  	  function FFTM (x, y) {
  	    this.x = x;
  	    this.y = y;
  	  }

  	  FFTM.prototype.makeRBT = function makeRBT (N) {
  	    var t = new Array(N);
  	    var l = BN.prototype._countBits(N) - 1;
  	    for (var i = 0; i < N; i++) {
  	      t[i] = this.revBin(i, l, N);
  	    }

  	    return t;
  	  };

  	  // Returns binary-reversed representation of `x`
  	  FFTM.prototype.revBin = function revBin (x, l, N) {
  	    if (x === 0 || x === N - 1) return x;

  	    var rb = 0;
  	    for (var i = 0; i < l; i++) {
  	      rb |= (x & 1) << (l - i - 1);
  	      x >>= 1;
  	    }

  	    return rb;
  	  };

  	  // Performs "tweedling" phase, therefore 'emulating'
  	  // behaviour of the recursive algorithm
  	  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
  	    for (var i = 0; i < N; i++) {
  	      rtws[i] = rws[rbt[i]];
  	      itws[i] = iws[rbt[i]];
  	    }
  	  };

  	  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
  	    this.permute(rbt, rws, iws, rtws, itws, N);

  	    for (var s = 1; s < N; s <<= 1) {
  	      var l = s << 1;

  	      var rtwdf = Math.cos(2 * Math.PI / l);
  	      var itwdf = Math.sin(2 * Math.PI / l);

  	      for (var p = 0; p < N; p += l) {
  	        var rtwdf_ = rtwdf;
  	        var itwdf_ = itwdf;

  	        for (var j = 0; j < s; j++) {
  	          var re = rtws[p + j];
  	          var ie = itws[p + j];

  	          var ro = rtws[p + j + s];
  	          var io = itws[p + j + s];

  	          var rx = rtwdf_ * ro - itwdf_ * io;

  	          io = rtwdf_ * io + itwdf_ * ro;
  	          ro = rx;

  	          rtws[p + j] = re + ro;
  	          itws[p + j] = ie + io;

  	          rtws[p + j + s] = re - ro;
  	          itws[p + j + s] = ie - io;

  	          /* jshint maxdepth : false */
  	          if (j !== l) {
  	            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

  	            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
  	            rtwdf_ = rx;
  	          }
  	        }
  	      }
  	    }
  	  };

  	  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
  	    var N = Math.max(m, n) | 1;
  	    var odd = N & 1;
  	    var i = 0;
  	    for (N = N / 2 | 0; N; N = N >>> 1) {
  	      i++;
  	    }

  	    return 1 << i + 1 + odd;
  	  };

  	  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
  	    if (N <= 1) return;

  	    for (var i = 0; i < N / 2; i++) {
  	      var t = rws[i];

  	      rws[i] = rws[N - i - 1];
  	      rws[N - i - 1] = t;

  	      t = iws[i];

  	      iws[i] = -iws[N - i - 1];
  	      iws[N - i - 1] = -t;
  	    }
  	  };

  	  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
  	    var carry = 0;
  	    for (var i = 0; i < N / 2; i++) {
  	      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
  	        Math.round(ws[2 * i] / N) +
  	        carry;

  	      ws[i] = w & 0x3ffffff;

  	      if (w < 0x4000000) {
  	        carry = 0;
  	      } else {
  	        carry = w / 0x4000000 | 0;
  	      }
  	    }

  	    return ws;
  	  };

  	  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
  	    var carry = 0;
  	    for (var i = 0; i < len; i++) {
  	      carry = carry + (ws[i] | 0);

  	      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
  	      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
  	    }

  	    // Pad with zeroes
  	    for (i = 2 * len; i < N; ++i) {
  	      rws[i] = 0;
  	    }

  	    assert(carry === 0);
  	    assert((carry & ~0x1fff) === 0);
  	  };

  	  FFTM.prototype.stub = function stub (N) {
  	    var ph = new Array(N);
  	    for (var i = 0; i < N; i++) {
  	      ph[i] = 0;
  	    }

  	    return ph;
  	  };

  	  FFTM.prototype.mulp = function mulp (x, y, out) {
  	    var N = 2 * this.guessLen13b(x.length, y.length);

  	    var rbt = this.makeRBT(N);

  	    var _ = this.stub(N);

  	    var rws = new Array(N);
  	    var rwst = new Array(N);
  	    var iwst = new Array(N);

  	    var nrws = new Array(N);
  	    var nrwst = new Array(N);
  	    var niwst = new Array(N);

  	    var rmws = out.words;
  	    rmws.length = N;

  	    this.convert13b(x.words, x.length, rws, N);
  	    this.convert13b(y.words, y.length, nrws, N);

  	    this.transform(rws, _, rwst, iwst, N, rbt);
  	    this.transform(nrws, _, nrwst, niwst, N, rbt);

  	    for (var i = 0; i < N; i++) {
  	      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
  	      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
  	      rwst[i] = rx;
  	    }

  	    this.conjugate(rwst, iwst, N);
  	    this.transform(rwst, iwst, rmws, _, N, rbt);
  	    this.conjugate(rmws, _, N);
  	    this.normalize13b(rmws, N);

  	    out.negative = x.negative ^ y.negative;
  	    out.length = x.length + y.length;
  	    return out.strip();
  	  };

  	  // Multiply `this` by `num`
  	  BN.prototype.mul = function mul (num) {
  	    var out = new BN(null);
  	    out.words = new Array(this.length + num.length);
  	    return this.mulTo(num, out);
  	  };

  	  // Multiply employing FFT
  	  BN.prototype.mulf = function mulf (num) {
  	    var out = new BN(null);
  	    out.words = new Array(this.length + num.length);
  	    return jumboMulTo(this, num, out);
  	  };

  	  // In-place Multiplication
  	  BN.prototype.imul = function imul (num) {
  	    return this.clone().mulTo(num, this);
  	  };

  	  BN.prototype.imuln = function imuln (num) {
  	    assert(typeof num === 'number');
  	    assert(num < 0x4000000);

  	    // Carry
  	    var carry = 0;
  	    for (var i = 0; i < this.length; i++) {
  	      var w = (this.words[i] | 0) * num;
  	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
  	      carry >>= 26;
  	      carry += (w / 0x4000000) | 0;
  	      // NOTE: lo is 27bit maximum
  	      carry += lo >>> 26;
  	      this.words[i] = lo & 0x3ffffff;
  	    }

  	    if (carry !== 0) {
  	      this.words[i] = carry;
  	      this.length++;
  	    }

  	    return this;
  	  };

  	  BN.prototype.muln = function muln (num) {
  	    return this.clone().imuln(num);
  	  };

  	  // `this` * `this`
  	  BN.prototype.sqr = function sqr () {
  	    return this.mul(this);
  	  };

  	  // `this` * `this` in-place
  	  BN.prototype.isqr = function isqr () {
  	    return this.imul(this.clone());
  	  };

  	  // Math.pow(`this`, `num`)
  	  BN.prototype.pow = function pow (num) {
  	    var w = toBitArray(num);
  	    if (w.length === 0) return new BN(1);

  	    // Skip leading zeroes
  	    var res = this;
  	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
  	      if (w[i] !== 0) break;
  	    }

  	    if (++i < w.length) {
  	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
  	        if (w[i] === 0) continue;

  	        res = res.mul(q);
  	      }
  	    }

  	    return res;
  	  };

  	  // Shift-left in-place
  	  BN.prototype.iushln = function iushln (bits) {
  	    assert(typeof bits === 'number' && bits >= 0);
  	    var r = bits % 26;
  	    var s = (bits - r) / 26;
  	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
  	    var i;

  	    if (r !== 0) {
  	      var carry = 0;

  	      for (i = 0; i < this.length; i++) {
  	        var newCarry = this.words[i] & carryMask;
  	        var c = ((this.words[i] | 0) - newCarry) << r;
  	        this.words[i] = c | carry;
  	        carry = newCarry >>> (26 - r);
  	      }

  	      if (carry) {
  	        this.words[i] = carry;
  	        this.length++;
  	      }
  	    }

  	    if (s !== 0) {
  	      for (i = this.length - 1; i >= 0; i--) {
  	        this.words[i + s] = this.words[i];
  	      }

  	      for (i = 0; i < s; i++) {
  	        this.words[i] = 0;
  	      }

  	      this.length += s;
  	    }

  	    return this.strip();
  	  };

  	  BN.prototype.ishln = function ishln (bits) {
  	    // TODO(indutny): implement me
  	    assert(this.negative === 0);
  	    return this.iushln(bits);
  	  };

  	  // Shift-right in-place
  	  // NOTE: `hint` is a lowest bit before trailing zeroes
  	  // NOTE: if `extended` is present - it will be filled with destroyed bits
  	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
  	    assert(typeof bits === 'number' && bits >= 0);
  	    var h;
  	    if (hint) {
  	      h = (hint - (hint % 26)) / 26;
  	    } else {
  	      h = 0;
  	    }

  	    var r = bits % 26;
  	    var s = Math.min((bits - r) / 26, this.length);
  	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  	    var maskedWords = extended;

  	    h -= s;
  	    h = Math.max(0, h);

  	    // Extended mode, copy masked part
  	    if (maskedWords) {
  	      for (var i = 0; i < s; i++) {
  	        maskedWords.words[i] = this.words[i];
  	      }
  	      maskedWords.length = s;
  	    }

  	    if (s === 0) ; else if (this.length > s) {
  	      this.length -= s;
  	      for (i = 0; i < this.length; i++) {
  	        this.words[i] = this.words[i + s];
  	      }
  	    } else {
  	      this.words[0] = 0;
  	      this.length = 1;
  	    }

  	    var carry = 0;
  	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
  	      var word = this.words[i] | 0;
  	      this.words[i] = (carry << (26 - r)) | (word >>> r);
  	      carry = word & mask;
  	    }

  	    // Push carried bits as a mask
  	    if (maskedWords && carry !== 0) {
  	      maskedWords.words[maskedWords.length++] = carry;
  	    }

  	    if (this.length === 0) {
  	      this.words[0] = 0;
  	      this.length = 1;
  	    }

  	    return this.strip();
  	  };

  	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
  	    // TODO(indutny): implement me
  	    assert(this.negative === 0);
  	    return this.iushrn(bits, hint, extended);
  	  };

  	  // Shift-left
  	  BN.prototype.shln = function shln (bits) {
  	    return this.clone().ishln(bits);
  	  };

  	  BN.prototype.ushln = function ushln (bits) {
  	    return this.clone().iushln(bits);
  	  };

  	  // Shift-right
  	  BN.prototype.shrn = function shrn (bits) {
  	    return this.clone().ishrn(bits);
  	  };

  	  BN.prototype.ushrn = function ushrn (bits) {
  	    return this.clone().iushrn(bits);
  	  };

  	  // Test if n bit is set
  	  BN.prototype.testn = function testn (bit) {
  	    assert(typeof bit === 'number' && bit >= 0);
  	    var r = bit % 26;
  	    var s = (bit - r) / 26;
  	    var q = 1 << r;

  	    // Fast case: bit is much higher than all existing words
  	    if (this.length <= s) return false;

  	    // Check bit and return
  	    var w = this.words[s];

  	    return !!(w & q);
  	  };

  	  // Return only lowers bits of number (in-place)
  	  BN.prototype.imaskn = function imaskn (bits) {
  	    assert(typeof bits === 'number' && bits >= 0);
  	    var r = bits % 26;
  	    var s = (bits - r) / 26;

  	    assert(this.negative === 0, 'imaskn works only with positive numbers');

  	    if (this.length <= s) {
  	      return this;
  	    }

  	    if (r !== 0) {
  	      s++;
  	    }
  	    this.length = Math.min(s, this.length);

  	    if (r !== 0) {
  	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  	      this.words[this.length - 1] &= mask;
  	    }

  	    return this.strip();
  	  };

  	  // Return only lowers bits of number
  	  BN.prototype.maskn = function maskn (bits) {
  	    return this.clone().imaskn(bits);
  	  };

  	  // Add plain number `num` to `this`
  	  BN.prototype.iaddn = function iaddn (num) {
  	    assert(typeof num === 'number');
  	    assert(num < 0x4000000);
  	    if (num < 0) return this.isubn(-num);

  	    // Possible sign change
  	    if (this.negative !== 0) {
  	      if (this.length === 1 && (this.words[0] | 0) < num) {
  	        this.words[0] = num - (this.words[0] | 0);
  	        this.negative = 0;
  	        return this;
  	      }

  	      this.negative = 0;
  	      this.isubn(num);
  	      this.negative = 1;
  	      return this;
  	    }

  	    // Add without checks
  	    return this._iaddn(num);
  	  };

  	  BN.prototype._iaddn = function _iaddn (num) {
  	    this.words[0] += num;

  	    // Carry
  	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
  	      this.words[i] -= 0x4000000;
  	      if (i === this.length - 1) {
  	        this.words[i + 1] = 1;
  	      } else {
  	        this.words[i + 1]++;
  	      }
  	    }
  	    this.length = Math.max(this.length, i + 1);

  	    return this;
  	  };

  	  // Subtract plain number `num` from `this`
  	  BN.prototype.isubn = function isubn (num) {
  	    assert(typeof num === 'number');
  	    assert(num < 0x4000000);
  	    if (num < 0) return this.iaddn(-num);

  	    if (this.negative !== 0) {
  	      this.negative = 0;
  	      this.iaddn(num);
  	      this.negative = 1;
  	      return this;
  	    }

  	    this.words[0] -= num;

  	    if (this.length === 1 && this.words[0] < 0) {
  	      this.words[0] = -this.words[0];
  	      this.negative = 1;
  	    } else {
  	      // Carry
  	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
  	        this.words[i] += 0x4000000;
  	        this.words[i + 1] -= 1;
  	      }
  	    }

  	    return this.strip();
  	  };

  	  BN.prototype.addn = function addn (num) {
  	    return this.clone().iaddn(num);
  	  };

  	  BN.prototype.subn = function subn (num) {
  	    return this.clone().isubn(num);
  	  };

  	  BN.prototype.iabs = function iabs () {
  	    this.negative = 0;

  	    return this;
  	  };

  	  BN.prototype.abs = function abs () {
  	    return this.clone().iabs();
  	  };

  	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
  	    var len = num.length + shift;
  	    var i;

  	    this._expand(len);

  	    var w;
  	    var carry = 0;
  	    for (i = 0; i < num.length; i++) {
  	      w = (this.words[i + shift] | 0) + carry;
  	      var right = (num.words[i] | 0) * mul;
  	      w -= right & 0x3ffffff;
  	      carry = (w >> 26) - ((right / 0x4000000) | 0);
  	      this.words[i + shift] = w & 0x3ffffff;
  	    }
  	    for (; i < this.length - shift; i++) {
  	      w = (this.words[i + shift] | 0) + carry;
  	      carry = w >> 26;
  	      this.words[i + shift] = w & 0x3ffffff;
  	    }

  	    if (carry === 0) return this.strip();

  	    // Subtraction overflow
  	    assert(carry === -1);
  	    carry = 0;
  	    for (i = 0; i < this.length; i++) {
  	      w = -(this.words[i] | 0) + carry;
  	      carry = w >> 26;
  	      this.words[i] = w & 0x3ffffff;
  	    }
  	    this.negative = 1;

  	    return this.strip();
  	  };

  	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
  	    var shift = this.length - num.length;

  	    var a = this.clone();
  	    var b = num;

  	    // Normalize
  	    var bhi = b.words[b.length - 1] | 0;
  	    var bhiBits = this._countBits(bhi);
  	    shift = 26 - bhiBits;
  	    if (shift !== 0) {
  	      b = b.ushln(shift);
  	      a.iushln(shift);
  	      bhi = b.words[b.length - 1] | 0;
  	    }

  	    // Initialize quotient
  	    var m = a.length - b.length;
  	    var q;

  	    if (mode !== 'mod') {
  	      q = new BN(null);
  	      q.length = m + 1;
  	      q.words = new Array(q.length);
  	      for (var i = 0; i < q.length; i++) {
  	        q.words[i] = 0;
  	      }
  	    }

  	    var diff = a.clone()._ishlnsubmul(b, 1, m);
  	    if (diff.negative === 0) {
  	      a = diff;
  	      if (q) {
  	        q.words[m] = 1;
  	      }
  	    }

  	    for (var j = m - 1; j >= 0; j--) {
  	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
  	        (a.words[b.length + j - 1] | 0);

  	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
  	      // (0x7ffffff)
  	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

  	      a._ishlnsubmul(b, qj, j);
  	      while (a.negative !== 0) {
  	        qj--;
  	        a.negative = 0;
  	        a._ishlnsubmul(b, 1, j);
  	        if (!a.isZero()) {
  	          a.negative ^= 1;
  	        }
  	      }
  	      if (q) {
  	        q.words[j] = qj;
  	      }
  	    }
  	    if (q) {
  	      q.strip();
  	    }
  	    a.strip();

  	    // Denormalize
  	    if (mode !== 'div' && shift !== 0) {
  	      a.iushrn(shift);
  	    }

  	    return {
  	      div: q || null,
  	      mod: a
  	    };
  	  };

  	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  	  //       to `div` to request div only, or be absent to
  	  //       request both div & mod
  	  //       2) `positive` is true if unsigned mod is requested
  	  BN.prototype.divmod = function divmod (num, mode, positive) {
  	    assert(!num.isZero());

  	    if (this.isZero()) {
  	      return {
  	        div: new BN(0),
  	        mod: new BN(0)
  	      };
  	    }

  	    var div, mod, res;
  	    if (this.negative !== 0 && num.negative === 0) {
  	      res = this.neg().divmod(num, mode);

  	      if (mode !== 'mod') {
  	        div = res.div.neg();
  	      }

  	      if (mode !== 'div') {
  	        mod = res.mod.neg();
  	        if (positive && mod.negative !== 0) {
  	          mod.iadd(num);
  	        }
  	      }

  	      return {
  	        div: div,
  	        mod: mod
  	      };
  	    }

  	    if (this.negative === 0 && num.negative !== 0) {
  	      res = this.divmod(num.neg(), mode);

  	      if (mode !== 'mod') {
  	        div = res.div.neg();
  	      }

  	      return {
  	        div: div,
  	        mod: res.mod
  	      };
  	    }

  	    if ((this.negative & num.negative) !== 0) {
  	      res = this.neg().divmod(num.neg(), mode);

  	      if (mode !== 'div') {
  	        mod = res.mod.neg();
  	        if (positive && mod.negative !== 0) {
  	          mod.isub(num);
  	        }
  	      }

  	      return {
  	        div: res.div,
  	        mod: mod
  	      };
  	    }

  	    // Both numbers are positive at this point

  	    // Strip both numbers to approximate shift value
  	    if (num.length > this.length || this.cmp(num) < 0) {
  	      return {
  	        div: new BN(0),
  	        mod: this
  	      };
  	    }

  	    // Very short reduction
  	    if (num.length === 1) {
  	      if (mode === 'div') {
  	        return {
  	          div: this.divn(num.words[0]),
  	          mod: null
  	        };
  	      }

  	      if (mode === 'mod') {
  	        return {
  	          div: null,
  	          mod: new BN(this.modn(num.words[0]))
  	        };
  	      }

  	      return {
  	        div: this.divn(num.words[0]),
  	        mod: new BN(this.modn(num.words[0]))
  	      };
  	    }

  	    return this._wordDiv(num, mode);
  	  };

  	  // Find `this` / `num`
  	  BN.prototype.div = function div (num) {
  	    return this.divmod(num, 'div', false).div;
  	  };

  	  // Find `this` % `num`
  	  BN.prototype.mod = function mod (num) {
  	    return this.divmod(num, 'mod', false).mod;
  	  };

  	  BN.prototype.umod = function umod (num) {
  	    return this.divmod(num, 'mod', true).mod;
  	  };

  	  // Find Round(`this` / `num`)
  	  BN.prototype.divRound = function divRound (num) {
  	    var dm = this.divmod(num);

  	    // Fast case - exact division
  	    if (dm.mod.isZero()) return dm.div;

  	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

  	    var half = num.ushrn(1);
  	    var r2 = num.andln(1);
  	    var cmp = mod.cmp(half);

  	    // Round down
  	    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

  	    // Round up
  	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  	  };

  	  BN.prototype.modn = function modn (num) {
  	    assert(num <= 0x3ffffff);
  	    var p = (1 << 26) % num;

  	    var acc = 0;
  	    for (var i = this.length - 1; i >= 0; i--) {
  	      acc = (p * acc + (this.words[i] | 0)) % num;
  	    }

  	    return acc;
  	  };

  	  // In-place division by number
  	  BN.prototype.idivn = function idivn (num) {
  	    assert(num <= 0x3ffffff);

  	    var carry = 0;
  	    for (var i = this.length - 1; i >= 0; i--) {
  	      var w = (this.words[i] | 0) + carry * 0x4000000;
  	      this.words[i] = (w / num) | 0;
  	      carry = w % num;
  	    }

  	    return this.strip();
  	  };

  	  BN.prototype.divn = function divn (num) {
  	    return this.clone().idivn(num);
  	  };

  	  BN.prototype.egcd = function egcd (p) {
  	    assert(p.negative === 0);
  	    assert(!p.isZero());

  	    var x = this;
  	    var y = p.clone();

  	    if (x.negative !== 0) {
  	      x = x.umod(p);
  	    } else {
  	      x = x.clone();
  	    }

  	    // A * x + B * y = x
  	    var A = new BN(1);
  	    var B = new BN(0);

  	    // C * x + D * y = y
  	    var C = new BN(0);
  	    var D = new BN(1);

  	    var g = 0;

  	    while (x.isEven() && y.isEven()) {
  	      x.iushrn(1);
  	      y.iushrn(1);
  	      ++g;
  	    }

  	    var yp = y.clone();
  	    var xp = x.clone();

  	    while (!x.isZero()) {
  	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
  	      if (i > 0) {
  	        x.iushrn(i);
  	        while (i-- > 0) {
  	          if (A.isOdd() || B.isOdd()) {
  	            A.iadd(yp);
  	            B.isub(xp);
  	          }

  	          A.iushrn(1);
  	          B.iushrn(1);
  	        }
  	      }

  	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
  	      if (j > 0) {
  	        y.iushrn(j);
  	        while (j-- > 0) {
  	          if (C.isOdd() || D.isOdd()) {
  	            C.iadd(yp);
  	            D.isub(xp);
  	          }

  	          C.iushrn(1);
  	          D.iushrn(1);
  	        }
  	      }

  	      if (x.cmp(y) >= 0) {
  	        x.isub(y);
  	        A.isub(C);
  	        B.isub(D);
  	      } else {
  	        y.isub(x);
  	        C.isub(A);
  	        D.isub(B);
  	      }
  	    }

  	    return {
  	      a: C,
  	      b: D,
  	      gcd: y.iushln(g)
  	    };
  	  };

  	  // This is reduced incarnation of the binary EEA
  	  // above, designated to invert members of the
  	  // _prime_ fields F(p) at a maximal speed
  	  BN.prototype._invmp = function _invmp (p) {
  	    assert(p.negative === 0);
  	    assert(!p.isZero());

  	    var a = this;
  	    var b = p.clone();

  	    if (a.negative !== 0) {
  	      a = a.umod(p);
  	    } else {
  	      a = a.clone();
  	    }

  	    var x1 = new BN(1);
  	    var x2 = new BN(0);

  	    var delta = b.clone();

  	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
  	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
  	      if (i > 0) {
  	        a.iushrn(i);
  	        while (i-- > 0) {
  	          if (x1.isOdd()) {
  	            x1.iadd(delta);
  	          }

  	          x1.iushrn(1);
  	        }
  	      }

  	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
  	      if (j > 0) {
  	        b.iushrn(j);
  	        while (j-- > 0) {
  	          if (x2.isOdd()) {
  	            x2.iadd(delta);
  	          }

  	          x2.iushrn(1);
  	        }
  	      }

  	      if (a.cmp(b) >= 0) {
  	        a.isub(b);
  	        x1.isub(x2);
  	      } else {
  	        b.isub(a);
  	        x2.isub(x1);
  	      }
  	    }

  	    var res;
  	    if (a.cmpn(1) === 0) {
  	      res = x1;
  	    } else {
  	      res = x2;
  	    }

  	    if (res.cmpn(0) < 0) {
  	      res.iadd(p);
  	    }

  	    return res;
  	  };

  	  BN.prototype.gcd = function gcd (num) {
  	    if (this.isZero()) return num.abs();
  	    if (num.isZero()) return this.abs();

  	    var a = this.clone();
  	    var b = num.clone();
  	    a.negative = 0;
  	    b.negative = 0;

  	    // Remove common factor of two
  	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
  	      a.iushrn(1);
  	      b.iushrn(1);
  	    }

  	    do {
  	      while (a.isEven()) {
  	        a.iushrn(1);
  	      }
  	      while (b.isEven()) {
  	        b.iushrn(1);
  	      }

  	      var r = a.cmp(b);
  	      if (r < 0) {
  	        // Swap `a` and `b` to make `a` always bigger than `b`
  	        var t = a;
  	        a = b;
  	        b = t;
  	      } else if (r === 0 || b.cmpn(1) === 0) {
  	        break;
  	      }

  	      a.isub(b);
  	    } while (true);

  	    return b.iushln(shift);
  	  };

  	  // Invert number in the field F(num)
  	  BN.prototype.invm = function invm (num) {
  	    return this.egcd(num).a.umod(num);
  	  };

  	  BN.prototype.isEven = function isEven () {
  	    return (this.words[0] & 1) === 0;
  	  };

  	  BN.prototype.isOdd = function isOdd () {
  	    return (this.words[0] & 1) === 1;
  	  };

  	  // And first word and num
  	  BN.prototype.andln = function andln (num) {
  	    return this.words[0] & num;
  	  };

  	  // Increment at the bit position in-line
  	  BN.prototype.bincn = function bincn (bit) {
  	    assert(typeof bit === 'number');
  	    var r = bit % 26;
  	    var s = (bit - r) / 26;
  	    var q = 1 << r;

  	    // Fast case: bit is much higher than all existing words
  	    if (this.length <= s) {
  	      this._expand(s + 1);
  	      this.words[s] |= q;
  	      return this;
  	    }

  	    // Add bit and propagate, if needed
  	    var carry = q;
  	    for (var i = s; carry !== 0 && i < this.length; i++) {
  	      var w = this.words[i] | 0;
  	      w += carry;
  	      carry = w >>> 26;
  	      w &= 0x3ffffff;
  	      this.words[i] = w;
  	    }
  	    if (carry !== 0) {
  	      this.words[i] = carry;
  	      this.length++;
  	    }
  	    return this;
  	  };

  	  BN.prototype.isZero = function isZero () {
  	    return this.length === 1 && this.words[0] === 0;
  	  };

  	  BN.prototype.cmpn = function cmpn (num) {
  	    var negative = num < 0;

  	    if (this.negative !== 0 && !negative) return -1;
  	    if (this.negative === 0 && negative) return 1;

  	    this.strip();

  	    var res;
  	    if (this.length > 1) {
  	      res = 1;
  	    } else {
  	      if (negative) {
  	        num = -num;
  	      }

  	      assert(num <= 0x3ffffff, 'Number is too big');

  	      var w = this.words[0] | 0;
  	      res = w === num ? 0 : w < num ? -1 : 1;
  	    }
  	    if (this.negative !== 0) return -res | 0;
  	    return res;
  	  };

  	  // Compare two numbers and return:
  	  // 1 - if `this` > `num`
  	  // 0 - if `this` == `num`
  	  // -1 - if `this` < `num`
  	  BN.prototype.cmp = function cmp (num) {
  	    if (this.negative !== 0 && num.negative === 0) return -1;
  	    if (this.negative === 0 && num.negative !== 0) return 1;

  	    var res = this.ucmp(num);
  	    if (this.negative !== 0) return -res | 0;
  	    return res;
  	  };

  	  // Unsigned comparison
  	  BN.prototype.ucmp = function ucmp (num) {
  	    // At this point both numbers have the same sign
  	    if (this.length > num.length) return 1;
  	    if (this.length < num.length) return -1;

  	    var res = 0;
  	    for (var i = this.length - 1; i >= 0; i--) {
  	      var a = this.words[i] | 0;
  	      var b = num.words[i] | 0;

  	      if (a === b) continue;
  	      if (a < b) {
  	        res = -1;
  	      } else if (a > b) {
  	        res = 1;
  	      }
  	      break;
  	    }
  	    return res;
  	  };

  	  BN.prototype.gtn = function gtn (num) {
  	    return this.cmpn(num) === 1;
  	  };

  	  BN.prototype.gt = function gt (num) {
  	    return this.cmp(num) === 1;
  	  };

  	  BN.prototype.gten = function gten (num) {
  	    return this.cmpn(num) >= 0;
  	  };

  	  BN.prototype.gte = function gte (num) {
  	    return this.cmp(num) >= 0;
  	  };

  	  BN.prototype.ltn = function ltn (num) {
  	    return this.cmpn(num) === -1;
  	  };

  	  BN.prototype.lt = function lt (num) {
  	    return this.cmp(num) === -1;
  	  };

  	  BN.prototype.lten = function lten (num) {
  	    return this.cmpn(num) <= 0;
  	  };

  	  BN.prototype.lte = function lte (num) {
  	    return this.cmp(num) <= 0;
  	  };

  	  BN.prototype.eqn = function eqn (num) {
  	    return this.cmpn(num) === 0;
  	  };

  	  BN.prototype.eq = function eq (num) {
  	    return this.cmp(num) === 0;
  	  };

  	  //
  	  // A reduce context, could be using montgomery or something better, depending
  	  // on the `m` itself.
  	  //
  	  BN.red = function red (num) {
  	    return new Red(num);
  	  };

  	  BN.prototype.toRed = function toRed (ctx) {
  	    assert(!this.red, 'Already a number in reduction context');
  	    assert(this.negative === 0, 'red works only with positives');
  	    return ctx.convertTo(this)._forceRed(ctx);
  	  };

  	  BN.prototype.fromRed = function fromRed () {
  	    assert(this.red, 'fromRed works only with numbers in reduction context');
  	    return this.red.convertFrom(this);
  	  };

  	  BN.prototype._forceRed = function _forceRed (ctx) {
  	    this.red = ctx;
  	    return this;
  	  };

  	  BN.prototype.forceRed = function forceRed (ctx) {
  	    assert(!this.red, 'Already a number in reduction context');
  	    return this._forceRed(ctx);
  	  };

  	  BN.prototype.redAdd = function redAdd (num) {
  	    assert(this.red, 'redAdd works only with red numbers');
  	    return this.red.add(this, num);
  	  };

  	  BN.prototype.redIAdd = function redIAdd (num) {
  	    assert(this.red, 'redIAdd works only with red numbers');
  	    return this.red.iadd(this, num);
  	  };

  	  BN.prototype.redSub = function redSub (num) {
  	    assert(this.red, 'redSub works only with red numbers');
  	    return this.red.sub(this, num);
  	  };

  	  BN.prototype.redISub = function redISub (num) {
  	    assert(this.red, 'redISub works only with red numbers');
  	    return this.red.isub(this, num);
  	  };

  	  BN.prototype.redShl = function redShl (num) {
  	    assert(this.red, 'redShl works only with red numbers');
  	    return this.red.shl(this, num);
  	  };

  	  BN.prototype.redMul = function redMul (num) {
  	    assert(this.red, 'redMul works only with red numbers');
  	    this.red._verify2(this, num);
  	    return this.red.mul(this, num);
  	  };

  	  BN.prototype.redIMul = function redIMul (num) {
  	    assert(this.red, 'redMul works only with red numbers');
  	    this.red._verify2(this, num);
  	    return this.red.imul(this, num);
  	  };

  	  BN.prototype.redSqr = function redSqr () {
  	    assert(this.red, 'redSqr works only with red numbers');
  	    this.red._verify1(this);
  	    return this.red.sqr(this);
  	  };

  	  BN.prototype.redISqr = function redISqr () {
  	    assert(this.red, 'redISqr works only with red numbers');
  	    this.red._verify1(this);
  	    return this.red.isqr(this);
  	  };

  	  // Square root over p
  	  BN.prototype.redSqrt = function redSqrt () {
  	    assert(this.red, 'redSqrt works only with red numbers');
  	    this.red._verify1(this);
  	    return this.red.sqrt(this);
  	  };

  	  BN.prototype.redInvm = function redInvm () {
  	    assert(this.red, 'redInvm works only with red numbers');
  	    this.red._verify1(this);
  	    return this.red.invm(this);
  	  };

  	  // Return negative clone of `this` % `red modulo`
  	  BN.prototype.redNeg = function redNeg () {
  	    assert(this.red, 'redNeg works only with red numbers');
  	    this.red._verify1(this);
  	    return this.red.neg(this);
  	  };

  	  BN.prototype.redPow = function redPow (num) {
  	    assert(this.red && !num.red, 'redPow(normalNum)');
  	    this.red._verify1(this);
  	    return this.red.pow(this, num);
  	  };

  	  // Prime numbers with efficient reduction
  	  var primes = {
  	    k256: null,
  	    p224: null,
  	    p192: null,
  	    p25519: null
  	  };

  	  // Pseudo-Mersenne prime
  	  function MPrime (name, p) {
  	    // P = 2 ^ N - K
  	    this.name = name;
  	    this.p = new BN(p, 16);
  	    this.n = this.p.bitLength();
  	    this.k = new BN(1).iushln(this.n).isub(this.p);

  	    this.tmp = this._tmp();
  	  }

  	  MPrime.prototype._tmp = function _tmp () {
  	    var tmp = new BN(null);
  	    tmp.words = new Array(Math.ceil(this.n / 13));
  	    return tmp;
  	  };

  	  MPrime.prototype.ireduce = function ireduce (num) {
  	    // Assumes that `num` is less than `P^2`
  	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  	    var r = num;
  	    var rlen;

  	    do {
  	      this.split(r, this.tmp);
  	      r = this.imulK(r);
  	      r = r.iadd(this.tmp);
  	      rlen = r.bitLength();
  	    } while (rlen > this.n);

  	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
  	    if (cmp === 0) {
  	      r.words[0] = 0;
  	      r.length = 1;
  	    } else if (cmp > 0) {
  	      r.isub(this.p);
  	    } else {
  	      r.strip();
  	    }

  	    return r;
  	  };

  	  MPrime.prototype.split = function split (input, out) {
  	    input.iushrn(this.n, 0, out);
  	  };

  	  MPrime.prototype.imulK = function imulK (num) {
  	    return num.imul(this.k);
  	  };

  	  function K256 () {
  	    MPrime.call(
  	      this,
  	      'k256',
  	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  	  }
  	  inherits(K256, MPrime);

  	  K256.prototype.split = function split (input, output) {
  	    // 256 = 9 * 26 + 22
  	    var mask = 0x3fffff;

  	    var outLen = Math.min(input.length, 9);
  	    for (var i = 0; i < outLen; i++) {
  	      output.words[i] = input.words[i];
  	    }
  	    output.length = outLen;

  	    if (input.length <= 9) {
  	      input.words[0] = 0;
  	      input.length = 1;
  	      return;
  	    }

  	    // Shift by 9 limbs
  	    var prev = input.words[9];
  	    output.words[output.length++] = prev & mask;

  	    for (i = 10; i < input.length; i++) {
  	      var next = input.words[i] | 0;
  	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
  	      prev = next;
  	    }
  	    prev >>>= 22;
  	    input.words[i - 10] = prev;
  	    if (prev === 0 && input.length > 10) {
  	      input.length -= 10;
  	    } else {
  	      input.length -= 9;
  	    }
  	  };

  	  K256.prototype.imulK = function imulK (num) {
  	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  	    num.words[num.length] = 0;
  	    num.words[num.length + 1] = 0;
  	    num.length += 2;

  	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
  	    var lo = 0;
  	    for (var i = 0; i < num.length; i++) {
  	      var w = num.words[i] | 0;
  	      lo += w * 0x3d1;
  	      num.words[i] = lo & 0x3ffffff;
  	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
  	    }

  	    // Fast length reduction
  	    if (num.words[num.length - 1] === 0) {
  	      num.length--;
  	      if (num.words[num.length - 1] === 0) {
  	        num.length--;
  	      }
  	    }
  	    return num;
  	  };

  	  function P224 () {
  	    MPrime.call(
  	      this,
  	      'p224',
  	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  	  }
  	  inherits(P224, MPrime);

  	  function P192 () {
  	    MPrime.call(
  	      this,
  	      'p192',
  	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  	  }
  	  inherits(P192, MPrime);

  	  function P25519 () {
  	    // 2 ^ 255 - 19
  	    MPrime.call(
  	      this,
  	      '25519',
  	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  	  }
  	  inherits(P25519, MPrime);

  	  P25519.prototype.imulK = function imulK (num) {
  	    // K = 0x13
  	    var carry = 0;
  	    for (var i = 0; i < num.length; i++) {
  	      var hi = (num.words[i] | 0) * 0x13 + carry;
  	      var lo = hi & 0x3ffffff;
  	      hi >>>= 26;

  	      num.words[i] = lo;
  	      carry = hi;
  	    }
  	    if (carry !== 0) {
  	      num.words[num.length++] = carry;
  	    }
  	    return num;
  	  };

  	  // Exported mostly for testing purposes, use plain name instead
  	  BN._prime = function prime (name) {
  	    // Cached version of prime
  	    if (primes[name]) return primes[name];

  	    var prime;
  	    if (name === 'k256') {
  	      prime = new K256();
  	    } else if (name === 'p224') {
  	      prime = new P224();
  	    } else if (name === 'p192') {
  	      prime = new P192();
  	    } else if (name === 'p25519') {
  	      prime = new P25519();
  	    } else {
  	      throw new Error('Unknown prime ' + name);
  	    }
  	    primes[name] = prime;

  	    return prime;
  	  };

  	  //
  	  // Base reduction engine
  	  //
  	  function Red (m) {
  	    if (typeof m === 'string') {
  	      var prime = BN._prime(m);
  	      this.m = prime.p;
  	      this.prime = prime;
  	    } else {
  	      assert(m.gtn(1), 'modulus must be greater than 1');
  	      this.m = m;
  	      this.prime = null;
  	    }
  	  }

  	  Red.prototype._verify1 = function _verify1 (a) {
  	    assert(a.negative === 0, 'red works only with positives');
  	    assert(a.red, 'red works only with red numbers');
  	  };

  	  Red.prototype._verify2 = function _verify2 (a, b) {
  	    assert((a.negative | b.negative) === 0, 'red works only with positives');
  	    assert(a.red && a.red === b.red,
  	      'red works only with red numbers');
  	  };

  	  Red.prototype.imod = function imod (a) {
  	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
  	    return a.umod(this.m)._forceRed(this);
  	  };

  	  Red.prototype.neg = function neg (a) {
  	    if (a.isZero()) {
  	      return a.clone();
  	    }

  	    return this.m.sub(a)._forceRed(this);
  	  };

  	  Red.prototype.add = function add (a, b) {
  	    this._verify2(a, b);

  	    var res = a.add(b);
  	    if (res.cmp(this.m) >= 0) {
  	      res.isub(this.m);
  	    }
  	    return res._forceRed(this);
  	  };

  	  Red.prototype.iadd = function iadd (a, b) {
  	    this._verify2(a, b);

  	    var res = a.iadd(b);
  	    if (res.cmp(this.m) >= 0) {
  	      res.isub(this.m);
  	    }
  	    return res;
  	  };

  	  Red.prototype.sub = function sub (a, b) {
  	    this._verify2(a, b);

  	    var res = a.sub(b);
  	    if (res.cmpn(0) < 0) {
  	      res.iadd(this.m);
  	    }
  	    return res._forceRed(this);
  	  };

  	  Red.prototype.isub = function isub (a, b) {
  	    this._verify2(a, b);

  	    var res = a.isub(b);
  	    if (res.cmpn(0) < 0) {
  	      res.iadd(this.m);
  	    }
  	    return res;
  	  };

  	  Red.prototype.shl = function shl (a, num) {
  	    this._verify1(a);
  	    return this.imod(a.ushln(num));
  	  };

  	  Red.prototype.imul = function imul (a, b) {
  	    this._verify2(a, b);
  	    return this.imod(a.imul(b));
  	  };

  	  Red.prototype.mul = function mul (a, b) {
  	    this._verify2(a, b);
  	    return this.imod(a.mul(b));
  	  };

  	  Red.prototype.isqr = function isqr (a) {
  	    return this.imul(a, a.clone());
  	  };

  	  Red.prototype.sqr = function sqr (a) {
  	    return this.mul(a, a);
  	  };

  	  Red.prototype.sqrt = function sqrt (a) {
  	    if (a.isZero()) return a.clone();

  	    var mod3 = this.m.andln(3);
  	    assert(mod3 % 2 === 1);

  	    // Fast case
  	    if (mod3 === 3) {
  	      var pow = this.m.add(new BN(1)).iushrn(2);
  	      return this.pow(a, pow);
  	    }

  	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  	    //
  	    // Find Q and S, that Q * 2 ^ S = (P - 1)
  	    var q = this.m.subn(1);
  	    var s = 0;
  	    while (!q.isZero() && q.andln(1) === 0) {
  	      s++;
  	      q.iushrn(1);
  	    }
  	    assert(!q.isZero());

  	    var one = new BN(1).toRed(this);
  	    var nOne = one.redNeg();

  	    // Find quadratic non-residue
  	    // NOTE: Max is such because of generalized Riemann hypothesis.
  	    var lpow = this.m.subn(1).iushrn(1);
  	    var z = this.m.bitLength();
  	    z = new BN(2 * z * z).toRed(this);

  	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
  	      z.redIAdd(nOne);
  	    }

  	    var c = this.pow(z, q);
  	    var r = this.pow(a, q.addn(1).iushrn(1));
  	    var t = this.pow(a, q);
  	    var m = s;
  	    while (t.cmp(one) !== 0) {
  	      var tmp = t;
  	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
  	        tmp = tmp.redSqr();
  	      }
  	      assert(i < m);
  	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

  	      r = r.redMul(b);
  	      c = b.redSqr();
  	      t = t.redMul(c);
  	      m = i;
  	    }

  	    return r;
  	  };

  	  Red.prototype.invm = function invm (a) {
  	    var inv = a._invmp(this.m);
  	    if (inv.negative !== 0) {
  	      inv.negative = 0;
  	      return this.imod(inv).redNeg();
  	    } else {
  	      return this.imod(inv);
  	    }
  	  };

  	  Red.prototype.pow = function pow (a, num) {
  	    if (num.isZero()) return new BN(1).toRed(this);
  	    if (num.cmpn(1) === 0) return a.clone();

  	    var windowSize = 4;
  	    var wnd = new Array(1 << windowSize);
  	    wnd[0] = new BN(1).toRed(this);
  	    wnd[1] = a;
  	    for (var i = 2; i < wnd.length; i++) {
  	      wnd[i] = this.mul(wnd[i - 1], a);
  	    }

  	    var res = wnd[0];
  	    var current = 0;
  	    var currentLen = 0;
  	    var start = num.bitLength() % 26;
  	    if (start === 0) {
  	      start = 26;
  	    }

  	    for (i = num.length - 1; i >= 0; i--) {
  	      var word = num.words[i];
  	      for (var j = start - 1; j >= 0; j--) {
  	        var bit = (word >> j) & 1;
  	        if (res !== wnd[0]) {
  	          res = this.sqr(res);
  	        }

  	        if (bit === 0 && current === 0) {
  	          currentLen = 0;
  	          continue;
  	        }

  	        current <<= 1;
  	        current |= bit;
  	        currentLen++;
  	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

  	        res = this.mul(res, wnd[current]);
  	        currentLen = 0;
  	        current = 0;
  	      }
  	      start = 26;
  	    }

  	    return res;
  	  };

  	  Red.prototype.convertTo = function convertTo (num) {
  	    var r = num.umod(this.m);

  	    return r === num ? r.clone() : r;
  	  };

  	  Red.prototype.convertFrom = function convertFrom (num) {
  	    var res = num.clone();
  	    res.red = null;
  	    return res;
  	  };

  	  //
  	  // Montgomery method engine
  	  //

  	  BN.mont = function mont (num) {
  	    return new Mont(num);
  	  };

  	  function Mont (m) {
  	    Red.call(this, m);

  	    this.shift = this.m.bitLength();
  	    if (this.shift % 26 !== 0) {
  	      this.shift += 26 - (this.shift % 26);
  	    }

  	    this.r = new BN(1).iushln(this.shift);
  	    this.r2 = this.imod(this.r.sqr());
  	    this.rinv = this.r._invmp(this.m);

  	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  	    this.minv = this.minv.umod(this.r);
  	    this.minv = this.r.sub(this.minv);
  	  }
  	  inherits(Mont, Red);

  	  Mont.prototype.convertTo = function convertTo (num) {
  	    return this.imod(num.ushln(this.shift));
  	  };

  	  Mont.prototype.convertFrom = function convertFrom (num) {
  	    var r = this.imod(num.mul(this.rinv));
  	    r.red = null;
  	    return r;
  	  };

  	  Mont.prototype.imul = function imul (a, b) {
  	    if (a.isZero() || b.isZero()) {
  	      a.words[0] = 0;
  	      a.length = 1;
  	      return a;
  	    }

  	    var t = a.imul(b);
  	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  	    var u = t.isub(c).iushrn(this.shift);
  	    var res = u;

  	    if (u.cmp(this.m) >= 0) {
  	      res = u.isub(this.m);
  	    } else if (u.cmpn(0) < 0) {
  	      res = u.iadd(this.m);
  	    }

  	    return res._forceRed(this);
  	  };

  	  Mont.prototype.mul = function mul (a, b) {
  	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

  	    var t = a.mul(b);
  	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  	    var u = t.isub(c).iushrn(this.shift);
  	    var res = u;
  	    if (u.cmp(this.m) >= 0) {
  	      res = u.isub(this.m);
  	    } else if (u.cmpn(0) < 0) {
  	      res = u.iadd(this.m);
  	    }

  	    return res._forceRed(this);
  	  };

  	  Mont.prototype.invm = function invm (a) {
  	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  	    var res = this.imod(a._invmp(this.m).mul(this.r2));
  	    return res._forceRed(this);
  	  };
  	})(module, commonjsGlobal);
  } (bn));

  var BN = bn.exports;

  var cjs$1 = {};

  var isTypedarray      = isTypedArray$2;
  isTypedArray$2.strict = isStrictTypedArray;
  isTypedArray$2.loose  = isLooseTypedArray;

  var toString = Object.prototype.toString;
  var names = {
      '[object Int8Array]': true
    , '[object Int16Array]': true
    , '[object Int32Array]': true
    , '[object Uint8Array]': true
    , '[object Uint8ClampedArray]': true
    , '[object Uint16Array]': true
    , '[object Uint32Array]': true
    , '[object Float32Array]': true
    , '[object Float64Array]': true
  };

  function isTypedArray$2(arr) {
    return (
         isStrictTypedArray(arr)
      || isLooseTypedArray(arr)
    )
  }

  function isStrictTypedArray(arr) {
    return (
         arr instanceof Int8Array
      || arr instanceof Int16Array
      || arr instanceof Int32Array
      || arr instanceof Uint8Array
      || arr instanceof Uint8ClampedArray
      || arr instanceof Uint16Array
      || arr instanceof Uint32Array
      || arr instanceof Float32Array
      || arr instanceof Float64Array
    )
  }

  function isLooseTypedArray(arr) {
    return names[toString.call(arr)]
  }

  var isTypedArray$1 = isTypedarray.strict;

  var typedarrayToBuffer = function typedarrayToBuffer (arr) {
    if (isTypedArray$1(arr)) {
      // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
      var buf = Buffer.from(arr.buffer);
      if (arr.byteLength !== arr.buffer.byteLength) {
        // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
        buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
      }
      return buf
    } else {
      // Pass through all other types to `Buffer.from`
      return Buffer.from(arr)
    }
  };

  var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(cjs$1, "__esModule", { value: true });
  var removeHexLeadingZeros_1 = cjs$1.removeHexLeadingZeros = sanitizeHex_1 = cjs$1.sanitizeHex = addHexPrefix_1 = cjs$1.addHexPrefix = removeHexPrefix_1 = cjs$1.removeHexPrefix = cjs$1.padRight = cjs$1.padLeft = cjs$1.sanitizeBytes = cjs$1.swapHex = cjs$1.swapBytes = cjs$1.splitBytes = cjs$1.calcByteLength = cjs$1.trimRight = cjs$1.trimLeft = concatArrays_1 = cjs$1.concatArrays = cjs$1.concatBuffers = cjs$1.getEncoding = cjs$1.getType = cjs$1.isArrayBuffer = cjs$1.isTypedArray = cjs$1.isBuffer = isHexString_1 = cjs$1.isHexString = cjs$1.isBinaryString = cjs$1.binaryToNumber = cjs$1.binaryToUtf8 = cjs$1.binaryToHex = cjs$1.binaryToArray = cjs$1.binaryToBuffer = cjs$1.numberToBinary = cjs$1.numberToUtf8 = cjs$1.numberToHex = cjs$1.numberToArray = cjs$1.numberToBuffer = cjs$1.utf8ToBinary = cjs$1.utf8ToNumber = utf8ToHex_1 = cjs$1.utf8ToHex = utf8ToArray_1 = cjs$1.utf8ToArray = utf8ToBuffer_1 = cjs$1.utf8ToBuffer = cjs$1.hexToBinary = cjs$1.hexToNumber = cjs$1.hexToUtf8 = hexToArray_1 = cjs$1.hexToArray = cjs$1.hexToBuffer = cjs$1.arrayToBinary = cjs$1.arrayToNumber = arrayToUtf8_1 = cjs$1.arrayToUtf8 = arrayToHex_1 = cjs$1.arrayToHex = arrayToBuffer_1 = cjs$1.arrayToBuffer = cjs$1.bufferToBinary = cjs$1.bufferToNumber = cjs$1.bufferToUtf8 = cjs$1.bufferToHex = bufferToArray_1 = cjs$1.bufferToArray = void 0;
  const is_typedarray_1 = __importDefault$1(isTypedarray);
  const typedarray_to_buffer_1 = __importDefault$1(typedarrayToBuffer);
  const ENC_HEX = "hex";
  const ENC_UTF8 = "utf8";
  const ENC_BIN = "binary";
  const TYPE_BUFFER = "buffer";
  const TYPE_ARRAY = "array";
  const TYPE_TYPED_ARRAY = "typed-array";
  const TYPE_ARRAY_BUFFER = "array-buffer";
  const STRING_ZERO = "0";
  function bufferToArray(buf) {
      return new Uint8Array(buf);
  }
  var bufferToArray_1 = cjs$1.bufferToArray = bufferToArray;
  function bufferToHex(buf, prefixed = false) {
      const hex = buf.toString(ENC_HEX);
      return prefixed ? addHexPrefix(hex) : hex;
  }
  cjs$1.bufferToHex = bufferToHex;
  function bufferToUtf8(buf) {
      return buf.toString(ENC_UTF8);
  }
  cjs$1.bufferToUtf8 = bufferToUtf8;
  function bufferToNumber(buf) {
      return buf.readUIntBE(0, buf.length);
  }
  cjs$1.bufferToNumber = bufferToNumber;
  function bufferToBinary(buf) {
      return arrayToBinary(bufferToArray(buf));
  }
  cjs$1.bufferToBinary = bufferToBinary;
  function arrayToBuffer(arr) {
      return typedarray_to_buffer_1.default(arr);
  }
  var arrayToBuffer_1 = cjs$1.arrayToBuffer = arrayToBuffer;
  function arrayToHex(arr, prefixed = false) {
      return bufferToHex(arrayToBuffer(arr), prefixed);
  }
  var arrayToHex_1 = cjs$1.arrayToHex = arrayToHex;
  function arrayToUtf8(arr) {
      return bufferToUtf8(arrayToBuffer(arr));
  }
  var arrayToUtf8_1 = cjs$1.arrayToUtf8 = arrayToUtf8;
  function arrayToNumber(arr) {
      return bufferToNumber(arrayToBuffer(arr));
  }
  cjs$1.arrayToNumber = arrayToNumber;
  function arrayToBinary(arr) {
      return Array.from(arr)
          .map(numberToBinary)
          .join("");
  }
  cjs$1.arrayToBinary = arrayToBinary;
  function hexToBuffer(hex) {
      return Buffer.from(removeHexPrefix(hex), ENC_HEX);
  }
  cjs$1.hexToBuffer = hexToBuffer;
  function hexToArray(hex) {
      return bufferToArray(hexToBuffer(hex));
  }
  var hexToArray_1 = cjs$1.hexToArray = hexToArray;
  function hexToUtf8(hex) {
      return bufferToUtf8(hexToBuffer(hex));
  }
  cjs$1.hexToUtf8 = hexToUtf8;
  function hexToNumber(hex) {
      return arrayToNumber(hexToArray(hex));
  }
  cjs$1.hexToNumber = hexToNumber;
  function hexToBinary(hex) {
      return arrayToBinary(hexToArray(hex));
  }
  cjs$1.hexToBinary = hexToBinary;
  function utf8ToBuffer(utf8) {
      return Buffer.from(utf8, ENC_UTF8);
  }
  var utf8ToBuffer_1 = cjs$1.utf8ToBuffer = utf8ToBuffer;
  function utf8ToArray(utf8) {
      return bufferToArray(utf8ToBuffer(utf8));
  }
  var utf8ToArray_1 = cjs$1.utf8ToArray = utf8ToArray;
  function utf8ToHex(utf8, prefixed = false) {
      return bufferToHex(utf8ToBuffer(utf8), prefixed);
  }
  var utf8ToHex_1 = cjs$1.utf8ToHex = utf8ToHex;
  function utf8ToNumber(utf8) {
      const num = parseInt(utf8, 10);
      assert(isDefined(num), "Number can only safely store up to 53 bits");
      return num;
  }
  cjs$1.utf8ToNumber = utf8ToNumber;
  function utf8ToBinary(utf8) {
      return arrayToBinary(utf8ToArray(utf8));
  }
  cjs$1.utf8ToBinary = utf8ToBinary;
  function numberToBuffer(num) {
      return binaryToBuffer(numberToBinary(num));
  }
  cjs$1.numberToBuffer = numberToBuffer;
  function numberToArray(num) {
      return binaryToArray(numberToBinary(num));
  }
  cjs$1.numberToArray = numberToArray;
  function numberToHex(num, prefixed) {
      return binaryToHex(numberToBinary(num), prefixed);
  }
  cjs$1.numberToHex = numberToHex;
  function numberToUtf8(num) {
      return `${num}`;
  }
  cjs$1.numberToUtf8 = numberToUtf8;
  function numberToBinary(num) {
      const bin = (num >>> 0).toString(2);
      return sanitizeBytes(bin);
  }
  cjs$1.numberToBinary = numberToBinary;
  function binaryToBuffer(bin) {
      return arrayToBuffer(binaryToArray(bin));
  }
  cjs$1.binaryToBuffer = binaryToBuffer;
  function binaryToArray(bin) {
      return new Uint8Array(splitBytes(bin).map(x => parseInt(x, 2)));
  }
  cjs$1.binaryToArray = binaryToArray;
  function binaryToHex(bin, prefixed) {
      return arrayToHex(binaryToArray(bin), prefixed);
  }
  cjs$1.binaryToHex = binaryToHex;
  function binaryToUtf8(bin) {
      return arrayToUtf8(binaryToArray(bin));
  }
  cjs$1.binaryToUtf8 = binaryToUtf8;
  function binaryToNumber(bin) {
      return arrayToNumber(binaryToArray(bin));
  }
  cjs$1.binaryToNumber = binaryToNumber;
  function isBinaryString(str) {
      if (typeof str !== "string" || !new RegExp(/^[01]+$/).test(str)) {
          return false;
      }
      if (str.length % 8 !== 0) {
          return false;
      }
      return true;
  }
  cjs$1.isBinaryString = isBinaryString;
  function isHexString$1(str, length) {
      if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
          return false;
      }
      if (length && str.length !== 2 + 2 * length) {
          return false;
      }
      return true;
  }
  var isHexString_1 = cjs$1.isHexString = isHexString$1;
  function isBuffer(val) {
      return Buffer.isBuffer(val);
  }
  cjs$1.isBuffer = isBuffer;
  function isTypedArray(val) {
      return is_typedarray_1.default.strict(val) && !isBuffer(val);
  }
  cjs$1.isTypedArray = isTypedArray;
  function isArrayBuffer(val) {
      return (!isTypedArray(val) &&
          !isBuffer(val) &&
          typeof val.byteLength !== "undefined");
  }
  cjs$1.isArrayBuffer = isArrayBuffer;
  function getType(val) {
      if (isBuffer(val)) {
          return TYPE_BUFFER;
      }
      else if (isTypedArray(val)) {
          return TYPE_TYPED_ARRAY;
      }
      else if (isArrayBuffer(val)) {
          return TYPE_ARRAY_BUFFER;
      }
      else if (Array.isArray(val)) {
          return TYPE_ARRAY;
      }
      else {
          return typeof val;
      }
  }
  cjs$1.getType = getType;
  function getEncoding(str) {
      if (isBinaryString(str)) {
          return ENC_BIN;
      }
      if (isHexString$1(str)) {
          return ENC_HEX;
      }
      return ENC_UTF8;
  }
  cjs$1.getEncoding = getEncoding;
  function concatBuffers(...args) {
      const result = Buffer.concat(args);
      return result;
  }
  cjs$1.concatBuffers = concatBuffers;
  function concatArrays(...args) {
      let result = [];
      args.forEach(arg => (result = result.concat(Array.from(arg))));
      return new Uint8Array([...result]);
  }
  var concatArrays_1 = cjs$1.concatArrays = concatArrays;
  function trimLeft(data, length) {
      const diff = data.length - length;
      if (diff > 0) {
          data = data.slice(diff);
      }
      return data;
  }
  cjs$1.trimLeft = trimLeft;
  function trimRight(data, length) {
      return data.slice(0, length);
  }
  cjs$1.trimRight = trimRight;
  function calcByteLength(length, byteSize = 8) {
      const remainder = length % byteSize;
      return remainder
          ? ((length - remainder) / byteSize) * byteSize + byteSize
          : length;
  }
  cjs$1.calcByteLength = calcByteLength;
  function splitBytes(str, byteSize = 8) {
      const bytes = sanitizeBytes(str).match(new RegExp(`.{${byteSize}}`, "gi"));
      return Array.from(bytes || []);
  }
  cjs$1.splitBytes = splitBytes;
  function swapBytes(str) {
      return splitBytes(str)
          .map(reverseString)
          .join("");
  }
  cjs$1.swapBytes = swapBytes;
  function swapHex(str) {
      return binaryToHex(swapBytes(hexToBinary(str)));
  }
  cjs$1.swapHex = swapHex;
  function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
      return padLeft(str, calcByteLength(str.length, byteSize), padding);
  }
  cjs$1.sanitizeBytes = sanitizeBytes;
  function padLeft(str, length, padding = STRING_ZERO) {
      return padString(str, length, true, padding);
  }
  cjs$1.padLeft = padLeft;
  function padRight(str, length, padding = STRING_ZERO) {
      return padString(str, length, false, padding);
  }
  cjs$1.padRight = padRight;
  function removeHexPrefix(hex) {
      return hex.replace(/^0x/, "");
  }
  var removeHexPrefix_1 = cjs$1.removeHexPrefix = removeHexPrefix;
  function addHexPrefix(hex) {
      return hex.startsWith("0x") ? hex : `0x${hex}`;
  }
  var addHexPrefix_1 = cjs$1.addHexPrefix = addHexPrefix;
  function sanitizeHex$1(hex) {
      hex = removeHexPrefix(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
          hex = addHexPrefix(hex);
      }
      return hex;
  }
  var sanitizeHex_1 = cjs$1.sanitizeHex = sanitizeHex$1;
  function removeHexLeadingZeros$1(hex) {
      const prefixed = hex.startsWith("0x");
      hex = removeHexPrefix(hex);
      hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
      return prefixed ? addHexPrefix(hex) : hex;
  }
  removeHexLeadingZeros_1 = cjs$1.removeHexLeadingZeros = removeHexLeadingZeros$1;
  function isUndefined(value) {
      return typeof value === "undefined";
  }
  function isDefined(value) {
      return !isUndefined(value);
  }
  function assert(assertion, errorMessage) {
      if (!assertion) {
          throw new Error(errorMessage);
      }
  }
  function reverseString(str) {
      return str
          .split("")
          .reverse()
          .join("");
  }
  function padString(str, length, left, padding = STRING_ZERO) {
      const diff = length - str.length;
      let result = str;
      if (diff > 0) {
          const pad = padding.repeat(diff);
          result = left ? pad + str : str + pad;
      }
      return result;
  }

  function convertArrayBufferToBuffer(arrBuf) {
      return arrayToBuffer_1(new Uint8Array(arrBuf));
  }
  function convertArrayBufferToHex(arrBuf, noPrefix) {
      return arrayToHex_1(new Uint8Array(arrBuf), !noPrefix);
  }
  function convertBufferToArrayBuffer(buf) {
      return bufferToArray_1(buf).buffer;
  }
  function convertUtf8ToBuffer(utf8) {
      return utf8ToBuffer_1(utf8);
  }
  function convertUtf8ToHex(utf8, noPrefix) {
      return utf8ToHex_1(utf8, !noPrefix);
  }
  function convertHexToArrayBuffer(hex) {
      return hexToArray_1(hex).buffer;
  }
  function convertNumberToHex(num, noPrefix) {
      const hex = removeHexPrefix_1(sanitizeHex_1(new BN(num).toString(16)));
      return noPrefix ? hex : addHexPrefix_1(hex);
  }

  var sha3 = {exports: {}};

  (function (module) {
  	/*jslint bitwise: true */
  	(function () {

  	  var INPUT_ERROR = 'input is invalid type';
  	  var FINALIZE_ERROR = 'finalize already called';
  	  var WINDOW = typeof window === 'object';
  	  var root = WINDOW ? window : {};
  	  if (root.JS_SHA3_NO_WINDOW) {
  	    WINDOW = false;
  	  }
  	  var WEB_WORKER = !WINDOW && typeof self === 'object';
  	  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof browser$1$1 === 'object' && browser$1$1.versions && browser$1$1.versions.node;
  	  if (NODE_JS) {
  	    root = commonjsGlobal;
  	  } else if (WEB_WORKER) {
  	    root = self;
  	  }
  	  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
  	  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  	  var HEX_CHARS = '0123456789abcdef'.split('');
  	  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  	  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  	  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  	  var PADDING = [6, 1536, 393216, 100663296];
  	  var SHIFT = [0, 8, 16, 24];
  	  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
  	    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
  	    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
  	    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
  	    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  	  var BITS = [224, 256, 384, 512];
  	  var SHAKE_BITS = [128, 256];
  	  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  	  var CSHAKE_BYTEPAD = {
  	    '128': 168,
  	    '256': 136
  	  };

  	  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
  	    Array.isArray = function (obj) {
  	      return Object.prototype.toString.call(obj) === '[object Array]';
  	    };
  	  }

  	  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
  	    ArrayBuffer.isView = function (obj) {
  	      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
  	    };
  	  }

  	  var createOutputMethod = function (bits, padding, outputType) {
  	    return function (message) {
  	      return new Keccak(bits, padding, bits).update(message)[outputType]();
  	    };
  	  };

  	  var createShakeOutputMethod = function (bits, padding, outputType) {
  	    return function (message, outputBits) {
  	      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
  	    };
  	  };

  	  var createCshakeOutputMethod = function (bits, padding, outputType) {
  	    return function (message, outputBits, n, s) {
  	      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
  	    };
  	  };

  	  var createKmacOutputMethod = function (bits, padding, outputType) {
  	    return function (key, message, outputBits, s) {
  	      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
  	    };
  	  };

  	  var createOutputMethods = function (method, createMethod, bits, padding) {
  	    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
  	      var type = OUTPUT_TYPES[i];
  	      method[type] = createMethod(bits, padding, type);
  	    }
  	    return method;
  	  };

  	  var createMethod = function (bits, padding) {
  	    var method = createOutputMethod(bits, padding, 'hex');
  	    method.create = function () {
  	      return new Keccak(bits, padding, bits);
  	    };
  	    method.update = function (message) {
  	      return method.create().update(message);
  	    };
  	    return createOutputMethods(method, createOutputMethod, bits, padding);
  	  };

  	  var createShakeMethod = function (bits, padding) {
  	    var method = createShakeOutputMethod(bits, padding, 'hex');
  	    method.create = function (outputBits) {
  	      return new Keccak(bits, padding, outputBits);
  	    };
  	    method.update = function (message, outputBits) {
  	      return method.create(outputBits).update(message);
  	    };
  	    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  	  };

  	  var createCshakeMethod = function (bits, padding) {
  	    var w = CSHAKE_BYTEPAD[bits];
  	    var method = createCshakeOutputMethod(bits, padding, 'hex');
  	    method.create = function (outputBits, n, s) {
  	      if (!n && !s) {
  	        return methods['shake' + bits].create(outputBits);
  	      } else {
  	        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
  	      }
  	    };
  	    method.update = function (message, outputBits, n, s) {
  	      return method.create(outputBits, n, s).update(message);
  	    };
  	    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  	  };

  	  var createKmacMethod = function (bits, padding) {
  	    var w = CSHAKE_BYTEPAD[bits];
  	    var method = createKmacOutputMethod(bits, padding, 'hex');
  	    method.create = function (key, outputBits, s) {
  	      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
  	    };
  	    method.update = function (key, message, outputBits, s) {
  	      return method.create(key, outputBits, s).update(message);
  	    };
  	    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  	  };

  	  var algorithms = [
  	    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
  	    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
  	    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
  	    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
  	    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  	  ];

  	  var methods = {}, methodNames = [];

  	  for (var i = 0; i < algorithms.length; ++i) {
  	    var algorithm = algorithms[i];
  	    var bits = algorithm.bits;
  	    for (var j = 0; j < bits.length; ++j) {
  	      var methodName = algorithm.name + '_' + bits[j];
  	      methodNames.push(methodName);
  	      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
  	      if (algorithm.name !== 'sha3') {
  	        var newMethodName = algorithm.name + bits[j];
  	        methodNames.push(newMethodName);
  	        methods[newMethodName] = methods[methodName];
  	      }
  	    }
  	  }

  	  function Keccak(bits, padding, outputBits) {
  	    this.blocks = [];
  	    this.s = [];
  	    this.padding = padding;
  	    this.outputBits = outputBits;
  	    this.reset = true;
  	    this.finalized = false;
  	    this.block = 0;
  	    this.start = 0;
  	    this.blockCount = (1600 - (bits << 1)) >> 5;
  	    this.byteCount = this.blockCount << 2;
  	    this.outputBlocks = outputBits >> 5;
  	    this.extraBytes = (outputBits & 31) >> 3;

  	    for (var i = 0; i < 50; ++i) {
  	      this.s[i] = 0;
  	    }
  	  }

  	  Keccak.prototype.update = function (message) {
  	    if (this.finalized) {
  	      throw new Error(FINALIZE_ERROR);
  	    }
  	    var notString, type = typeof message;
  	    if (type !== 'string') {
  	      if (type === 'object') {
  	        if (message === null) {
  	          throw new Error(INPUT_ERROR);
  	        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
  	          message = new Uint8Array(message);
  	        } else if (!Array.isArray(message)) {
  	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
  	            throw new Error(INPUT_ERROR);
  	          }
  	        }
  	      } else {
  	        throw new Error(INPUT_ERROR);
  	      }
  	      notString = true;
  	    }
  	    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
  	      blockCount = this.blockCount, index = 0, s = this.s, i, code;

  	    while (index < length) {
  	      if (this.reset) {
  	        this.reset = false;
  	        blocks[0] = this.block;
  	        for (i = 1; i < blockCount + 1; ++i) {
  	          blocks[i] = 0;
  	        }
  	      }
  	      if (notString) {
  	        for (i = this.start; index < length && i < byteCount; ++index) {
  	          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
  	        }
  	      } else {
  	        for (i = this.start; index < length && i < byteCount; ++index) {
  	          code = message.charCodeAt(index);
  	          if (code < 0x80) {
  	            blocks[i >> 2] |= code << SHIFT[i++ & 3];
  	          } else if (code < 0x800) {
  	            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  	          } else if (code < 0xd800 || code >= 0xe000) {
  	            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  	          } else {
  	            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
  	            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
  	            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
  	          }
  	        }
  	      }
  	      this.lastByteIndex = i;
  	      if (i >= byteCount) {
  	        this.start = i - byteCount;
  	        this.block = blocks[blockCount];
  	        for (i = 0; i < blockCount; ++i) {
  	          s[i] ^= blocks[i];
  	        }
  	        f(s);
  	        this.reset = true;
  	      } else {
  	        this.start = i;
  	      }
  	    }
  	    return this;
  	  };

  	  Keccak.prototype.encode = function (x, right) {
  	    var o = x & 255, n = 1;
  	    var bytes = [o];
  	    x = x >> 8;
  	    o = x & 255;
  	    while (o > 0) {
  	      bytes.unshift(o);
  	      x = x >> 8;
  	      o = x & 255;
  	      ++n;
  	    }
  	    if (right) {
  	      bytes.push(n);
  	    } else {
  	      bytes.unshift(n);
  	    }
  	    this.update(bytes);
  	    return bytes.length;
  	  };

  	  Keccak.prototype.encodeString = function (str) {
  	    var notString, type = typeof str;
  	    if (type !== 'string') {
  	      if (type === 'object') {
  	        if (str === null) {
  	          throw new Error(INPUT_ERROR);
  	        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
  	          str = new Uint8Array(str);
  	        } else if (!Array.isArray(str)) {
  	          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
  	            throw new Error(INPUT_ERROR);
  	          }
  	        }
  	      } else {
  	        throw new Error(INPUT_ERROR);
  	      }
  	      notString = true;
  	    }
  	    var bytes = 0, length = str.length;
  	    if (notString) {
  	      bytes = length;
  	    } else {
  	      for (var i = 0; i < str.length; ++i) {
  	        var code = str.charCodeAt(i);
  	        if (code < 0x80) {
  	          bytes += 1;
  	        } else if (code < 0x800) {
  	          bytes += 2;
  	        } else if (code < 0xd800 || code >= 0xe000) {
  	          bytes += 3;
  	        } else {
  	          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
  	          bytes += 4;
  	        }
  	      }
  	    }
  	    bytes += this.encode(bytes * 8);
  	    this.update(str);
  	    return bytes;
  	  };

  	  Keccak.prototype.bytepad = function (strs, w) {
  	    var bytes = this.encode(w);
  	    for (var i = 0; i < strs.length; ++i) {
  	      bytes += this.encodeString(strs[i]);
  	    }
  	    var paddingBytes = w - bytes % w;
  	    var zeros = [];
  	    zeros.length = paddingBytes;
  	    this.update(zeros);
  	    return this;
  	  };

  	  Keccak.prototype.finalize = function () {
  	    if (this.finalized) {
  	      return;
  	    }
  	    this.finalized = true;
  	    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
  	    blocks[i >> 2] |= this.padding[i & 3];
  	    if (this.lastByteIndex === this.byteCount) {
  	      blocks[0] = blocks[blockCount];
  	      for (i = 1; i < blockCount + 1; ++i) {
  	        blocks[i] = 0;
  	      }
  	    }
  	    blocks[blockCount - 1] |= 0x80000000;
  	    for (i = 0; i < blockCount; ++i) {
  	      s[i] ^= blocks[i];
  	    }
  	    f(s);
  	  };

  	  Keccak.prototype.toString = Keccak.prototype.hex = function () {
  	    this.finalize();

  	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  	      extraBytes = this.extraBytes, i = 0, j = 0;
  	    var hex = '', block;
  	    while (j < outputBlocks) {
  	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  	        block = s[i];
  	        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
  	          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
  	          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
  	          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
  	      }
  	      if (j % blockCount === 0) {
  	        f(s);
  	        i = 0;
  	      }
  	    }
  	    if (extraBytes) {
  	      block = s[i];
  	      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
  	      if (extraBytes > 1) {
  	        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
  	      }
  	      if (extraBytes > 2) {
  	        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
  	      }
  	    }
  	    return hex;
  	  };

  	  Keccak.prototype.arrayBuffer = function () {
  	    this.finalize();

  	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  	      extraBytes = this.extraBytes, i = 0, j = 0;
  	    var bytes = this.outputBits >> 3;
  	    var buffer;
  	    if (extraBytes) {
  	      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
  	    } else {
  	      buffer = new ArrayBuffer(bytes);
  	    }
  	    var array = new Uint32Array(buffer);
  	    while (j < outputBlocks) {
  	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  	        array[j] = s[i];
  	      }
  	      if (j % blockCount === 0) {
  	        f(s);
  	      }
  	    }
  	    if (extraBytes) {
  	      array[i] = s[i];
  	      buffer = buffer.slice(0, bytes);
  	    }
  	    return buffer;
  	  };

  	  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  	  Keccak.prototype.digest = Keccak.prototype.array = function () {
  	    this.finalize();

  	    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
  	      extraBytes = this.extraBytes, i = 0, j = 0;
  	    var array = [], offset, block;
  	    while (j < outputBlocks) {
  	      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
  	        offset = j << 2;
  	        block = s[i];
  	        array[offset] = block & 0xFF;
  	        array[offset + 1] = (block >> 8) & 0xFF;
  	        array[offset + 2] = (block >> 16) & 0xFF;
  	        array[offset + 3] = (block >> 24) & 0xFF;
  	      }
  	      if (j % blockCount === 0) {
  	        f(s);
  	      }
  	    }
  	    if (extraBytes) {
  	      offset = j << 2;
  	      block = s[i];
  	      array[offset] = block & 0xFF;
  	      if (extraBytes > 1) {
  	        array[offset + 1] = (block >> 8) & 0xFF;
  	      }
  	      if (extraBytes > 2) {
  	        array[offset + 2] = (block >> 16) & 0xFF;
  	      }
  	    }
  	    return array;
  	  };

  	  function Kmac(bits, padding, outputBits) {
  	    Keccak.call(this, bits, padding, outputBits);
  	  }

  	  Kmac.prototype = new Keccak();

  	  Kmac.prototype.finalize = function () {
  	    this.encode(this.outputBits, true);
  	    return Keccak.prototype.finalize.call(this);
  	  };

  	  var f = function (s) {
  	    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
  	      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
  	      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
  	      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  	    for (n = 0; n < 48; n += 2) {
  	      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
  	      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
  	      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
  	      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
  	      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
  	      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
  	      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
  	      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
  	      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
  	      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

  	      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
  	      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
  	      s[0] ^= h;
  	      s[1] ^= l;
  	      s[10] ^= h;
  	      s[11] ^= l;
  	      s[20] ^= h;
  	      s[21] ^= l;
  	      s[30] ^= h;
  	      s[31] ^= l;
  	      s[40] ^= h;
  	      s[41] ^= l;
  	      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
  	      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
  	      s[2] ^= h;
  	      s[3] ^= l;
  	      s[12] ^= h;
  	      s[13] ^= l;
  	      s[22] ^= h;
  	      s[23] ^= l;
  	      s[32] ^= h;
  	      s[33] ^= l;
  	      s[42] ^= h;
  	      s[43] ^= l;
  	      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
  	      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
  	      s[4] ^= h;
  	      s[5] ^= l;
  	      s[14] ^= h;
  	      s[15] ^= l;
  	      s[24] ^= h;
  	      s[25] ^= l;
  	      s[34] ^= h;
  	      s[35] ^= l;
  	      s[44] ^= h;
  	      s[45] ^= l;
  	      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
  	      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
  	      s[6] ^= h;
  	      s[7] ^= l;
  	      s[16] ^= h;
  	      s[17] ^= l;
  	      s[26] ^= h;
  	      s[27] ^= l;
  	      s[36] ^= h;
  	      s[37] ^= l;
  	      s[46] ^= h;
  	      s[47] ^= l;
  	      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
  	      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
  	      s[8] ^= h;
  	      s[9] ^= l;
  	      s[18] ^= h;
  	      s[19] ^= l;
  	      s[28] ^= h;
  	      s[29] ^= l;
  	      s[38] ^= h;
  	      s[39] ^= l;
  	      s[48] ^= h;
  	      s[49] ^= l;

  	      b0 = s[0];
  	      b1 = s[1];
  	      b32 = (s[11] << 4) | (s[10] >>> 28);
  	      b33 = (s[10] << 4) | (s[11] >>> 28);
  	      b14 = (s[20] << 3) | (s[21] >>> 29);
  	      b15 = (s[21] << 3) | (s[20] >>> 29);
  	      b46 = (s[31] << 9) | (s[30] >>> 23);
  	      b47 = (s[30] << 9) | (s[31] >>> 23);
  	      b28 = (s[40] << 18) | (s[41] >>> 14);
  	      b29 = (s[41] << 18) | (s[40] >>> 14);
  	      b20 = (s[2] << 1) | (s[3] >>> 31);
  	      b21 = (s[3] << 1) | (s[2] >>> 31);
  	      b2 = (s[13] << 12) | (s[12] >>> 20);
  	      b3 = (s[12] << 12) | (s[13] >>> 20);
  	      b34 = (s[22] << 10) | (s[23] >>> 22);
  	      b35 = (s[23] << 10) | (s[22] >>> 22);
  	      b16 = (s[33] << 13) | (s[32] >>> 19);
  	      b17 = (s[32] << 13) | (s[33] >>> 19);
  	      b48 = (s[42] << 2) | (s[43] >>> 30);
  	      b49 = (s[43] << 2) | (s[42] >>> 30);
  	      b40 = (s[5] << 30) | (s[4] >>> 2);
  	      b41 = (s[4] << 30) | (s[5] >>> 2);
  	      b22 = (s[14] << 6) | (s[15] >>> 26);
  	      b23 = (s[15] << 6) | (s[14] >>> 26);
  	      b4 = (s[25] << 11) | (s[24] >>> 21);
  	      b5 = (s[24] << 11) | (s[25] >>> 21);
  	      b36 = (s[34] << 15) | (s[35] >>> 17);
  	      b37 = (s[35] << 15) | (s[34] >>> 17);
  	      b18 = (s[45] << 29) | (s[44] >>> 3);
  	      b19 = (s[44] << 29) | (s[45] >>> 3);
  	      b10 = (s[6] << 28) | (s[7] >>> 4);
  	      b11 = (s[7] << 28) | (s[6] >>> 4);
  	      b42 = (s[17] << 23) | (s[16] >>> 9);
  	      b43 = (s[16] << 23) | (s[17] >>> 9);
  	      b24 = (s[26] << 25) | (s[27] >>> 7);
  	      b25 = (s[27] << 25) | (s[26] >>> 7);
  	      b6 = (s[36] << 21) | (s[37] >>> 11);
  	      b7 = (s[37] << 21) | (s[36] >>> 11);
  	      b38 = (s[47] << 24) | (s[46] >>> 8);
  	      b39 = (s[46] << 24) | (s[47] >>> 8);
  	      b30 = (s[8] << 27) | (s[9] >>> 5);
  	      b31 = (s[9] << 27) | (s[8] >>> 5);
  	      b12 = (s[18] << 20) | (s[19] >>> 12);
  	      b13 = (s[19] << 20) | (s[18] >>> 12);
  	      b44 = (s[29] << 7) | (s[28] >>> 25);
  	      b45 = (s[28] << 7) | (s[29] >>> 25);
  	      b26 = (s[38] << 8) | (s[39] >>> 24);
  	      b27 = (s[39] << 8) | (s[38] >>> 24);
  	      b8 = (s[48] << 14) | (s[49] >>> 18);
  	      b9 = (s[49] << 14) | (s[48] >>> 18);

  	      s[0] = b0 ^ (~b2 & b4);
  	      s[1] = b1 ^ (~b3 & b5);
  	      s[10] = b10 ^ (~b12 & b14);
  	      s[11] = b11 ^ (~b13 & b15);
  	      s[20] = b20 ^ (~b22 & b24);
  	      s[21] = b21 ^ (~b23 & b25);
  	      s[30] = b30 ^ (~b32 & b34);
  	      s[31] = b31 ^ (~b33 & b35);
  	      s[40] = b40 ^ (~b42 & b44);
  	      s[41] = b41 ^ (~b43 & b45);
  	      s[2] = b2 ^ (~b4 & b6);
  	      s[3] = b3 ^ (~b5 & b7);
  	      s[12] = b12 ^ (~b14 & b16);
  	      s[13] = b13 ^ (~b15 & b17);
  	      s[22] = b22 ^ (~b24 & b26);
  	      s[23] = b23 ^ (~b25 & b27);
  	      s[32] = b32 ^ (~b34 & b36);
  	      s[33] = b33 ^ (~b35 & b37);
  	      s[42] = b42 ^ (~b44 & b46);
  	      s[43] = b43 ^ (~b45 & b47);
  	      s[4] = b4 ^ (~b6 & b8);
  	      s[5] = b5 ^ (~b7 & b9);
  	      s[14] = b14 ^ (~b16 & b18);
  	      s[15] = b15 ^ (~b17 & b19);
  	      s[24] = b24 ^ (~b26 & b28);
  	      s[25] = b25 ^ (~b27 & b29);
  	      s[34] = b34 ^ (~b36 & b38);
  	      s[35] = b35 ^ (~b37 & b39);
  	      s[44] = b44 ^ (~b46 & b48);
  	      s[45] = b45 ^ (~b47 & b49);
  	      s[6] = b6 ^ (~b8 & b0);
  	      s[7] = b7 ^ (~b9 & b1);
  	      s[16] = b16 ^ (~b18 & b10);
  	      s[17] = b17 ^ (~b19 & b11);
  	      s[26] = b26 ^ (~b28 & b20);
  	      s[27] = b27 ^ (~b29 & b21);
  	      s[36] = b36 ^ (~b38 & b30);
  	      s[37] = b37 ^ (~b39 & b31);
  	      s[46] = b46 ^ (~b48 & b40);
  	      s[47] = b47 ^ (~b49 & b41);
  	      s[8] = b8 ^ (~b0 & b2);
  	      s[9] = b9 ^ (~b1 & b3);
  	      s[18] = b18 ^ (~b10 & b12);
  	      s[19] = b19 ^ (~b11 & b13);
  	      s[28] = b28 ^ (~b20 & b22);
  	      s[29] = b29 ^ (~b21 & b23);
  	      s[38] = b38 ^ (~b30 & b32);
  	      s[39] = b39 ^ (~b31 & b33);
  	      s[48] = b48 ^ (~b40 & b42);
  	      s[49] = b49 ^ (~b41 & b43);

  	      s[0] ^= RC[n];
  	      s[1] ^= RC[n + 1];
  	    }
  	  };

  	  if (COMMON_JS) {
  	    module.exports = methods;
  	  } else {
  	    for (i = 0; i < methodNames.length; ++i) {
  	      root[methodNames[i]] = methods[methodNames[i]];
  	    }
  	  }
  	})();
  } (sha3));

  var cjs = {};

  var crypto = {};

  Object.defineProperty(crypto, "__esModule", { value: true });
  crypto.isBrowserCryptoAvailable = crypto.getSubtleCrypto = crypto.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
      return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }
  crypto.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto.isBrowserCryptoAvailable = isBrowserCryptoAvailable;

  var env = {};

  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative() {
      return (typeof document === "undefined" &&
          typeof navigator !== "undefined" &&
          navigator.product === "ReactNative");
  }
  env.isReactNative = isReactNative;
  function isNode() {
      return (typeof browser$1$1 !== "undefined" &&
          typeof browser$1$1.versions !== "undefined" &&
          typeof browser$1$1.versions.node !== "undefined");
  }
  env.isNode = isNode;
  function isBrowser() {
      return !isReactNative() && !isNode();
  }
  env.isBrowser = isBrowser;

  (function (exports) {
  	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  	}) : (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    o[k2] = m[k];
  	}));
  	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
  	    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	__exportStar(crypto, exports);
  	__exportStar(env, exports);
  	
  } (cjs));

  function payloadId$1() {
      const date = Date.now() * Math.pow(10, 3);
      const extra = Math.floor(Math.random() * Math.pow(10, 3));
      return date + extra;
  }

  function sanitizeHex(hex) {
      return sanitizeHex_1(hex);
  }
  function removeHexLeadingZeros(hex) {
      return removeHexLeadingZeros_1(addHexPrefix_1(hex));
  }
  const payloadId = payloadId$1;
  function uuid() {
      const result = ((a, b) => {
          for (b = a = ""; a++ < 36; b += (a * 51) & 52 ? (a ^ 15 ? 8 ^ (Math.random() * (a ^ 20 ? 16 : 4)) : 4).toString(16) : "-") {
          }
          return b;
      })();
      return result;
  }

  function isEmptyString(value) {
      return value === "" || (typeof value === "string" && value.trim() === "");
  }
  function isEmptyArray(array) {
      return !(array && array.length);
  }
  function isHexString(value, length) {
      return isHexString_1(value, length);
  }
  function isJsonRpcRequest(object) {
      return typeof object.method !== "undefined";
  }
  function isJsonRpcResponseSuccess(object) {
      return typeof object.result !== "undefined";
  }
  function isJsonRpcResponseError(object) {
      return typeof object.error !== "undefined";
  }
  function isInternalEvent(object) {
      return typeof object.event !== "undefined";
  }
  function isReservedEvent(event) {
      return reservedEvents.includes(event) || event.startsWith("wc_");
  }
  function isSilentPayload(request) {
      if (request.method.startsWith("wc_")) {
          return true;
      }
      if (signingMethods.includes(request.method)) {
          return false;
      }
      return true;
  }

  function toChecksumAddress(address) {
      address = removeHexPrefix_1(address.toLowerCase());
      const hash = removeHexPrefix_1(sha3.exports.keccak_256(convertUtf8ToBuffer(address)));
      let checksum = "";
      for (let i = 0; i < address.length; i++) {
          if (parseInt(hash[i], 16) > 7) {
              checksum += address[i].toUpperCase();
          }
          else {
              checksum += address[i];
          }
      }
      return addHexPrefix_1(checksum);
  }
  const isValidAddress = (address) => {
      if (!address) {
          return false;
      }
      else if (address.toLowerCase().substring(0, 2) !== "0x") {
          return false;
      }
      else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
          return false;
      }
      else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
          return true;
      }
      else {
          return address === toChecksumAddress(address);
      }
  };
  function parsePersonalSign(params) {
      if (!isEmptyArray(params) && !isHexString(params[0])) {
          params[0] = convertUtf8ToHex(params[0]);
      }
      return params;
  }
  function parseTransactionData(txData) {
      if (typeof txData.type !== "undefined" && txData.type !== "0")
          return txData;
      if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
          throw new Error(`Transaction object must include a valid 'from' value.`);
      }
      function parseHexValues(value) {
          let result = value;
          if (typeof value === "number" || (typeof value === "string" && !isEmptyString(value))) {
              if (!isHexString(value)) {
                  result = convertNumberToHex(value);
              }
              else if (typeof value === "string") {
                  result = sanitizeHex(value);
              }
          }
          if (typeof result === "string") {
              result = removeHexLeadingZeros(result);
          }
          return result;
      }
      const txDataRPC = {
          from: sanitizeHex(txData.from),
          to: typeof txData.to === "undefined" ? "" : sanitizeHex(txData.to),
          gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
          gas: typeof txData.gas === "undefined"
              ? typeof txData.gasLimit === "undefined"
                  ? ""
                  : parseHexValues(txData.gasLimit)
              : parseHexValues(txData.gas),
          value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
          nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
          data: typeof txData.data === "undefined" ? "" : sanitizeHex(txData.data) || "0x",
      };
      const prunable = ["gasPrice", "gas", "value", "nonce"];
      Object.keys(txDataRPC).forEach((key) => {
          if (!txDataRPC[key].trim().length && prunable.includes(key)) {
              delete txDataRPC[key];
          }
      });
      return txDataRPC;
  }

  function formatRpcError(error) {
      const message = error.message || "Failed or Rejected Request";
      let code = -32000;
      if (error && !error.code) {
          switch (message) {
              case "Parse error":
                  code = -32700;
                  break;
              case "Invalid request":
                  code = -32600;
                  break;
              case "Method not found":
                  code = -32601;
                  break;
              case "Invalid params":
                  code = -32602;
                  break;
              case "Internal error":
                  code = -32603;
                  break;
              default:
                  code = -32000;
                  break;
          }
      }
      const result = {
          code,
          message,
      };
      return result;
  }

  var queryString = {};

  var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token, 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');

  function decodeComponents(components, split) {
  	try {
  		// Try to decode the entire string first
  		return decodeURIComponent(components.join(''));
  	} catch (err) {
  		// Do nothing
  	}

  	if (components.length === 1) {
  		return components;
  	}

  	split = split || 1;

  	// Split the array in 2 parts
  	var left = components.slice(0, split);
  	var right = components.slice(split);

  	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }

  function decode(input) {
  	try {
  		return decodeURIComponent(input);
  	} catch (err) {
  		var tokens = input.match(singleMatcher);

  		for (var i = 1; i < tokens.length; i++) {
  			input = decodeComponents(tokens, i).join('');

  			tokens = input.match(singleMatcher);
  		}

  		return input;
  	}
  }

  function customDecodeURIComponent(input) {
  	// Keep track of all the replacements and prefill the map with the `BOM`
  	var replaceMap = {
  		'%FE%FF': '\uFFFD\uFFFD',
  		'%FF%FE': '\uFFFD\uFFFD'
  	};

  	var match = multiMatcher.exec(input);
  	while (match) {
  		try {
  			// Decode as big chunks as possible
  			replaceMap[match[0]] = decodeURIComponent(match[0]);
  		} catch (err) {
  			var result = decode(match[0]);

  			if (result !== match[0]) {
  				replaceMap[match[0]] = result;
  			}
  		}

  		match = multiMatcher.exec(input);
  	}

  	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
  	replaceMap['%C2'] = '\uFFFD';

  	var entries = Object.keys(replaceMap);

  	for (var i = 0; i < entries.length; i++) {
  		// Replace all decoded components
  		var key = entries[i];
  		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  	}

  	return input;
  }

  var decodeUriComponent = function (encodedURI) {
  	if (typeof encodedURI !== 'string') {
  		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
  	}

  	try {
  		encodedURI = encodedURI.replace(/\+/g, ' ');

  		// Try the built in decoder first
  		return decodeURIComponent(encodedURI);
  	} catch (err) {
  		// Fallback to a more advanced decoder
  		return customDecodeURIComponent(encodedURI);
  	}
  };

  var splitOnFirst = (string, separator) => {
  	if (!(typeof string === 'string' && typeof separator === 'string')) {
  		throw new TypeError('Expected the arguments to be of type `string`');
  	}

  	if (separator === '') {
  		return [string];
  	}

  	const separatorIndex = string.indexOf(separator);

  	if (separatorIndex === -1) {
  		return [string];
  	}

  	return [
  		string.slice(0, separatorIndex),
  		string.slice(separatorIndex + separator.length)
  	];
  };

  (function (exports) {
  	const strictUriEncode$1 = strictUriEncode;
  	const decodeComponent = decodeUriComponent;
  	const splitOnFirst$1 = splitOnFirst;

  	const isNullOrUndefined = value => value === null || value === undefined;

  	function encoderForArrayFormat(options) {
  		switch (options.arrayFormat) {
  			case 'index':
  				return key => (result, value) => {
  					const index = result.length;

  					if (
  						value === undefined ||
  						(options.skipNull && value === null) ||
  						(options.skipEmptyString && value === '')
  					) {
  						return result;
  					}

  					if (value === null) {
  						return [...result, [encode(key, options), '[', index, ']'].join('')];
  					}

  					return [
  						...result,
  						[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
  					];
  				};

  			case 'bracket':
  				return key => (result, value) => {
  					if (
  						value === undefined ||
  						(options.skipNull && value === null) ||
  						(options.skipEmptyString && value === '')
  					) {
  						return result;
  					}

  					if (value === null) {
  						return [...result, [encode(key, options), '[]'].join('')];
  					}

  					return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
  				};

  			case 'comma':
  			case 'separator':
  				return key => (result, value) => {
  					if (value === null || value === undefined || value.length === 0) {
  						return result;
  					}

  					if (result.length === 0) {
  						return [[encode(key, options), '=', encode(value, options)].join('')];
  					}

  					return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
  				};

  			default:
  				return key => (result, value) => {
  					if (
  						value === undefined ||
  						(options.skipNull && value === null) ||
  						(options.skipEmptyString && value === '')
  					) {
  						return result;
  					}

  					if (value === null) {
  						return [...result, encode(key, options)];
  					}

  					return [...result, [encode(key, options), '=', encode(value, options)].join('')];
  				};
  		}
  	}

  	function parserForArrayFormat(options) {
  		let result;

  		switch (options.arrayFormat) {
  			case 'index':
  				return (key, value, accumulator) => {
  					result = /\[(\d*)\]$/.exec(key);

  					key = key.replace(/\[\d*\]$/, '');

  					if (!result) {
  						accumulator[key] = value;
  						return;
  					}

  					if (accumulator[key] === undefined) {
  						accumulator[key] = {};
  					}

  					accumulator[key][result[1]] = value;
  				};

  			case 'bracket':
  				return (key, value, accumulator) => {
  					result = /(\[\])$/.exec(key);
  					key = key.replace(/\[\]$/, '');

  					if (!result) {
  						accumulator[key] = value;
  						return;
  					}

  					if (accumulator[key] === undefined) {
  						accumulator[key] = [value];
  						return;
  					}

  					accumulator[key] = [].concat(accumulator[key], value);
  				};

  			case 'comma':
  			case 'separator':
  				return (key, value, accumulator) => {
  					const isArray = typeof value === 'string' && value.split('').indexOf(options.arrayFormatSeparator) > -1;
  					const newValue = isArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
  					accumulator[key] = newValue;
  				};

  			default:
  				return (key, value, accumulator) => {
  					if (accumulator[key] === undefined) {
  						accumulator[key] = value;
  						return;
  					}

  					accumulator[key] = [].concat(accumulator[key], value);
  				};
  		}
  	}

  	function validateArrayFormatSeparator(value) {
  		if (typeof value !== 'string' || value.length !== 1) {
  			throw new TypeError('arrayFormatSeparator must be single character string');
  		}
  	}

  	function encode(value, options) {
  		if (options.encode) {
  			return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
  		}

  		return value;
  	}

  	function decode(value, options) {
  		if (options.decode) {
  			return decodeComponent(value);
  		}

  		return value;
  	}

  	function keysSorter(input) {
  		if (Array.isArray(input)) {
  			return input.sort();
  		}

  		if (typeof input === 'object') {
  			return keysSorter(Object.keys(input))
  				.sort((a, b) => Number(a) - Number(b))
  				.map(key => input[key]);
  		}

  		return input;
  	}

  	function removeHash(input) {
  		const hashStart = input.indexOf('#');
  		if (hashStart !== -1) {
  			input = input.slice(0, hashStart);
  		}

  		return input;
  	}

  	function getHash(url) {
  		let hash = '';
  		const hashStart = url.indexOf('#');
  		if (hashStart !== -1) {
  			hash = url.slice(hashStart);
  		}

  		return hash;
  	}

  	function extract(input) {
  		input = removeHash(input);
  		const queryStart = input.indexOf('?');
  		if (queryStart === -1) {
  			return '';
  		}

  		return input.slice(queryStart + 1);
  	}

  	function parseValue(value, options) {
  		if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
  			value = Number(value);
  		} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
  			value = value.toLowerCase() === 'true';
  		}

  		return value;
  	}

  	function parse(input, options) {
  		options = Object.assign({
  			decode: true,
  			sort: true,
  			arrayFormat: 'none',
  			arrayFormatSeparator: ',',
  			parseNumbers: false,
  			parseBooleans: false
  		}, options);

  		validateArrayFormatSeparator(options.arrayFormatSeparator);

  		const formatter = parserForArrayFormat(options);

  		// Create an object with no prototype
  		const ret = Object.create(null);

  		if (typeof input !== 'string') {
  			return ret;
  		}

  		input = input.trim().replace(/^[?#&]/, '');

  		if (!input) {
  			return ret;
  		}

  		for (const param of input.split('&')) {
  			let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '=');

  			// Missing `=` should be `null`:
  			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
  			value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
  			formatter(decode(key, options), value, ret);
  		}

  		for (const key of Object.keys(ret)) {
  			const value = ret[key];
  			if (typeof value === 'object' && value !== null) {
  				for (const k of Object.keys(value)) {
  					value[k] = parseValue(value[k], options);
  				}
  			} else {
  				ret[key] = parseValue(value, options);
  			}
  		}

  		if (options.sort === false) {
  			return ret;
  		}

  		return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
  			const value = ret[key];
  			if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
  				// Sort object keys, not values
  				result[key] = keysSorter(value);
  			} else {
  				result[key] = value;
  			}

  			return result;
  		}, Object.create(null));
  	}

  	exports.extract = extract;
  	exports.parse = parse;

  	exports.stringify = (object, options) => {
  		if (!object) {
  			return '';
  		}

  		options = Object.assign({
  			encode: true,
  			strict: true,
  			arrayFormat: 'none',
  			arrayFormatSeparator: ','
  		}, options);

  		validateArrayFormatSeparator(options.arrayFormatSeparator);

  		const shouldFilter = key => (
  			(options.skipNull && isNullOrUndefined(object[key])) ||
  			(options.skipEmptyString && object[key] === '')
  		);

  		const formatter = encoderForArrayFormat(options);

  		const objectCopy = {};

  		for (const key of Object.keys(object)) {
  			if (!shouldFilter(key)) {
  				objectCopy[key] = object[key];
  			}
  		}

  		const keys = Object.keys(objectCopy);

  		if (options.sort !== false) {
  			keys.sort(options.sort);
  		}

  		return keys.map(key => {
  			const value = object[key];

  			if (value === undefined) {
  				return '';
  			}

  			if (value === null) {
  				return encode(key, options);
  			}

  			if (Array.isArray(value)) {
  				return value
  					.reduce(formatter(key), [])
  					.join('&');
  			}

  			return encode(key, options) + '=' + encode(value, options);
  		}).filter(x => x.length > 0).join('&');
  	};

  	exports.parseUrl = (input, options) => {
  		options = Object.assign({
  			decode: true
  		}, options);

  		const [url, hash] = splitOnFirst$1(input, '#');

  		return Object.assign(
  			{
  				url: url.split('?')[0] || '',
  				query: parse(extract(input), options)
  			},
  			options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
  		);
  	};

  	exports.stringifyUrl = (input, options) => {
  		options = Object.assign({
  			encode: true,
  			strict: true
  		}, options);

  		const url = removeHash(input.url).split('?')[0] || '';
  		const queryFromUrl = exports.extract(input.url);
  		const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

  		const query = Object.assign(parsedQueryFromUrl, input.query);
  		let queryString = exports.stringify(query, options);
  		if (queryString) {
  			queryString = `?${queryString}`;
  		}

  		let hash = getHash(input.url);
  		if (input.fragmentIdentifier) {
  			hash = `#${encode(input.fragmentIdentifier, options)}`;
  		}

  		return `${url}${queryString}${hash}`;
  	};
  } (queryString));

  function getQueryString(url) {
      const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : undefined;
      const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
      return queryString;
  }
  function appendToQueryString(queryString, newQueryParams) {
      let queryParams = parseQueryString(queryString);
      queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
      queryString = formatQueryString(queryParams);
      return queryString;
  }
  function parseQueryString(queryString$1) {
      return queryString.parse(queryString$1);
  }
  function formatQueryString(queryParams) {
      return queryString.stringify(queryParams);
  }

  function isWalletConnectSession(object) {
      return typeof object.bridge !== "undefined";
  }
  function parseWalletConnectUri(str) {
      const pathStart = str.indexOf(":");
      const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : undefined;
      const protocol = str.substring(0, pathStart);
      const path = str.substring(pathStart + 1, pathEnd);
      function parseRequiredParams(path) {
          const separator = "@";
          const values = path.split(separator);
          const requiredParams = {
              handshakeTopic: values[0],
              version: parseInt(values[1], 10),
          };
          return requiredParams;
      }
      const requiredParams = parseRequiredParams(path);
      const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
      function parseQueryParams(queryString) {
          const result = parseQueryString(queryString);
          const parameters = {
              key: result.key || "",
              bridge: result.bridge || "",
          };
          return parameters;
      }
      const queryParams = parseQueryParams(queryString);
      const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
      return result;
  }

  class NetworkMonitor {
      constructor() {
          this._eventEmitters = [];
          if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
              window.addEventListener("online", () => this.trigger("online"));
              window.addEventListener("offline", () => this.trigger("offline"));
          }
      }
      on(event, callback) {
          this._eventEmitters.push({
              event,
              callback,
          });
      }
      trigger(event) {
          let eventEmitters = [];
          if (event) {
              eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
          }
          eventEmitters.forEach((eventEmitter) => {
              eventEmitter.callback();
          });
      }
  }

  const WS = typeof global$1.WebSocket !== "undefined" ? global$1.WebSocket : require("ws");
  class SocketTransport {
      constructor(opts) {
          this.opts = opts;
          this._queue = [];
          this._events = [];
          this._subscriptions = [];
          this._protocol = opts.protocol;
          this._version = opts.version;
          this._url = "";
          this._netMonitor = null;
          this._socket = null;
          this._nextSocket = null;
          this._subscriptions = opts.subscriptions || [];
          this._netMonitor = opts.netMonitor || new NetworkMonitor();
          if (!opts.url || typeof opts.url !== "string") {
              throw new Error("Missing or invalid WebSocket url");
          }
          this._url = opts.url;
          this._netMonitor.on("online", () => this._socketCreate());
      }
      set readyState(value) {
      }
      get readyState() {
          return this._socket ? this._socket.readyState : -1;
      }
      set connecting(value) {
      }
      get connecting() {
          return this.readyState === 0;
      }
      set connected(value) {
      }
      get connected() {
          return this.readyState === 1;
      }
      set closing(value) {
      }
      get closing() {
          return this.readyState === 2;
      }
      set closed(value) {
      }
      get closed() {
          return this.readyState === 3;
      }
      open() {
          this._socketCreate();
      }
      close() {
          this._socketClose();
      }
      send(message, topic, silent) {
          if (!topic || typeof topic !== "string") {
              throw new Error("Missing or invalid topic field");
          }
          this._socketSend({
              topic: topic,
              type: "pub",
              payload: message,
              silent: !!silent,
          });
      }
      subscribe(topic) {
          this._socketSend({
              topic: topic,
              type: "sub",
              payload: "",
              silent: true,
          });
      }
      on(event, callback) {
          this._events.push({ event, callback });
      }
      _socketCreate() {
          if (this._nextSocket) {
              return;
          }
          const url = getWebSocketUrl(this._url, this._protocol, this._version);
          this._nextSocket = new WS(url);
          if (!this._nextSocket) {
              throw new Error("Failed to create socket");
          }
          this._nextSocket.onmessage = (event) => this._socketReceive(event);
          this._nextSocket.onopen = () => this._socketOpen();
          this._nextSocket.onerror = (event) => this._socketError(event);
          this._nextSocket.onclose = () => {
              setTimeout(() => {
                  this._nextSocket = null;
                  this._socketCreate();
              }, 1000);
          };
      }
      _socketOpen() {
          this._socketClose();
          this._socket = this._nextSocket;
          this._nextSocket = null;
          this._queueSubscriptions();
          this._pushQueue();
      }
      _socketClose() {
          if (this._socket) {
              this._socket.onclose = () => {
              };
              this._socket.close();
          }
      }
      _socketSend(socketMessage) {
          const message = JSON.stringify(socketMessage);
          if (this._socket && this._socket.readyState === 1) {
              this._socket.send(message);
          }
          else {
              this._setToQueue(socketMessage);
              this._socketCreate();
          }
      }
      async _socketReceive(event) {
          let socketMessage;
          try {
              socketMessage = JSON.parse(event.data);
          }
          catch (error) {
              return;
          }
          this._socketSend({
              topic: socketMessage.topic,
              type: "ack",
              payload: "",
              silent: true,
          });
          if (this._socket && this._socket.readyState === 1) {
              const events = this._events.filter(event => event.event === "message");
              if (events && events.length) {
                  events.forEach(event => event.callback(socketMessage));
              }
          }
      }
      _socketError(e) {
          const events = this._events.filter(event => event.event === "error");
          if (events && events.length) {
              events.forEach(event => event.callback(e));
          }
      }
      _queueSubscriptions() {
          const subscriptions = this._subscriptions;
          subscriptions.forEach((topic) => this._queue.push({
              topic: topic,
              type: "sub",
              payload: "",
              silent: true,
          }));
          this._subscriptions = this.opts.subscriptions || [];
      }
      _setToQueue(socketMessage) {
          this._queue.push(socketMessage);
      }
      _pushQueue() {
          const queue = this._queue;
          queue.forEach((socketMessage) => this._socketSend(socketMessage));
          this._queue = [];
      }
  }
  function getWebSocketUrl(_url, protocol, version) {
      var _a, _b;
      const url = _url.startsWith("https")
          ? _url.replace("https", "wss")
          : _url.startsWith("http")
              ? _url.replace("http", "ws")
              : _url;
      const splitUrl = url.split("?");
      const params = isBrowser$1()
          ? {
              protocol,
              version,
              env: "browser",
              host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || "",
          }
          : {
              protocol,
              version,
              env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || "",
          };
      const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
      return splitUrl[0] + "?" + queryString;
  }

  const ERROR_SESSION_CONNECTED = "Session currently connected";
  const ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
  const ERROR_SESSION_REJECTED = "Session Rejected";
  const ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
  const ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
  const ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
  const ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
  const ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
  const ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
  const ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
  const ERROR_INVALID_URI = "URI format is invalid";
  const ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
  const ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

  class EventManager {
      constructor() {
          this._eventEmitters = [];
      }
      subscribe(eventEmitter) {
          this._eventEmitters.push(eventEmitter);
      }
      unsubscribe(event) {
          this._eventEmitters = this._eventEmitters.filter(x => x.event !== event);
      }
      trigger(payload) {
          let eventEmitters = [];
          let event;
          if (isJsonRpcRequest(payload)) {
              event = payload.method;
          }
          else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
              event = `response:${payload.id}`;
          }
          else if (isInternalEvent(payload)) {
              event = payload.event;
          }
          else {
              event = "";
          }
          if (event) {
              eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
          }
          if ((!eventEmitters || !eventEmitters.length) &&
              !isReservedEvent(event) &&
              !isInternalEvent(event)) {
              eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
          }
          eventEmitters.forEach((eventEmitter) => {
              if (isJsonRpcResponseError(payload)) {
                  const error = new Error(payload.error.message);
                  eventEmitter.callback(error, null);
              }
              else {
                  eventEmitter.callback(null, payload);
              }
          });
      }
  }

  class SessionStorage {
      constructor(storageId = "walletconnect") {
          this.storageId = storageId;
      }
      getSession() {
          let session = null;
          const json = getLocal(this.storageId);
          if (json && isWalletConnectSession(json)) {
              session = json;
          }
          return session;
      }
      setSession(session) {
          setLocal(this.storageId, session);
          return session;
      }
      removeSession() {
          removeLocal(this.storageId);
      }
  }

  const domain = "walletconnect.org";
  const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
  const bridges = alphanumerical.split("").map(char => `https://${char}.bridge.walletconnect.org`);
  function extractHostname(url) {
      let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
      hostname = hostname.split(":")[0];
      hostname = hostname.split("?")[0];
      return hostname;
  }
  function extractRootDomain(url) {
      return extractHostname(url)
          .split(".")
          .slice(-2)
          .join(".");
  }
  function randomBridgeIndex() {
      return Math.floor(Math.random() * bridges.length);
  }
  function selectRandomBridgeUrl() {
      return bridges[randomBridgeIndex()];
  }
  function shouldSelectRandomly(url) {
      return extractRootDomain(url) === domain;
  }
  function getBridgeUrl(url) {
      if (shouldSelectRandomly(url)) {
          return selectRandomBridgeUrl();
      }
      return url;
  }

  class Connector {
      constructor(opts) {
          this.protocol = "wc";
          this.version = 1;
          this._bridge = "";
          this._key = null;
          this._clientId = "";
          this._clientMeta = null;
          this._peerId = "";
          this._peerMeta = null;
          this._handshakeId = 0;
          this._handshakeTopic = "";
          this._connected = false;
          this._accounts = [];
          this._chainId = 0;
          this._networkId = 0;
          this._rpcUrl = "";
          this._eventManager = new EventManager();
          this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
          this._cryptoLib = opts.cryptoLib;
          this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
          this._qrcodeModal = opts.connectorOpts.qrcodeModal;
          this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
          this._signingMethods = [...signingMethods, ...(opts.connectorOpts.signingMethods || [])];
          if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
              throw new Error(ERROR_MISSING_REQUIRED);
          }
          if (opts.connectorOpts.bridge) {
              this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
          }
          if (opts.connectorOpts.uri) {
              this.uri = opts.connectorOpts.uri;
          }
          const session = opts.connectorOpts.session || this._getStorageSession();
          if (session) {
              this.session = session;
          }
          if (this.handshakeId) {
              this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
          }
          this._transport =
              opts.transport ||
                  new SocketTransport({
                      protocol: this.protocol,
                      version: this.version,
                      url: this.bridge,
                      subscriptions: [this.clientId],
                  });
          this._subscribeToInternalEvents();
          this._initTransport();
          if (opts.connectorOpts.uri) {
              this._subscribeToSessionRequest();
          }
          if (opts.pushServerOpts) {
              this._registerPushServer(opts.pushServerOpts);
          }
      }
      set bridge(value) {
          if (!value) {
              return;
          }
          this._bridge = value;
      }
      get bridge() {
          return this._bridge;
      }
      set key(value) {
          if (!value) {
              return;
          }
          const key = convertHexToArrayBuffer(value);
          this._key = key;
      }
      get key() {
          if (this._key) {
              const key = convertArrayBufferToHex(this._key, true);
              return key;
          }
          return "";
      }
      set clientId(value) {
          if (!value) {
              return;
          }
          this._clientId = value;
      }
      get clientId() {
          let clientId = this._clientId;
          if (!clientId) {
              clientId = this._clientId = uuid();
          }
          return this._clientId;
      }
      set peerId(value) {
          if (!value) {
              return;
          }
          this._peerId = value;
      }
      get peerId() {
          return this._peerId;
      }
      set clientMeta(value) {
      }
      get clientMeta() {
          let clientMeta = this._clientMeta;
          if (!clientMeta) {
              clientMeta = this._clientMeta = getClientMeta();
          }
          return clientMeta;
      }
      set peerMeta(value) {
          this._peerMeta = value;
      }
      get peerMeta() {
          const peerMeta = this._peerMeta;
          return peerMeta;
      }
      set handshakeTopic(value) {
          if (!value) {
              return;
          }
          this._handshakeTopic = value;
      }
      get handshakeTopic() {
          return this._handshakeTopic;
      }
      set handshakeId(value) {
          if (!value) {
              return;
          }
          this._handshakeId = value;
      }
      get handshakeId() {
          return this._handshakeId;
      }
      get uri() {
          const _uri = this._formatUri();
          return _uri;
      }
      set uri(value) {
          if (!value) {
              return;
          }
          const { handshakeTopic, bridge, key } = this._parseUri(value);
          this.handshakeTopic = handshakeTopic;
          this.bridge = bridge;
          this.key = key;
      }
      set chainId(value) {
          this._chainId = value;
      }
      get chainId() {
          const chainId = this._chainId;
          return chainId;
      }
      set networkId(value) {
          this._networkId = value;
      }
      get networkId() {
          const networkId = this._networkId;
          return networkId;
      }
      set accounts(value) {
          this._accounts = value;
      }
      get accounts() {
          const accounts = this._accounts;
          return accounts;
      }
      set rpcUrl(value) {
          this._rpcUrl = value;
      }
      get rpcUrl() {
          const rpcUrl = this._rpcUrl;
          return rpcUrl;
      }
      set connected(value) {
      }
      get connected() {
          return this._connected;
      }
      set pending(value) {
      }
      get pending() {
          return !!this._handshakeTopic;
      }
      get session() {
          return {
              connected: this.connected,
              accounts: this.accounts,
              chainId: this.chainId,
              bridge: this.bridge,
              key: this.key,
              clientId: this.clientId,
              clientMeta: this.clientMeta,
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              handshakeId: this.handshakeId,
              handshakeTopic: this.handshakeTopic,
          };
      }
      set session(value) {
          if (!value) {
              return;
          }
          this._connected = value.connected;
          this.accounts = value.accounts;
          this.chainId = value.chainId;
          this.bridge = value.bridge;
          this.key = value.key;
          this.clientId = value.clientId;
          this.clientMeta = value.clientMeta;
          this.peerId = value.peerId;
          this.peerMeta = value.peerMeta;
          this.handshakeId = value.handshakeId;
          this.handshakeTopic = value.handshakeTopic;
      }
      on(event, callback) {
          const eventEmitter = {
              event,
              callback,
          };
          this._eventManager.subscribe(eventEmitter);
      }
      off(event) {
          this._eventManager.unsubscribe(event);
      }
      async createInstantRequest(instantRequest) {
          this._key = await this._generateKey();
          const request = this._formatRequest({
              method: "wc_instantRequest",
              params: [
                  {
                      peerId: this.clientId,
                      peerMeta: this.clientMeta,
                      request: this._formatRequest(instantRequest),
                  },
              ],
          });
          this.handshakeId = request.id;
          this.handshakeTopic = uuid();
          this._eventManager.trigger({
              event: "display_uri",
              params: [this.uri],
          });
          this.on("modal_closed", () => {
              throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
          });
          const endInstantRequest = () => {
              this.killSession();
          };
          try {
              const result = await this._sendCallRequest(request);
              if (result) {
                  endInstantRequest();
              }
              return result;
          }
          catch (error) {
              endInstantRequest();
              throw error;
          }
      }
      async connect(opts) {
          if (!this._qrcodeModal) {
              throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
          }
          if (this.connected) {
              return {
                  chainId: this.chainId,
                  accounts: this.accounts,
              };
          }
          await this.createSession(opts);
          return new Promise(async (resolve, reject) => {
              this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
              this.on("connect", (error, payload) => {
                  if (error) {
                      return reject(error);
                  }
                  resolve(payload.params[0]);
              });
          });
      }
      async createSession(opts) {
          if (this._connected) {
              throw new Error(ERROR_SESSION_CONNECTED);
          }
          if (this.pending) {
              return;
          }
          this._key = await this._generateKey();
          const request = this._formatRequest({
              method: "wc_sessionRequest",
              params: [
                  {
                      peerId: this.clientId,
                      peerMeta: this.clientMeta,
                      chainId: opts && opts.chainId ? opts.chainId : null,
                  },
              ],
          });
          this.handshakeId = request.id;
          this.handshakeTopic = uuid();
          this._sendSessionRequest(request, "Session update rejected", {
              topic: this.handshakeTopic,
          });
          this._eventManager.trigger({
              event: "display_uri",
              params: [this.uri],
          });
      }
      approveSession(sessionStatus) {
          if (this._connected) {
              throw new Error(ERROR_SESSION_CONNECTED);
          }
          this.chainId = sessionStatus.chainId;
          this.accounts = sessionStatus.accounts;
          this.networkId = sessionStatus.networkId || 0;
          this.rpcUrl = sessionStatus.rpcUrl || "";
          const sessionParams = {
              approved: true,
              chainId: this.chainId,
              networkId: this.networkId,
              accounts: this.accounts,
              rpcUrl: this.rpcUrl,
              peerId: this.clientId,
              peerMeta: this.clientMeta,
          };
          const response = {
              id: this.handshakeId,
              jsonrpc: "2.0",
              result: sessionParams,
          };
          this._sendResponse(response);
          this._connected = true;
          this._setStorageSession();
          this._eventManager.trigger({
              event: "connect",
              params: [
                  {
                      peerId: this.peerId,
                      peerMeta: this.peerMeta,
                      chainId: this.chainId,
                      accounts: this.accounts,
                  },
              ],
          });
      }
      rejectSession(sessionError) {
          if (this._connected) {
              throw new Error(ERROR_SESSION_CONNECTED);
          }
          const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
          const response = this._formatResponse({
              id: this.handshakeId,
              error: { message },
          });
          this._sendResponse(response);
          this._connected = false;
          this._eventManager.trigger({
              event: "disconnect",
              params: [{ message }],
          });
          this._removeStorageSession();
      }
      updateSession(sessionStatus) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          this.chainId = sessionStatus.chainId;
          this.accounts = sessionStatus.accounts;
          this.networkId = sessionStatus.networkId || 0;
          this.rpcUrl = sessionStatus.rpcUrl || "";
          const sessionParams = {
              approved: true,
              chainId: this.chainId,
              networkId: this.networkId,
              accounts: this.accounts,
              rpcUrl: this.rpcUrl,
          };
          const request = this._formatRequest({
              method: "wc_sessionUpdate",
              params: [sessionParams],
          });
          this._sendSessionRequest(request, "Session update rejected");
          this._eventManager.trigger({
              event: "session_update",
              params: [
                  {
                      chainId: this.chainId,
                      accounts: this.accounts,
                  },
              ],
          });
          this._manageStorageSession();
      }
      async killSession(sessionError) {
          const message = sessionError ? sessionError.message : "Session Disconnected";
          const sessionParams = {
              approved: false,
              chainId: null,
              networkId: null,
              accounts: null,
          };
          const request = this._formatRequest({
              method: "wc_sessionUpdate",
              params: [sessionParams],
          });
          await this._sendRequest(request);
          this._handleSessionDisconnect(message);
      }
      async sendTransaction(tx) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = parseTransactionData(tx);
          const request = this._formatRequest({
              method: "eth_sendTransaction",
              params: [parsedTx],
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      async signTransaction(tx) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = parseTransactionData(tx);
          const request = this._formatRequest({
              method: "eth_signTransaction",
              params: [parsedTx],
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      async signMessage(params) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
              method: "eth_sign",
              params,
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      async signPersonalMessage(params) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          params = parsePersonalSign(params);
          const request = this._formatRequest({
              method: "personal_sign",
              params,
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      async signTypedData(params) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
              method: "eth_signTypedData",
              params,
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      async updateChain(chainParams) {
          if (!this._connected) {
              throw new Error("Session currently disconnected");
          }
          const request = this._formatRequest({
              method: "wallet_updateChain",
              params: [chainParams],
          });
          const result = await this._sendCallRequest(request);
          return result;
      }
      unsafeSend(request, options) {
          this._sendRequest(request, options);
          this._eventManager.trigger({
              event: "call_request_sent",
              params: [{ request, options }],
          });
          return new Promise((resolve, reject) => {
              this._subscribeToResponse(request.id, (error, payload) => {
                  if (error) {
                      reject(error);
                      return;
                  }
                  if (!payload) {
                      throw new Error(ERROR_MISSING_JSON_RPC);
                  }
                  resolve(payload);
              });
          });
      }
      async sendCustomRequest(request, options) {
          if (!this._connected) {
              throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          switch (request.method) {
              case "eth_accounts":
                  return this.accounts;
              case "eth_chainId":
                  return convertNumberToHex(this.chainId);
              case "eth_sendTransaction":
              case "eth_signTransaction":
                  if (request.params) {
                      request.params[0] = parseTransactionData(request.params[0]);
                  }
                  break;
              case "personal_sign":
                  if (request.params) {
                      request.params = parsePersonalSign(request.params);
                  }
                  break;
          }
          const formattedRequest = this._formatRequest(request);
          const result = await this._sendCallRequest(formattedRequest, options);
          return result;
      }
      approveRequest(response) {
          if (isJsonRpcResponseSuccess(response)) {
              const formattedResponse = this._formatResponse(response);
              this._sendResponse(formattedResponse);
          }
          else {
              throw new Error(ERROR_MISSING_RESULT);
          }
      }
      rejectRequest(response) {
          if (isJsonRpcResponseError(response)) {
              const formattedResponse = this._formatResponse(response);
              this._sendResponse(formattedResponse);
          }
          else {
              throw new Error(ERROR_MISSING_ERROR);
          }
      }
      transportClose() {
          this._transport.close();
      }
      async _sendRequest(request, options) {
          const callRequest = this._formatRequest(request);
          const encryptionPayload = await this._encrypt(callRequest);
          const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined"
              ? !options.forcePushNotification
              : isSilentPayload(callRequest);
          this._transport.send(payload, topic, silent);
      }
      async _sendResponse(response) {
          const encryptionPayload = await this._encrypt(response);
          const topic = this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = true;
          this._transport.send(payload, topic, silent);
      }
      async _sendSessionRequest(request, errorMsg, options) {
          this._sendRequest(request, options);
          this._subscribeToSessionResponse(request.id, errorMsg);
      }
      _sendCallRequest(request, options) {
          this._sendRequest(request, options);
          this._eventManager.trigger({
              event: "call_request_sent",
              params: [{ request, options }],
          });
          return this._subscribeToCallResponse(request.id);
      }
      _formatRequest(request) {
          if (typeof request.method === "undefined") {
              throw new Error(ERROR_MISSING_METHOD);
          }
          const formattedRequest = {
              id: typeof request.id === "undefined" ? payloadId() : request.id,
              jsonrpc: "2.0",
              method: request.method,
              params: typeof request.params === "undefined" ? [] : request.params,
          };
          return formattedRequest;
      }
      _formatResponse(response) {
          if (typeof response.id === "undefined") {
              throw new Error(ERROR_MISSING_ID);
          }
          const baseResponse = { id: response.id, jsonrpc: "2.0" };
          if (isJsonRpcResponseError(response)) {
              const error = formatRpcError(response.error);
              const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
              return errorResponse;
          }
          else if (isJsonRpcResponseSuccess(response)) {
              const successResponse = Object.assign(Object.assign({}, baseResponse), response);
              return successResponse;
          }
          throw new Error(ERROR_INVALID_RESPONSE);
      }
      _handleSessionDisconnect(errorMsg) {
          const message = errorMsg || "Session Disconnected";
          if (!this._connected) {
              if (this._qrcodeModal) {
                  this._qrcodeModal.close();
              }
              removeLocal(mobileLinkChoiceKey);
          }
          if (this._connected) {
              this._connected = false;
          }
          if (this._handshakeId) {
              this._handshakeId = 0;
          }
          if (this._handshakeTopic) {
              this._handshakeTopic = "";
          }
          if (this._peerId) {
              this._peerId = "";
          }
          this._eventManager.trigger({
              event: "disconnect",
              params: [{ message }],
          });
          this._removeStorageSession();
          this.transportClose();
      }
      _handleSessionResponse(errorMsg, sessionParams) {
          if (sessionParams) {
              if (sessionParams.approved) {
                  if (!this._connected) {
                      this._connected = true;
                      if (sessionParams.chainId) {
                          this.chainId = sessionParams.chainId;
                      }
                      if (sessionParams.accounts) {
                          this.accounts = sessionParams.accounts;
                      }
                      if (sessionParams.peerId && !this.peerId) {
                          this.peerId = sessionParams.peerId;
                      }
                      if (sessionParams.peerMeta && !this.peerMeta) {
                          this.peerMeta = sessionParams.peerMeta;
                      }
                      this._eventManager.trigger({
                          event: "connect",
                          params: [
                              {
                                  peerId: this.peerId,
                                  peerMeta: this.peerMeta,
                                  chainId: this.chainId,
                                  accounts: this.accounts,
                              },
                          ],
                      });
                  }
                  else {
                      if (sessionParams.chainId) {
                          this.chainId = sessionParams.chainId;
                      }
                      if (sessionParams.accounts) {
                          this.accounts = sessionParams.accounts;
                      }
                      this._eventManager.trigger({
                          event: "session_update",
                          params: [
                              {
                                  chainId: this.chainId,
                                  accounts: this.accounts,
                              },
                          ],
                      });
                  }
                  this._manageStorageSession();
              }
              else {
                  this._handleSessionDisconnect(errorMsg);
              }
          }
          else {
              this._handleSessionDisconnect(errorMsg);
          }
      }
      async _handleIncomingMessages(socketMessage) {
          const activeTopics = [this.clientId, this.handshakeTopic];
          if (!activeTopics.includes(socketMessage.topic)) {
              return;
          }
          let encryptionPayload;
          try {
              encryptionPayload = JSON.parse(socketMessage.payload);
          }
          catch (error) {
              return;
          }
          const payload = await this._decrypt(encryptionPayload);
          if (payload) {
              this._eventManager.trigger(payload);
          }
      }
      _subscribeToSessionRequest() {
          this._transport.subscribe(this.handshakeTopic);
      }
      _subscribeToResponse(id, callback) {
          this.on(`response:${id}`, callback);
      }
      _subscribeToSessionResponse(id, errorMsg) {
          this._subscribeToResponse(id, (error, payload) => {
              if (error) {
                  this._handleSessionResponse(error.message);
                  return;
              }
              if (payload.result) {
                  this._handleSessionResponse(errorMsg, payload.result);
              }
              else if (payload.error && payload.error.message) {
                  this._handleSessionResponse(payload.error.message);
              }
              else {
                  this._handleSessionResponse(errorMsg);
              }
          });
      }
      _subscribeToCallResponse(id) {
          return new Promise((resolve, reject) => {
              this._subscribeToResponse(id, (error, payload) => {
                  if (error) {
                      reject(error);
                      return;
                  }
                  if (payload.result) {
                      resolve(payload.result);
                  }
                  else if (payload.error && payload.error.message) {
                      reject(new Error(payload.error.message));
                  }
                  else {
                      reject(new Error(ERROR_INVALID_RESPONSE));
                  }
              });
          });
      }
      _subscribeToInternalEvents() {
          this.on("display_uri", () => {
              if (this._qrcodeModal) {
                  this._qrcodeModal.open(this.uri, () => {
                      this._eventManager.trigger({
                          event: "modal_closed",
                          params: [],
                      });
                  }, this._qrcodeModalOptions);
              }
          });
          this.on("connect", () => {
              if (this._qrcodeModal) {
                  this._qrcodeModal.close();
              }
          });
          this.on("call_request_sent", (error, payload) => {
              const { request } = payload.params[0];
              if (isMobile() && this._signingMethods.includes(request.method)) {
                  const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
                  if (mobileLinkUrl) {
                      window.location.href = mobileLinkUrl.href;
                  }
              }
          });
          this.on("wc_sessionRequest", (error, payload) => {
              if (error) {
                  this._eventManager.trigger({
                      event: "error",
                      params: [
                          {
                              code: "SESSION_REQUEST_ERROR",
                              message: error.toString(),
                          },
                      ],
                  });
              }
              this.handshakeId = payload.id;
              this.peerId = payload.params[0].peerId;
              this.peerMeta = payload.params[0].peerMeta;
              const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
              this._eventManager.trigger(internalPayload);
          });
          this.on("wc_sessionUpdate", (error, payload) => {
              if (error) {
                  this._handleSessionResponse(error.message);
              }
              this._handleSessionResponse("Session disconnected", payload.params[0]);
          });
      }
      _initTransport() {
          this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
          this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
          this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
          this._transport.on("error", () => this._eventManager.trigger({
              event: "transport_error",
              params: ["Websocket connection failed"],
          }));
          this._transport.open();
      }
      _formatUri() {
          const protocol = this.protocol;
          const handshakeTopic = this.handshakeTopic;
          const version = this.version;
          const bridge = encodeURIComponent(this.bridge);
          const key = this.key;
          const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
          return uri;
      }
      _parseUri(uri) {
          const result = parseWalletConnectUri(uri);
          if (result.protocol === this.protocol) {
              if (!result.handshakeTopic) {
                  throw Error("Invalid or missing handshakeTopic parameter value");
              }
              const handshakeTopic = result.handshakeTopic;
              if (!result.bridge) {
                  throw Error("Invalid or missing bridge url parameter value");
              }
              const bridge = decodeURIComponent(result.bridge);
              if (!result.key) {
                  throw Error("Invalid or missing key parameter value");
              }
              const key = result.key;
              return { handshakeTopic, bridge, key };
          }
          else {
              throw new Error(ERROR_INVALID_URI);
          }
      }
      async _generateKey() {
          if (this._cryptoLib) {
              const result = await this._cryptoLib.generateKey();
              return result;
          }
          return null;
      }
      async _encrypt(data) {
          const key = this._key;
          if (this._cryptoLib && key) {
              const result = await this._cryptoLib.encrypt(data, key);
              return result;
          }
          return null;
      }
      async _decrypt(payload) {
          const key = this._key;
          if (this._cryptoLib && key) {
              const result = await this._cryptoLib.decrypt(payload, key);
              return result;
          }
          return null;
      }
      _getStorageSession() {
          let result = null;
          if (this._sessionStorage) {
              result = this._sessionStorage.getSession();
          }
          return result;
      }
      _setStorageSession() {
          if (this._sessionStorage) {
              this._sessionStorage.setSession(this.session);
          }
      }
      _removeStorageSession() {
          if (this._sessionStorage) {
              this._sessionStorage.removeSession();
          }
      }
      _manageStorageSession() {
          if (this._connected) {
              this._setStorageSession();
          }
          else {
              this._removeStorageSession();
          }
      }
      _registerPushServer(pushServerOpts) {
          if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
              throw Error("Invalid or missing pushServerOpts.url parameter value");
          }
          if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
              throw Error("Invalid or missing pushServerOpts.type parameter value");
          }
          if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
              throw Error("Invalid or missing pushServerOpts.token parameter value");
          }
          const pushSubscription = {
              bridge: this.bridge,
              topic: this.clientId,
              type: pushServerOpts.type,
              token: pushServerOpts.token,
              peerName: "",
              language: pushServerOpts.language || "",
          };
          this.on("connect", async (error, payload) => {
              if (error) {
                  throw error;
              }
              if (pushServerOpts.peerMeta) {
                  const peerName = payload.params[0].peerMeta.name;
                  pushSubscription.peerName = peerName;
              }
              try {
                  const response = await fetch(`${pushServerOpts.url}/new`, {
                      method: "POST",
                      headers: {
                          Accept: "application/json",
                          "Content-Type": "application/json",
                      },
                      body: JSON.stringify(pushSubscription),
                  });
                  const json = await response.json();
                  if (!json.success) {
                      throw Error("Failed to register in Push Server");
                  }
              }
              catch (error) {
                  throw Error("Failed to register in Push Server");
              }
          });
      }
  }

  function randomBytes(length) {
      const browserCrypto = cjs.getBrowerCrypto();
      return browserCrypto.getRandomValues(new Uint8Array(length));
  }

  const LENGTH_256 = 256;

  const AES_LENGTH = LENGTH_256;
  const HMAC_LENGTH = LENGTH_256;
  const AES_BROWSER_ALGO = "AES-CBC";
  const HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
  const HMAC_BROWSER = "HMAC";

  const ENCRYPT_OP = "encrypt";
  const DECRYPT_OP = "decrypt";
  const SIGN_OP = "sign";
  const VERIFY_OP = "verify";

  function getAlgo(type) {
      return type === AES_BROWSER_ALGO
          ? { length: AES_LENGTH, name: AES_BROWSER_ALGO }
          : {
              hash: { name: HMAC_BROWSER_ALGO },
              name: HMAC_BROWSER,
          };
  }
  function getOps(type) {
      return type === AES_BROWSER_ALGO
          ? [ENCRYPT_OP, DECRYPT_OP]
          : [SIGN_OP, VERIFY_OP];
  }
  async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
      return cjs.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
  }
  async function browserAesEncrypt(iv, key, data) {
      const subtle = cjs.getSubtleCrypto();
      const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
      const result = await subtle.encrypt({
          iv,
          name: AES_BROWSER_ALGO,
      }, cryptoKey, data);
      return new Uint8Array(result);
  }
  async function browserAesDecrypt(iv, key, data) {
      const subtle = cjs.getSubtleCrypto();
      const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
      const result = await subtle.decrypt({
          iv,
          name: AES_BROWSER_ALGO,
      }, cryptoKey, data);
      return new Uint8Array(result);
  }
  async function browserHmacSha256Sign(key, data) {
      const subtle = cjs.getSubtleCrypto();
      const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
      const signature = await subtle.sign({
          length: HMAC_LENGTH,
          name: HMAC_BROWSER,
      }, cryptoKey, data);
      return new Uint8Array(signature);
  }

  function aesCbcEncrypt(iv, key, data) {
      return browserAesEncrypt(iv, key, data);
  }
  function aesCbcDecrypt(iv, key, data) {
      return browserAesDecrypt(iv, key, data);
  }

  async function hmacSha256Sign(key, msg) {
      const result = await browserHmacSha256Sign(key, msg);
      return result;
  }

  async function generateKey(length) {
      const _length = (length || 256) / 8;
      const bytes = randomBytes(_length);
      const result = convertBufferToArrayBuffer(arrayToBuffer_1(bytes));
      return result;
  }
  async function verifyHmac(payload, key) {
      const cipherText = hexToArray_1(payload.data);
      const iv = hexToArray_1(payload.iv);
      const hmac = hexToArray_1(payload.hmac);
      const hmacHex = arrayToHex_1(hmac, false);
      const unsigned = concatArrays_1(cipherText, iv);
      const chmac = await hmacSha256Sign(key, unsigned);
      const chmacHex = arrayToHex_1(chmac, false);
      if (removeHexPrefix_1(hmacHex) === removeHexPrefix_1(chmacHex)) {
          return true;
      }
      return false;
  }
  async function encrypt(data, key, providedIv) {
      const _key = bufferToArray_1(convertArrayBufferToBuffer(key));
      const ivArrayBuffer = providedIv || (await generateKey(128));
      const iv = bufferToArray_1(convertArrayBufferToBuffer(ivArrayBuffer));
      const ivHex = arrayToHex_1(iv, false);
      const contentString = JSON.stringify(data);
      const content = utf8ToArray_1(contentString);
      const cipherText = await aesCbcEncrypt(iv, _key, content);
      const cipherTextHex = arrayToHex_1(cipherText, false);
      const unsigned = concatArrays_1(cipherText, iv);
      const hmac = await hmacSha256Sign(_key, unsigned);
      const hmacHex = arrayToHex_1(hmac, false);
      return {
          data: cipherTextHex,
          hmac: hmacHex,
          iv: ivHex,
      };
  }
  async function decrypt(payload, key) {
      const _key = bufferToArray_1(convertArrayBufferToBuffer(key));
      if (!_key) {
          throw new Error("Missing key: required for decryption");
      }
      const verified = await verifyHmac(payload, _key);
      if (!verified) {
          return null;
      }
      const cipherText = hexToArray_1(payload.data);
      const iv = hexToArray_1(payload.iv);
      const buffer = await aesCbcDecrypt(iv, _key, cipherText);
      const utf8 = arrayToUtf8_1(buffer);
      let data;
      try {
          data = JSON.parse(utf8);
      }
      catch (error) {
          return null;
      }
      return data;
  }

  var cryptoLib = /*#__PURE__*/Object.freeze({
    __proto__: null,
    generateKey: generateKey,
    verifyHmac: verifyHmac,
    encrypt: encrypt,
    decrypt: decrypt
  });

  class WalletConnect$1 extends Connector {
      constructor(connectorOpts, pushServerOpts) {
          super({
              cryptoLib,
              connectorOpts,
              pushServerOpts,
          });
      }
  }

  var lib$1 = {};

  var qrcode = {};

  (function (exports) {
  	//---------------------------------------------------------------------
  	// QRCode for JavaScript
  	//
  	// Copyright (c) 2009 Kazuhiko Arase
  	// Re-written in TypeScript by Makito <sumimakito@hotmail.com>
  	//
  	// URL: http://www.d-project.com/
  	//
  	// Licensed under the MIT license:
  	//   http://www.opensource.org/licenses/mit-license.php
  	//
  	// The word "QR Code" is registered trademark of
  	// DENSO WAVE INCORPORATED
  	//   http://www.denso-wave.com/qrcode/faqpatent-e.html
  	//
  	//---------------------------------------------------------------------
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.QRMath = exports.QRUtil = exports.QRMaskPattern = exports.QRErrorCorrectLevel = exports.QRCodeModel = void 0;
  	function checkQRVersion(version, sText, nCorrectLevel) {
  	    var length = _getUTF8Length(sText);
  	    var i = version - 1;
  	    var nLimit = 0;
  	    switch (nCorrectLevel) {
  	        case exports.QRErrorCorrectLevel.L:
  	            nLimit = QRCodeLimitLength[i][0];
  	            break;
  	        case exports.QRErrorCorrectLevel.M:
  	            nLimit = QRCodeLimitLength[i][1];
  	            break;
  	        case exports.QRErrorCorrectLevel.Q:
  	            nLimit = QRCodeLimitLength[i][2];
  	            break;
  	        case exports.QRErrorCorrectLevel.H:
  	            nLimit = QRCodeLimitLength[i][3];
  	            break;
  	    }
  	    return length <= nLimit;
  	}
  	function _getTypeNumber(sText, nCorrectLevel) {
  	    var nType = 1;
  	    var length = _getUTF8Length(sText);
  	    for (var i = 0, len = QRCodeLimitLength.length; i < len; i++) {
  	        var nLimit = 0;
  	        switch (nCorrectLevel) {
  	            case exports.QRErrorCorrectLevel.L:
  	                nLimit = QRCodeLimitLength[i][0];
  	                break;
  	            case exports.QRErrorCorrectLevel.M:
  	                nLimit = QRCodeLimitLength[i][1];
  	                break;
  	            case exports.QRErrorCorrectLevel.Q:
  	                nLimit = QRCodeLimitLength[i][2];
  	                break;
  	            case exports.QRErrorCorrectLevel.H:
  	                nLimit = QRCodeLimitLength[i][3];
  	                break;
  	        }
  	        if (length <= nLimit) {
  	            break;
  	        }
  	        else {
  	            nType++;
  	        }
  	    }
  	    if (nType > QRCodeLimitLength.length) {
  	        throw new Error("Too long data");
  	    }
  	    return nType;
  	}
  	function _getUTF8Length(sText) {
  	    var replacedText = encodeURI(sText)
  	        .toString()
  	        .replace(/\%[0-9a-fA-F]{2}/g, "a");
  	    return replacedText.length + (replacedText.length != Number(sText) ? 3 : 0);
  	}
  	var QR8bitByte = /** @class */ (function () {
  	    function QR8bitByte(data) {
  	        this.mode = QRMode.MODE_8BIT_BYTE;
  	        this.parsedData = [];
  	        this.data = data;
  	        var byteArrays = [];
  	        // Added to support UTF-8 Characters
  	        for (var i = 0, l = this.data.length; i < l; i++) {
  	            var byteArray = [];
  	            var code = this.data.charCodeAt(i);
  	            if (code > 0x10000) {
  	                byteArray[0] = 0xf0 | ((code & 0x1c0000) >>> 18);
  	                byteArray[1] = 0x80 | ((code & 0x3f000) >>> 12);
  	                byteArray[2] = 0x80 | ((code & 0xfc0) >>> 6);
  	                byteArray[3] = 0x80 | (code & 0x3f);
  	            }
  	            else if (code > 0x800) {
  	                byteArray[0] = 0xe0 | ((code & 0xf000) >>> 12);
  	                byteArray[1] = 0x80 | ((code & 0xfc0) >>> 6);
  	                byteArray[2] = 0x80 | (code & 0x3f);
  	            }
  	            else if (code > 0x80) {
  	                byteArray[0] = 0xc0 | ((code & 0x7c0) >>> 6);
  	                byteArray[1] = 0x80 | (code & 0x3f);
  	            }
  	            else {
  	                byteArray[0] = code;
  	            }
  	            byteArrays.push(byteArray);
  	        }
  	        this.parsedData = Array.prototype.concat.apply([], byteArrays);
  	        if (this.parsedData.length != this.data.length) {
  	            this.parsedData.unshift(191);
  	            this.parsedData.unshift(187);
  	            this.parsedData.unshift(239);
  	        }
  	    }
  	    QR8bitByte.prototype.getLength = function () {
  	        return this.parsedData.length;
  	    };
  	    QR8bitByte.prototype.write = function (buffer) {
  	        for (var i = 0, l = this.parsedData.length; i < l; i++) {
  	            buffer.put(this.parsedData[i], 8);
  	        }
  	    };
  	    return QR8bitByte;
  	}());
  	var QRCodeModel = /** @class */ (function () {
  	    function QRCodeModel(typeNumber, errorCorrectLevel) {
  	        if (typeNumber === void 0) { typeNumber = -1; }
  	        if (errorCorrectLevel === void 0) { errorCorrectLevel = exports.QRErrorCorrectLevel.L; }
  	        this.moduleCount = 0;
  	        this.dataList = [];
  	        this.typeNumber = typeNumber;
  	        this.errorCorrectLevel = errorCorrectLevel;
  	        this.moduleCount = 0;
  	        this.dataList = [];
  	    }
  	    QRCodeModel.prototype.addData = function (data) {
  	        if (this.typeNumber <= 0) {
  	            this.typeNumber = _getTypeNumber(data, this.errorCorrectLevel);
  	        }
  	        else if (this.typeNumber > 40) {
  	            throw new Error("Invalid QR version: " + this.typeNumber);
  	        }
  	        else {
  	            if (!checkQRVersion(this.typeNumber, data, this.errorCorrectLevel)) {
  	                throw new Error("Data is too long for QR version: " + this.typeNumber);
  	            }
  	        }
  	        var newData = new QR8bitByte(data);
  	        this.dataList.push(newData);
  	        this.dataCache = undefined;
  	    };
  	    QRCodeModel.prototype.isDark = function (row, col) {
  	        if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
  	            throw new Error(row + "," + col);
  	        }
  	        return this.modules[row][col];
  	    };
  	    QRCodeModel.prototype.getModuleCount = function () {
  	        return this.moduleCount;
  	    };
  	    QRCodeModel.prototype.make = function () {
  	        this.makeImpl(false, this.getBestMaskPattern());
  	    };
  	    QRCodeModel.prototype.makeImpl = function (test, maskPattern) {
  	        this.moduleCount = this.typeNumber * 4 + 17;
  	        this.modules = new Array(this.moduleCount);
  	        for (var row = 0; row < this.moduleCount; row++) {
  	            this.modules[row] = new Array(this.moduleCount);
  	            for (var col = 0; col < this.moduleCount; col++) {
  	                this.modules[row][col] = null;
  	            }
  	        }
  	        this.setupPositionProbePattern(0, 0);
  	        this.setupPositionProbePattern(this.moduleCount - 7, 0);
  	        this.setupPositionProbePattern(0, this.moduleCount - 7);
  	        this.setupPositionAdjustPattern();
  	        this.setupTimingPattern();
  	        this.setupTypeInfo(test, maskPattern);
  	        if (this.typeNumber >= 7) {
  	            this.setupTypeNumber(test);
  	        }
  	        if (this.dataCache == null) {
  	            this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  	        }
  	        this.mapData(this.dataCache, maskPattern);
  	    };
  	    QRCodeModel.prototype.setupPositionProbePattern = function (row, col) {
  	        for (var r = -1; r <= 7; r++) {
  	            if (row + r <= -1 || this.moduleCount <= row + r)
  	                continue;
  	            for (var c = -1; c <= 7; c++) {
  	                if (col + c <= -1 || this.moduleCount <= col + c)
  	                    continue;
  	                if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
  	                    (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
  	                    (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
  	                    this.modules[row + r][col + c] = true;
  	                }
  	                else {
  	                    this.modules[row + r][col + c] = false;
  	                }
  	            }
  	        }
  	    };
  	    QRCodeModel.prototype.getBestMaskPattern = function () {
  	        if (Number.isInteger(this.maskPattern) && Object.values(exports.QRMaskPattern).includes(this.maskPattern)) {
  	            return this.maskPattern;
  	        }
  	        var minLostPoint = 0;
  	        var pattern = 0;
  	        for (var i = 0; i < 8; i++) {
  	            this.makeImpl(true, i);
  	            var lostPoint = QRUtil.getLostPoint(this);
  	            if (i == 0 || minLostPoint > lostPoint) {
  	                minLostPoint = lostPoint;
  	                pattern = i;
  	            }
  	        }
  	        return pattern;
  	    };
  	    QRCodeModel.prototype.setupTimingPattern = function () {
  	        for (var r = 8; r < this.moduleCount - 8; r++) {
  	            if (this.modules[r][6] != null) {
  	                continue;
  	            }
  	            this.modules[r][6] = r % 2 == 0;
  	        }
  	        for (var c = 8; c < this.moduleCount - 8; c++) {
  	            if (this.modules[6][c] != null) {
  	                continue;
  	            }
  	            this.modules[6][c] = c % 2 == 0;
  	        }
  	    };
  	    QRCodeModel.prototype.setupPositionAdjustPattern = function () {
  	        var pos = QRUtil.getPatternPosition(this.typeNumber);
  	        for (var i = 0; i < pos.length; i++) {
  	            for (var j = 0; j < pos.length; j++) {
  	                var row = pos[i];
  	                var col = pos[j];
  	                if (this.modules[row][col] != null) {
  	                    continue;
  	                }
  	                for (var r = -2; r <= 2; r++) {
  	                    for (var c = -2; c <= 2; c++) {
  	                        if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
  	                            this.modules[row + r][col + c] = true;
  	                        }
  	                        else {
  	                            this.modules[row + r][col + c] = false;
  	                        }
  	                    }
  	                }
  	            }
  	        }
  	    };
  	    QRCodeModel.prototype.setupTypeNumber = function (test) {
  	        var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
  	        for (var i = 0; i < 18; i++) {
  	            var mod = !test && ((bits >> i) & 1) == 1;
  	            this.modules[Math.floor(i / 3)][(i % 3) + this.moduleCount - 8 - 3] = mod;
  	        }
  	        for (var i = 0; i < 18; i++) {
  	            var mod = !test && ((bits >> i) & 1) == 1;
  	            this.modules[(i % 3) + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
  	        }
  	    };
  	    QRCodeModel.prototype.setupTypeInfo = function (test, maskPattern) {
  	        var data = (this.errorCorrectLevel << 3) | maskPattern;
  	        var bits = QRUtil.getBCHTypeInfo(data);
  	        for (var i = 0; i < 15; i++) {
  	            var mod = !test && ((bits >> i) & 1) == 1;
  	            if (i < 6) {
  	                this.modules[i][8] = mod;
  	            }
  	            else if (i < 8) {
  	                this.modules[i + 1][8] = mod;
  	            }
  	            else {
  	                this.modules[this.moduleCount - 15 + i][8] = mod;
  	            }
  	        }
  	        for (var i = 0; i < 15; i++) {
  	            var mod = !test && ((bits >> i) & 1) == 1;
  	            if (i < 8) {
  	                this.modules[8][this.moduleCount - i - 1] = mod;
  	            }
  	            else if (i < 9) {
  	                this.modules[8][15 - i - 1 + 1] = mod;
  	            }
  	            else {
  	                this.modules[8][15 - i - 1] = mod;
  	            }
  	        }
  	        this.modules[this.moduleCount - 8][8] = !test;
  	    };
  	    QRCodeModel.prototype.mapData = function (data, maskPattern) {
  	        var inc = -1;
  	        var row = this.moduleCount - 1;
  	        var bitIndex = 7;
  	        var byteIndex = 0;
  	        for (var col = this.moduleCount - 1; col > 0; col -= 2) {
  	            if (col == 6)
  	                col--;
  	            while (true) {
  	                for (var c = 0; c < 2; c++) {
  	                    if (this.modules[row][col - c] == null) {
  	                        var dark = false;
  	                        if (byteIndex < data.length) {
  	                            dark = ((data[byteIndex] >>> bitIndex) & 1) == 1;
  	                        }
  	                        var mask = QRUtil.getMask(maskPattern, row, col - c);
  	                        if (mask) {
  	                            dark = !dark;
  	                        }
  	                        this.modules[row][col - c] = dark;
  	                        bitIndex--;
  	                        if (bitIndex == -1) {
  	                            byteIndex++;
  	                            bitIndex = 7;
  	                        }
  	                    }
  	                }
  	                row += inc;
  	                if (row < 0 || this.moduleCount <= row) {
  	                    row -= inc;
  	                    inc = -inc;
  	                    break;
  	                }
  	            }
  	        }
  	    };
  	    QRCodeModel.createData = function (typeNumber, errorCorrectLevel, dataList) {
  	        var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  	        var buffer = new QRBitBuffer();
  	        for (var i = 0; i < dataList.length; i++) {
  	            var data = dataList[i];
  	            buffer.put(data.mode, 4);
  	            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
  	            data.write(buffer);
  	        }
  	        var totalDataCount = 0;
  	        for (var i = 0; i < rsBlocks.length; i++) {
  	            totalDataCount += rsBlocks[i].dataCount;
  	        }
  	        if (buffer.getLengthInBits() > totalDataCount * 8) {
  	            throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  	        }
  	        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
  	            buffer.put(0, 4);
  	        }
  	        while (buffer.getLengthInBits() % 8 != 0) {
  	            buffer.putBit(false);
  	        }
  	        while (true) {
  	            if (buffer.getLengthInBits() >= totalDataCount * 8) {
  	                break;
  	            }
  	            buffer.put(QRCodeModel.PAD0, 8);
  	            if (buffer.getLengthInBits() >= totalDataCount * 8) {
  	                break;
  	            }
  	            buffer.put(QRCodeModel.PAD1, 8);
  	        }
  	        return QRCodeModel.createBytes(buffer, rsBlocks);
  	    };
  	    QRCodeModel.createBytes = function (buffer, rsBlocks) {
  	        var offset = 0;
  	        var maxDcCount = 0;
  	        var maxEcCount = 0;
  	        var dcdata = new Array(rsBlocks.length);
  	        var ecdata = new Array(rsBlocks.length);
  	        for (var r = 0; r < rsBlocks.length; r++) {
  	            var dcCount = rsBlocks[r].dataCount;
  	            var ecCount = rsBlocks[r].totalCount - dcCount;
  	            maxDcCount = Math.max(maxDcCount, dcCount);
  	            maxEcCount = Math.max(maxEcCount, ecCount);
  	            dcdata[r] = new Array(dcCount);
  	            for (var i = 0; i < dcdata[r].length; i++) {
  	                dcdata[r][i] = 0xff & buffer.buffer[i + offset];
  	            }
  	            offset += dcCount;
  	            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
  	            var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
  	            var modPoly = rawPoly.mod(rsPoly);
  	            ecdata[r] = new Array(rsPoly.getLength() - 1);
  	            for (var i = 0; i < ecdata[r].length; i++) {
  	                var modIndex = i + modPoly.getLength() - ecdata[r].length;
  	                ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
  	            }
  	        }
  	        var totalCodeCount = 0;
  	        for (var i = 0; i < rsBlocks.length; i++) {
  	            totalCodeCount += rsBlocks[i].totalCount;
  	        }
  	        var data = new Array(totalCodeCount);
  	        var index = 0;
  	        for (var i = 0; i < maxDcCount; i++) {
  	            for (var r = 0; r < rsBlocks.length; r++) {
  	                if (i < dcdata[r].length) {
  	                    data[index++] = dcdata[r][i];
  	                }
  	            }
  	        }
  	        for (var i = 0; i < maxEcCount; i++) {
  	            for (var r = 0; r < rsBlocks.length; r++) {
  	                if (i < ecdata[r].length) {
  	                    data[index++] = ecdata[r][i];
  	                }
  	            }
  	        }
  	        return data;
  	    };
  	    QRCodeModel.PAD0 = 0xec;
  	    QRCodeModel.PAD1 = 0x11;
  	    return QRCodeModel;
  	}());
  	exports.QRCodeModel = QRCodeModel;
  	exports.QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
  	var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
  	exports.QRMaskPattern = {
  	    PATTERN000: 0,
  	    PATTERN001: 1,
  	    PATTERN010: 2,
  	    PATTERN011: 3,
  	    PATTERN100: 4,
  	    PATTERN101: 5,
  	    PATTERN110: 6,
  	    PATTERN111: 7,
  	};
  	var QRUtil = /** @class */ (function () {
  	    function QRUtil() {
  	    }
  	    QRUtil.getBCHTypeInfo = function (data) {
  	        var d = data << 10;
  	        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
  	            d ^= QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15));
  	        }
  	        return ((data << 10) | d) ^ QRUtil.G15_MASK;
  	    };
  	    QRUtil.getBCHTypeNumber = function (data) {
  	        var d = data << 12;
  	        while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
  	            d ^= QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18));
  	        }
  	        return (data << 12) | d;
  	    };
  	    QRUtil.getBCHDigit = function (data) {
  	        var digit = 0;
  	        while (data != 0) {
  	            digit++;
  	            data >>>= 1;
  	        }
  	        return digit;
  	    };
  	    QRUtil.getPatternPosition = function (typeNumber) {
  	        return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  	    };
  	    QRUtil.getMask = function (maskPattern, i, j) {
  	        switch (maskPattern) {
  	            case exports.QRMaskPattern.PATTERN000:
  	                return (i + j) % 2 == 0;
  	            case exports.QRMaskPattern.PATTERN001:
  	                return i % 2 == 0;
  	            case exports.QRMaskPattern.PATTERN010:
  	                return j % 3 == 0;
  	            case exports.QRMaskPattern.PATTERN011:
  	                return (i + j) % 3 == 0;
  	            case exports.QRMaskPattern.PATTERN100:
  	                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
  	            case exports.QRMaskPattern.PATTERN101:
  	                return ((i * j) % 2) + ((i * j) % 3) == 0;
  	            case exports.QRMaskPattern.PATTERN110:
  	                return (((i * j) % 2) + ((i * j) % 3)) % 2 == 0;
  	            case exports.QRMaskPattern.PATTERN111:
  	                return (((i * j) % 3) + ((i + j) % 2)) % 2 == 0;
  	            default:
  	                throw new Error("bad maskPattern:" + maskPattern);
  	        }
  	    };
  	    QRUtil.getErrorCorrectPolynomial = function (errorCorrectLength) {
  	        var a = new QRPolynomial([1], 0);
  	        for (var i = 0; i < errorCorrectLength; i++) {
  	            a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
  	        }
  	        return a;
  	    };
  	    QRUtil.getLengthInBits = function (mode, type) {
  	        if (1 <= type && type < 10) {
  	            switch (mode) {
  	                case QRMode.MODE_NUMBER:
  	                    return 10;
  	                case QRMode.MODE_ALPHA_NUM:
  	                    return 9;
  	                case QRMode.MODE_8BIT_BYTE:
  	                    return 8;
  	                case QRMode.MODE_KANJI:
  	                    return 8;
  	                default:
  	                    throw new Error("mode:" + mode);
  	            }
  	        }
  	        else if (type < 27) {
  	            switch (mode) {
  	                case QRMode.MODE_NUMBER:
  	                    return 12;
  	                case QRMode.MODE_ALPHA_NUM:
  	                    return 11;
  	                case QRMode.MODE_8BIT_BYTE:
  	                    return 16;
  	                case QRMode.MODE_KANJI:
  	                    return 10;
  	                default:
  	                    throw new Error("mode:" + mode);
  	            }
  	        }
  	        else if (type < 41) {
  	            switch (mode) {
  	                case QRMode.MODE_NUMBER:
  	                    return 14;
  	                case QRMode.MODE_ALPHA_NUM:
  	                    return 13;
  	                case QRMode.MODE_8BIT_BYTE:
  	                    return 16;
  	                case QRMode.MODE_KANJI:
  	                    return 12;
  	                default:
  	                    throw new Error("mode:" + mode);
  	            }
  	        }
  	        else {
  	            throw new Error("type:" + type);
  	        }
  	    };
  	    QRUtil.getLostPoint = function (qrCode) {
  	        var moduleCount = qrCode.getModuleCount();
  	        var lostPoint = 0;
  	        for (var row = 0; row < moduleCount; row++) {
  	            for (var col = 0; col < moduleCount; col++) {
  	                var sameCount = 0;
  	                var dark = qrCode.isDark(row, col);
  	                for (var r = -1; r <= 1; r++) {
  	                    if (row + r < 0 || moduleCount <= row + r) {
  	                        continue;
  	                    }
  	                    for (var c = -1; c <= 1; c++) {
  	                        if (col + c < 0 || moduleCount <= col + c) {
  	                            continue;
  	                        }
  	                        if (r == 0 && c == 0) {
  	                            continue;
  	                        }
  	                        if (dark == qrCode.isDark(row + r, col + c)) {
  	                            sameCount++;
  	                        }
  	                    }
  	                }
  	                if (sameCount > 5) {
  	                    lostPoint += 3 + sameCount - 5;
  	                }
  	            }
  	        }
  	        for (var row = 0; row < moduleCount - 1; row++) {
  	            for (var col = 0; col < moduleCount - 1; col++) {
  	                var count = 0;
  	                if (qrCode.isDark(row, col))
  	                    count++;
  	                if (qrCode.isDark(row + 1, col))
  	                    count++;
  	                if (qrCode.isDark(row, col + 1))
  	                    count++;
  	                if (qrCode.isDark(row + 1, col + 1))
  	                    count++;
  	                if (count == 0 || count == 4) {
  	                    lostPoint += 3;
  	                }
  	            }
  	        }
  	        for (var row = 0; row < moduleCount; row++) {
  	            for (var col = 0; col < moduleCount - 6; col++) {
  	                if (qrCode.isDark(row, col) &&
  	                    !qrCode.isDark(row, col + 1) &&
  	                    qrCode.isDark(row, col + 2) &&
  	                    qrCode.isDark(row, col + 3) &&
  	                    qrCode.isDark(row, col + 4) &&
  	                    !qrCode.isDark(row, col + 5) &&
  	                    qrCode.isDark(row, col + 6)) {
  	                    lostPoint += 40;
  	                }
  	            }
  	        }
  	        for (var col = 0; col < moduleCount; col++) {
  	            for (var row = 0; row < moduleCount - 6; row++) {
  	                if (qrCode.isDark(row, col) &&
  	                    !qrCode.isDark(row + 1, col) &&
  	                    qrCode.isDark(row + 2, col) &&
  	                    qrCode.isDark(row + 3, col) &&
  	                    qrCode.isDark(row + 4, col) &&
  	                    !qrCode.isDark(row + 5, col) &&
  	                    qrCode.isDark(row + 6, col)) {
  	                    lostPoint += 40;
  	                }
  	            }
  	        }
  	        var darkCount = 0;
  	        for (var col = 0; col < moduleCount; col++) {
  	            for (var row = 0; row < moduleCount; row++) {
  	                if (qrCode.isDark(row, col)) {
  	                    darkCount++;
  	                }
  	            }
  	        }
  	        var ratio = Math.abs((100 * darkCount) / moduleCount / moduleCount - 50) / 5;
  	        lostPoint += ratio * 10;
  	        return lostPoint;
  	    };
  	    QRUtil.PATTERN_POSITION_TABLE = [
  	        [],
  	        [6, 18],
  	        [6, 22],
  	        [6, 26],
  	        [6, 30],
  	        [6, 34],
  	        [6, 22, 38],
  	        [6, 24, 42],
  	        [6, 26, 46],
  	        [6, 28, 50],
  	        [6, 30, 54],
  	        [6, 32, 58],
  	        [6, 34, 62],
  	        [6, 26, 46, 66],
  	        [6, 26, 48, 70],
  	        [6, 26, 50, 74],
  	        [6, 30, 54, 78],
  	        [6, 30, 56, 82],
  	        [6, 30, 58, 86],
  	        [6, 34, 62, 90],
  	        [6, 28, 50, 72, 94],
  	        [6, 26, 50, 74, 98],
  	        [6, 30, 54, 78, 102],
  	        [6, 28, 54, 80, 106],
  	        [6, 32, 58, 84, 110],
  	        [6, 30, 58, 86, 114],
  	        [6, 34, 62, 90, 118],
  	        [6, 26, 50, 74, 98, 122],
  	        [6, 30, 54, 78, 102, 126],
  	        [6, 26, 52, 78, 104, 130],
  	        [6, 30, 56, 82, 108, 134],
  	        [6, 34, 60, 86, 112, 138],
  	        [6, 30, 58, 86, 114, 142],
  	        [6, 34, 62, 90, 118, 146],
  	        [6, 30, 54, 78, 102, 126, 150],
  	        [6, 24, 50, 76, 102, 128, 154],
  	        [6, 28, 54, 80, 106, 132, 158],
  	        [6, 32, 58, 84, 110, 136, 162],
  	        [6, 26, 54, 82, 110, 138, 166],
  	        [6, 30, 58, 86, 114, 142, 170],
  	    ];
  	    QRUtil.G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
  	    QRUtil.G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
  	    QRUtil.G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
  	    return QRUtil;
  	}());
  	exports.QRUtil = QRUtil;
  	var QRMath = /** @class */ (function () {
  	    function QRMath() {
  	    }
  	    QRMath.glog = function (n) {
  	        if (n < 1) {
  	            throw new Error("glog(" + n + ")");
  	        }
  	        return QRMath.LOG_TABLE[n];
  	    };
  	    QRMath.gexp = function (n) {
  	        while (n < 0) {
  	            n += 255;
  	        }
  	        while (n >= 256) {
  	            n -= 255;
  	        }
  	        return QRMath.EXP_TABLE[n];
  	    };
  	    QRMath.EXP_TABLE = new Array(256);
  	    QRMath.LOG_TABLE = new Array(256);
  	    QRMath._constructor = (function () {
  	        for (var i = 0; i < 8; i++) {
  	            QRMath.EXP_TABLE[i] = 1 << i;
  	        }
  	        for (var i = 8; i < 256; i++) {
  	            QRMath.EXP_TABLE[i] =
  	                QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  	        }
  	        for (var i = 0; i < 255; i++) {
  	            QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  	        }
  	    })();
  	    return QRMath;
  	}());
  	exports.QRMath = QRMath;
  	var QRPolynomial = /** @class */ (function () {
  	    function QRPolynomial(num, shift) {
  	        if (num.length == undefined) {
  	            throw new Error(num.length + "/" + shift);
  	        }
  	        var offset = 0;
  	        while (offset < num.length && num[offset] == 0) {
  	            offset++;
  	        }
  	        this.num = new Array(num.length - offset + shift);
  	        for (var i = 0; i < num.length - offset; i++) {
  	            this.num[i] = num[i + offset];
  	        }
  	    }
  	    QRPolynomial.prototype.get = function (index) {
  	        return this.num[index];
  	    };
  	    QRPolynomial.prototype.getLength = function () {
  	        return this.num.length;
  	    };
  	    QRPolynomial.prototype.multiply = function (e) {
  	        var num = new Array(this.getLength() + e.getLength() - 1);
  	        for (var i = 0; i < this.getLength(); i++) {
  	            for (var j = 0; j < e.getLength(); j++) {
  	                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
  	            }
  	        }
  	        return new QRPolynomial(num, 0);
  	    };
  	    QRPolynomial.prototype.mod = function (e) {
  	        if (this.getLength() - e.getLength() < 0) {
  	            return this;
  	        }
  	        var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
  	        var num = new Array(this.getLength());
  	        for (var i = 0; i < this.getLength(); i++) {
  	            num[i] = this.get(i);
  	        }
  	        for (var i = 0; i < e.getLength(); i++) {
  	            num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
  	        }
  	        return new QRPolynomial(num, 0).mod(e);
  	    };
  	    return QRPolynomial;
  	}());
  	var QRRSBlock = /** @class */ (function () {
  	    function QRRSBlock(totalCount, dataCount) {
  	        this.totalCount = totalCount;
  	        this.dataCount = dataCount;
  	    }
  	    QRRSBlock.getRSBlocks = function (typeNumber, errorCorrectLevel) {
  	        var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  	        if (rsBlock == undefined) {
  	            throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  	        }
  	        var length = rsBlock.length / 3;
  	        var list = [];
  	        for (var i = 0; i < length; i++) {
  	            var count = rsBlock[i * 3 + 0];
  	            var totalCount = rsBlock[i * 3 + 1];
  	            var dataCount = rsBlock[i * 3 + 2];
  	            for (var j = 0; j < count; j++) {
  	                list.push(new QRRSBlock(totalCount, dataCount));
  	            }
  	        }
  	        return list;
  	    };
  	    QRRSBlock.getRsBlockTable = function (typeNumber, errorCorrectLevel) {
  	        switch (errorCorrectLevel) {
  	            case exports.QRErrorCorrectLevel.L:
  	                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
  	            case exports.QRErrorCorrectLevel.M:
  	                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
  	            case exports.QRErrorCorrectLevel.Q:
  	                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
  	            case exports.QRErrorCorrectLevel.H:
  	                return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
  	            default:
  	                return undefined;
  	        }
  	    };
  	    QRRSBlock.RS_BLOCK_TABLE = [
  	        [1, 26, 19],
  	        [1, 26, 16],
  	        [1, 26, 13],
  	        [1, 26, 9],
  	        [1, 44, 34],
  	        [1, 44, 28],
  	        [1, 44, 22],
  	        [1, 44, 16],
  	        [1, 70, 55],
  	        [1, 70, 44],
  	        [2, 35, 17],
  	        [2, 35, 13],
  	        [1, 100, 80],
  	        [2, 50, 32],
  	        [2, 50, 24],
  	        [4, 25, 9],
  	        [1, 134, 108],
  	        [2, 67, 43],
  	        [2, 33, 15, 2, 34, 16],
  	        [2, 33, 11, 2, 34, 12],
  	        [2, 86, 68],
  	        [4, 43, 27],
  	        [4, 43, 19],
  	        [4, 43, 15],
  	        [2, 98, 78],
  	        [4, 49, 31],
  	        [2, 32, 14, 4, 33, 15],
  	        [4, 39, 13, 1, 40, 14],
  	        [2, 121, 97],
  	        [2, 60, 38, 2, 61, 39],
  	        [4, 40, 18, 2, 41, 19],
  	        [4, 40, 14, 2, 41, 15],
  	        [2, 146, 116],
  	        [3, 58, 36, 2, 59, 37],
  	        [4, 36, 16, 4, 37, 17],
  	        [4, 36, 12, 4, 37, 13],
  	        [2, 86, 68, 2, 87, 69],
  	        [4, 69, 43, 1, 70, 44],
  	        [6, 43, 19, 2, 44, 20],
  	        [6, 43, 15, 2, 44, 16],
  	        [4, 101, 81],
  	        [1, 80, 50, 4, 81, 51],
  	        [4, 50, 22, 4, 51, 23],
  	        [3, 36, 12, 8, 37, 13],
  	        [2, 116, 92, 2, 117, 93],
  	        [6, 58, 36, 2, 59, 37],
  	        [4, 46, 20, 6, 47, 21],
  	        [7, 42, 14, 4, 43, 15],
  	        [4, 133, 107],
  	        [8, 59, 37, 1, 60, 38],
  	        [8, 44, 20, 4, 45, 21],
  	        [12, 33, 11, 4, 34, 12],
  	        [3, 145, 115, 1, 146, 116],
  	        [4, 64, 40, 5, 65, 41],
  	        [11, 36, 16, 5, 37, 17],
  	        [11, 36, 12, 5, 37, 13],
  	        [5, 109, 87, 1, 110, 88],
  	        [5, 65, 41, 5, 66, 42],
  	        [5, 54, 24, 7, 55, 25],
  	        [11, 36, 12],
  	        [5, 122, 98, 1, 123, 99],
  	        [7, 73, 45, 3, 74, 46],
  	        [15, 43, 19, 2, 44, 20],
  	        [3, 45, 15, 13, 46, 16],
  	        [1, 135, 107, 5, 136, 108],
  	        [10, 74, 46, 1, 75, 47],
  	        [1, 50, 22, 15, 51, 23],
  	        [2, 42, 14, 17, 43, 15],
  	        [5, 150, 120, 1, 151, 121],
  	        [9, 69, 43, 4, 70, 44],
  	        [17, 50, 22, 1, 51, 23],
  	        [2, 42, 14, 19, 43, 15],
  	        [3, 141, 113, 4, 142, 114],
  	        [3, 70, 44, 11, 71, 45],
  	        [17, 47, 21, 4, 48, 22],
  	        [9, 39, 13, 16, 40, 14],
  	        [3, 135, 107, 5, 136, 108],
  	        [3, 67, 41, 13, 68, 42],
  	        [15, 54, 24, 5, 55, 25],
  	        [15, 43, 15, 10, 44, 16],
  	        [4, 144, 116, 4, 145, 117],
  	        [17, 68, 42],
  	        [17, 50, 22, 6, 51, 23],
  	        [19, 46, 16, 6, 47, 17],
  	        [2, 139, 111, 7, 140, 112],
  	        [17, 74, 46],
  	        [7, 54, 24, 16, 55, 25],
  	        [34, 37, 13],
  	        [4, 151, 121, 5, 152, 122],
  	        [4, 75, 47, 14, 76, 48],
  	        [11, 54, 24, 14, 55, 25],
  	        [16, 45, 15, 14, 46, 16],
  	        [6, 147, 117, 4, 148, 118],
  	        [6, 73, 45, 14, 74, 46],
  	        [11, 54, 24, 16, 55, 25],
  	        [30, 46, 16, 2, 47, 17],
  	        [8, 132, 106, 4, 133, 107],
  	        [8, 75, 47, 13, 76, 48],
  	        [7, 54, 24, 22, 55, 25],
  	        [22, 45, 15, 13, 46, 16],
  	        [10, 142, 114, 2, 143, 115],
  	        [19, 74, 46, 4, 75, 47],
  	        [28, 50, 22, 6, 51, 23],
  	        [33, 46, 16, 4, 47, 17],
  	        [8, 152, 122, 4, 153, 123],
  	        [22, 73, 45, 3, 74, 46],
  	        [8, 53, 23, 26, 54, 24],
  	        [12, 45, 15, 28, 46, 16],
  	        [3, 147, 117, 10, 148, 118],
  	        [3, 73, 45, 23, 74, 46],
  	        [4, 54, 24, 31, 55, 25],
  	        [11, 45, 15, 31, 46, 16],
  	        [7, 146, 116, 7, 147, 117],
  	        [21, 73, 45, 7, 74, 46],
  	        [1, 53, 23, 37, 54, 24],
  	        [19, 45, 15, 26, 46, 16],
  	        [5, 145, 115, 10, 146, 116],
  	        [19, 75, 47, 10, 76, 48],
  	        [15, 54, 24, 25, 55, 25],
  	        [23, 45, 15, 25, 46, 16],
  	        [13, 145, 115, 3, 146, 116],
  	        [2, 74, 46, 29, 75, 47],
  	        [42, 54, 24, 1, 55, 25],
  	        [23, 45, 15, 28, 46, 16],
  	        [17, 145, 115],
  	        [10, 74, 46, 23, 75, 47],
  	        [10, 54, 24, 35, 55, 25],
  	        [19, 45, 15, 35, 46, 16],
  	        [17, 145, 115, 1, 146, 116],
  	        [14, 74, 46, 21, 75, 47],
  	        [29, 54, 24, 19, 55, 25],
  	        [11, 45, 15, 46, 46, 16],
  	        [13, 145, 115, 6, 146, 116],
  	        [14, 74, 46, 23, 75, 47],
  	        [44, 54, 24, 7, 55, 25],
  	        [59, 46, 16, 1, 47, 17],
  	        [12, 151, 121, 7, 152, 122],
  	        [12, 75, 47, 26, 76, 48],
  	        [39, 54, 24, 14, 55, 25],
  	        [22, 45, 15, 41, 46, 16],
  	        [6, 151, 121, 14, 152, 122],
  	        [6, 75, 47, 34, 76, 48],
  	        [46, 54, 24, 10, 55, 25],
  	        [2, 45, 15, 64, 46, 16],
  	        [17, 152, 122, 4, 153, 123],
  	        [29, 74, 46, 14, 75, 47],
  	        [49, 54, 24, 10, 55, 25],
  	        [24, 45, 15, 46, 46, 16],
  	        [4, 152, 122, 18, 153, 123],
  	        [13, 74, 46, 32, 75, 47],
  	        [48, 54, 24, 14, 55, 25],
  	        [42, 45, 15, 32, 46, 16],
  	        [20, 147, 117, 4, 148, 118],
  	        [40, 75, 47, 7, 76, 48],
  	        [43, 54, 24, 22, 55, 25],
  	        [10, 45, 15, 67, 46, 16],
  	        [19, 148, 118, 6, 149, 119],
  	        [18, 75, 47, 31, 76, 48],
  	        [34, 54, 24, 34, 55, 25],
  	        [20, 45, 15, 61, 46, 16],
  	    ];
  	    return QRRSBlock;
  	}());
  	var QRBitBuffer = /** @class */ (function () {
  	    function QRBitBuffer() {
  	        this.buffer = [];
  	        this.length = 0;
  	    }
  	    QRBitBuffer.prototype.get = function (index) {
  	        var bufIndex = Math.floor(index / 8);
  	        return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) == 1;
  	    };
  	    QRBitBuffer.prototype.put = function (num, length) {
  	        for (var i = 0; i < length; i++) {
  	            this.putBit(((num >>> (length - i - 1)) & 1) == 1);
  	        }
  	    };
  	    QRBitBuffer.prototype.getLengthInBits = function () {
  	        return this.length;
  	    };
  	    QRBitBuffer.prototype.putBit = function (bit) {
  	        var bufIndex = Math.floor(this.length / 8);
  	        if (this.buffer.length <= bufIndex) {
  	            this.buffer.push(0);
  	        }
  	        if (bit) {
  	            this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
  	        }
  	        this.length++;
  	    };
  	    return QRBitBuffer;
  	}());
  	var QRCodeLimitLength = [
  	    [17, 14, 11, 7],
  	    [32, 26, 20, 14],
  	    [53, 42, 32, 24],
  	    [78, 62, 46, 34],
  	    [106, 84, 60, 44],
  	    [134, 106, 74, 58],
  	    [154, 122, 86, 64],
  	    [192, 152, 108, 84],
  	    [230, 180, 130, 98],
  	    [271, 213, 151, 119],
  	    [321, 251, 177, 137],
  	    [367, 287, 203, 155],
  	    [425, 331, 241, 177],
  	    [458, 362, 258, 194],
  	    [520, 412, 292, 220],
  	    [586, 450, 322, 250],
  	    [644, 504, 364, 280],
  	    [718, 560, 394, 310],
  	    [792, 624, 442, 338],
  	    [858, 666, 482, 382],
  	    [929, 711, 509, 403],
  	    [1003, 779, 565, 439],
  	    [1091, 857, 611, 461],
  	    [1171, 911, 661, 511],
  	    [1273, 997, 715, 535],
  	    [1367, 1059, 751, 593],
  	    [1465, 1125, 805, 625],
  	    [1528, 1190, 868, 658],
  	    [1628, 1264, 908, 698],
  	    [1732, 1370, 982, 742],
  	    [1840, 1452, 1030, 790],
  	    [1952, 1538, 1112, 842],
  	    [2068, 1628, 1168, 898],
  	    [2188, 1722, 1228, 958],
  	    [2303, 1809, 1283, 983],
  	    [2431, 1911, 1351, 1051],
  	    [2563, 1989, 1423, 1093],
  	    [2699, 2099, 1499, 1139],
  	    [2809, 2213, 1579, 1219],
  	    [2953, 2331, 1663, 1273],
  	];
  } (qrcode));

  var awesomeQr = {};

  var browser = {};

  /**
   * Font RegExp helpers.
   */

  const weights = 'bold|bolder|lighter|[1-9]00';
  const styles = 'italic|oblique';
  const variants = 'small-caps';
  const stretches = 'ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded';
  const units = 'px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q';
  const string = '\'([^\']+)\'|"([^"]+)"|[\\w\\s-]+';

  // [ [ <font-style> || <font-variant-css21> || <font-weight> || <font-stretch> ]?
  //    <font-size> [ / <line-height> ]? <font-family> ]
  // https://drafts.csswg.org/css-fonts-3/#font-prop
  const weightRe = new RegExp(`(${weights}) +`, 'i');
  const styleRe = new RegExp(`(${styles}) +`, 'i');
  const variantRe = new RegExp(`(${variants}) +`, 'i');
  const stretchRe = new RegExp(`(${stretches}) +`, 'i');
  const sizeFamilyRe = new RegExp(
    `([\\d\\.]+)(${units}) *((?:${string})( *, *(?:${string}))*)`);

  /**
   * Cache font parsing.
   */

  const cache = {};

  const defaultHeight = 16; // pt, common browser default

  /**
   * Parse font `str`.
   *
   * @param {String} str
   * @return {Object} Parsed font. `size` is in device units. `unit` is the unit
   *   appearing in the input string.
   * @api private
   */

  var parseFont$1 = str => {
    // Cached
    if (cache[str]) return cache[str]

    // Try for required properties first.
    const sizeFamily = sizeFamilyRe.exec(str);
    if (!sizeFamily) return // invalid

    // Default values and required properties
    const font = {
      weight: 'normal',
      style: 'normal',
      stretch: 'normal',
      variant: 'normal',
      size: parseFloat(sizeFamily[1]),
      unit: sizeFamily[2],
      family: sizeFamily[3].replace(/["']/g, '').replace(/ *, */g, ',')
    };

    // Optional, unordered properties.
    let weight, style, variant, stretch;
    // Stop search at `sizeFamily.index`
    const substr = str.substring(0, sizeFamily.index);
    if ((weight = weightRe.exec(substr))) font.weight = weight[1];
    if ((style = styleRe.exec(substr))) font.style = style[1];
    if ((variant = variantRe.exec(substr))) font.variant = variant[1];
    if ((stretch = stretchRe.exec(substr))) font.stretch = stretch[1];

    // Convert to device units. (`font.unit` is the original unit)
    // TODO: ch, ex
    switch (font.unit) {
      case 'pt':
        font.size /= 0.75;
        break
      case 'pc':
        font.size *= 16;
        break
      case 'in':
        font.size *= 96;
        break
      case 'cm':
        font.size *= 96.0 / 2.54;
        break
      case 'mm':
        font.size *= 96.0 / 25.4;
        break
      case '%':
        // TODO disabled because existing unit tests assume 100
        // font.size *= defaultHeight / 100 / 0.75
        break
      case 'em':
      case 'rem':
        font.size *= defaultHeight / 0.75;
        break
      case 'q':
        font.size *= 96 / 25.4 / 4;
        break
    }

    return (cache[str] = font)
  };

  /* globals document, ImageData */

  const parseFont = parseFont$1;

  browser.parseFont = parseFont;

  browser.createCanvas = function (width, height) {
    return Object.assign(document.createElement('canvas'), { width: width, height: height })
  };

  browser.createImageData = function (array, width, height) {
    // Browser implementation of ImageData looks at the number of arguments passed
    switch (arguments.length) {
      case 0: return new ImageData()
      case 1: return new ImageData(array)
      case 2: return new ImageData(array, width)
      default: return new ImageData(array, width, height)
    }
  };

  browser.loadImage = function (src, options) {
    return new Promise(function (resolve, reject) {
      const image = Object.assign(document.createElement('img'), options);

      function cleanup () {
        image.onload = null;
        image.onerror = null;
      }

      image.onload = function () { cleanup(); resolve(image); };
      image.onerror = function () { cleanup(); reject(new Error('Failed to load the image "' + src + '"')); };

      image.src = src;
    })
  };

  var gifuctJs = {};

  var gif = {};

  var lib = {};

  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.loop = lib.conditional = lib.parse = void 0;

  var parse = function parse(stream, schema) {
    var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;

    if (Array.isArray(schema)) {
      schema.forEach(function (partSchema) {
        return parse(stream, partSchema, result, parent);
      });
    } else if (typeof schema === 'function') {
      schema(stream, result, parent, parse);
    } else {
      var key = Object.keys(schema)[0];

      if (Array.isArray(schema[key])) {
        parent[key] = {};
        parse(stream, schema[key], result, parent[key]);
      } else {
        parent[key] = schema[key](stream, result, parent, parse);
      }
    }

    return result;
  };

  lib.parse = parse;

  var conditional = function conditional(schema, conditionFunc) {
    return function (stream, result, parent, parse) {
      if (conditionFunc(stream, result, parent)) {
        parse(stream, schema, result, parent);
      }
    };
  };

  lib.conditional = conditional;

  var loop = function loop(schema, continueFunc) {
    return function (stream, result, parent, parse) {
      var arr = [];
      var lastStreamPos = stream.pos;

      while (continueFunc(stream, result, parent)) {
        var newParent = {};
        parse(stream, schema, result, newParent); // cases when whole file is parsed but no termination is there and stream position is not getting updated as well
        // it falls into infinite recursion, null check to avoid the same

        if (stream.pos === lastStreamPos) {
          break;
        }

        lastStreamPos = stream.pos;
        arr.push(newParent);
      }

      return arr;
    };
  };

  lib.loop = loop;

  var uint8 = {};

  Object.defineProperty(uint8, "__esModule", {
    value: true
  });
  uint8.readBits = uint8.readArray = uint8.readUnsigned = uint8.readString = uint8.peekBytes = uint8.readBytes = uint8.peekByte = uint8.readByte = uint8.buildStream = void 0;

  // Default stream and parsers for Uint8TypedArray data type
  var buildStream = function buildStream(uint8Data) {
    return {
      data: uint8Data,
      pos: 0
    };
  };

  uint8.buildStream = buildStream;

  var readByte = function readByte() {
    return function (stream) {
      return stream.data[stream.pos++];
    };
  };

  uint8.readByte = readByte;

  var peekByte = function peekByte() {
    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return function (stream) {
      return stream.data[stream.pos + offset];
    };
  };

  uint8.peekByte = peekByte;

  var readBytes = function readBytes(length) {
    return function (stream) {
      return stream.data.subarray(stream.pos, stream.pos += length);
    };
  };

  uint8.readBytes = readBytes;

  var peekBytes = function peekBytes(length) {
    return function (stream) {
      return stream.data.subarray(stream.pos, stream.pos + length);
    };
  };

  uint8.peekBytes = peekBytes;

  var readString = function readString(length) {
    return function (stream) {
      return Array.from(readBytes(length)(stream)).map(function (value) {
        return String.fromCharCode(value);
      }).join('');
    };
  };

  uint8.readString = readString;

  var readUnsigned = function readUnsigned(littleEndian) {
    return function (stream) {
      var bytes = readBytes(2)(stream);
      return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];
    };
  };

  uint8.readUnsigned = readUnsigned;

  var readArray = function readArray(byteSize, totalOrFunc) {
    return function (stream, result, parent) {
      var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;
      var parser = readBytes(byteSize);
      var arr = new Array(total);

      for (var i = 0; i < total; i++) {
        arr[i] = parser(stream);
      }

      return arr;
    };
  };

  uint8.readArray = readArray;

  var subBitsTotal = function subBitsTotal(bits, startIndex, length) {
    var result = 0;

    for (var i = 0; i < length; i++) {
      result += bits[startIndex + i] && Math.pow(2, length - i - 1);
    }

    return result;
  };

  var readBits = function readBits(schema) {
    return function (stream) {
      var _byte = readByte()(stream); // convert the byte to bit array


      var bits = new Array(8);

      for (var i = 0; i < 8; i++) {
        bits[7 - i] = !!(_byte & 1 << i);
      } // convert the bit array to values based on the schema


      return Object.keys(schema).reduce(function (res, key) {
        var def = schema[key];

        if (def.length) {
          res[key] = subBitsTotal(bits, def.index, def.length);
        } else {
          res[key] = bits[def.index];
        }

        return res;
      }, {});
    };
  };

  uint8.readBits = readBits;

  (function (exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports["default"] = void 0;

  	var _ = lib;

  	var _uint = uint8;

  	// a set of 0x00 terminated subblocks
  	var subBlocksSchema = {
  	  blocks: function blocks(stream) {
  	    var terminator = 0x00;
  	    var chunks = [];
  	    var streamSize = stream.data.length;
  	    var total = 0;

  	    for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {
  	      // size becomes undefined for some case when file is corrupted and  terminator is not proper 
  	      // null check to avoid recursion
  	      if (!size) break; // catch corrupted files with no terminator

  	      if (stream.pos + size >= streamSize) {
  	        var availableSize = streamSize - stream.pos;
  	        chunks.push((0, _uint.readBytes)(availableSize)(stream));
  	        total += availableSize;
  	        break;
  	      }

  	      chunks.push((0, _uint.readBytes)(size)(stream));
  	      total += size;
  	    }

  	    var result = new Uint8Array(total);
  	    var offset = 0;

  	    for (var i = 0; i < chunks.length; i++) {
  	      result.set(chunks[i], offset);
  	      offset += chunks[i].length;
  	    }

  	    return result;
  	  }
  	}; // global control extension

  	var gceSchema = (0, _.conditional)({
  	  gce: [{
  	    codes: (0, _uint.readBytes)(2)
  	  }, {
  	    byteSize: (0, _uint.readByte)()
  	  }, {
  	    extras: (0, _uint.readBits)({
  	      future: {
  	        index: 0,
  	        length: 3
  	      },
  	      disposal: {
  	        index: 3,
  	        length: 3
  	      },
  	      userInput: {
  	        index: 6
  	      },
  	      transparentColorGiven: {
  	        index: 7
  	      }
  	    })
  	  }, {
  	    delay: (0, _uint.readUnsigned)(true)
  	  }, {
  	    transparentColorIndex: (0, _uint.readByte)()
  	  }, {
  	    terminator: (0, _uint.readByte)()
  	  }]
  	}, function (stream) {
  	  var codes = (0, _uint.peekBytes)(2)(stream);
  	  return codes[0] === 0x21 && codes[1] === 0xf9;
  	}); // image pipeline block

  	var imageSchema = (0, _.conditional)({
  	  image: [{
  	    code: (0, _uint.readByte)()
  	  }, {
  	    descriptor: [{
  	      left: (0, _uint.readUnsigned)(true)
  	    }, {
  	      top: (0, _uint.readUnsigned)(true)
  	    }, {
  	      width: (0, _uint.readUnsigned)(true)
  	    }, {
  	      height: (0, _uint.readUnsigned)(true)
  	    }, {
  	      lct: (0, _uint.readBits)({
  	        exists: {
  	          index: 0
  	        },
  	        interlaced: {
  	          index: 1
  	        },
  	        sort: {
  	          index: 2
  	        },
  	        future: {
  	          index: 3,
  	          length: 2
  	        },
  	        size: {
  	          index: 5,
  	          length: 3
  	        }
  	      })
  	    }]
  	  }, (0, _.conditional)({
  	    lct: (0, _uint.readArray)(3, function (stream, result, parent) {
  	      return Math.pow(2, parent.descriptor.lct.size + 1);
  	    })
  	  }, function (stream, result, parent) {
  	    return parent.descriptor.lct.exists;
  	  }), {
  	    data: [{
  	      minCodeSize: (0, _uint.readByte)()
  	    }, subBlocksSchema]
  	  }]
  	}, function (stream) {
  	  return (0, _uint.peekByte)()(stream) === 0x2c;
  	}); // plain text block

  	var textSchema = (0, _.conditional)({
  	  text: [{
  	    codes: (0, _uint.readBytes)(2)
  	  }, {
  	    blockSize: (0, _uint.readByte)()
  	  }, {
  	    preData: function preData(stream, result, parent) {
  	      return (0, _uint.readBytes)(parent.text.blockSize)(stream);
  	    }
  	  }, subBlocksSchema]
  	}, function (stream) {
  	  var codes = (0, _uint.peekBytes)(2)(stream);
  	  return codes[0] === 0x21 && codes[1] === 0x01;
  	}); // application block

  	var applicationSchema = (0, _.conditional)({
  	  application: [{
  	    codes: (0, _uint.readBytes)(2)
  	  }, {
  	    blockSize: (0, _uint.readByte)()
  	  }, {
  	    id: function id(stream, result, parent) {
  	      return (0, _uint.readString)(parent.blockSize)(stream);
  	    }
  	  }, subBlocksSchema]
  	}, function (stream) {
  	  var codes = (0, _uint.peekBytes)(2)(stream);
  	  return codes[0] === 0x21 && codes[1] === 0xff;
  	}); // comment block

  	var commentSchema = (0, _.conditional)({
  	  comment: [{
  	    codes: (0, _uint.readBytes)(2)
  	  }, subBlocksSchema]
  	}, function (stream) {
  	  var codes = (0, _uint.peekBytes)(2)(stream);
  	  return codes[0] === 0x21 && codes[1] === 0xfe;
  	});
  	var schema = [{
  	  header: [{
  	    signature: (0, _uint.readString)(3)
  	  }, {
  	    version: (0, _uint.readString)(3)
  	  }]
  	}, {
  	  lsd: [{
  	    width: (0, _uint.readUnsigned)(true)
  	  }, {
  	    height: (0, _uint.readUnsigned)(true)
  	  }, {
  	    gct: (0, _uint.readBits)({
  	      exists: {
  	        index: 0
  	      },
  	      resolution: {
  	        index: 1,
  	        length: 3
  	      },
  	      sort: {
  	        index: 4
  	      },
  	      size: {
  	        index: 5,
  	        length: 3
  	      }
  	    })
  	  }, {
  	    backgroundColorIndex: (0, _uint.readByte)()
  	  }, {
  	    pixelAspectRatio: (0, _uint.readByte)()
  	  }]
  	}, (0, _.conditional)({
  	  gct: (0, _uint.readArray)(3, function (stream, result) {
  	    return Math.pow(2, result.lsd.gct.size + 1);
  	  })
  	}, function (stream, result) {
  	  return result.lsd.gct.exists;
  	}), // content frames
  	{
  	  frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {
  	    var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence
  	    // of an ext or image block to avoid infinite loops
  	    //var terminator = 0x3B;
  	    //return nextCode !== terminator;

  	    return nextCode === 0x21 || nextCode === 0x2c;
  	  })
  	}];
  	var _default = schema;
  	exports["default"] = _default;
  } (gif));

  var deinterlace = {};

  /**
   * Deinterlace function from https://github.com/shachaf/jsgif
   */
  Object.defineProperty(deinterlace, "__esModule", { value: true });
  deinterlace.deinterlace = void 0;
  deinterlace.deinterlace = function (pixels, width) {
      var newPixels = new Array(pixels.length);
      var rows = pixels.length / width;
      var cpRow = function (toRow, fromRow) {
          var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
          newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
      };
      // See appendix E.
      var offsets = [0, 4, 2, 1];
      var steps = [8, 8, 4, 2];
      var fromRow = 0;
      for (var pass = 0; pass < 4; pass++) {
          for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
              cpRow(toRow, fromRow);
              fromRow++;
          }
      }
      return newPixels;
  };

  var lzw = {};

  /**
   * javascript port of java LZW decompression
   * Original java author url: https://gist.github.com/devunwired/4479231
   */
  Object.defineProperty(lzw, "__esModule", { value: true });
  lzw.lzw = void 0;
  lzw.lzw = function (minCodeSize, data, pixelCount) {
      var MAX_STACK_SIZE = 4096;
      var nullCode = -1;
      var npix = pixelCount;
      var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
      var dstPixels = new Array(pixelCount);
      var prefix = new Array(MAX_STACK_SIZE);
      var suffix = new Array(MAX_STACK_SIZE);
      var pixelStack = new Array(MAX_STACK_SIZE + 1);
      // Initialize GIF data stream decoder.
      data_size = minCodeSize;
      clear = 1 << data_size;
      end_of_information = clear + 1;
      available = clear + 2;
      old_code = nullCode;
      code_size = data_size + 1;
      code_mask = (1 << code_size) - 1;
      for (code = 0; code < clear; code++) {
          prefix[code] = 0;
          suffix[code] = code;
      }
      // Decode GIF pixel stream.
      var datum, bits, first, top, pi, bi;
      datum = bits = first = top = pi = bi = 0;
      for (i = 0; i < npix;) {
          if (top === 0) {
              if (bits < code_size) {
                  // get the next byte
                  datum += data[bi] << bits;
                  bits += 8;
                  bi++;
                  continue;
              }
              // Get the next code.
              code = datum & code_mask;
              datum >>= code_size;
              bits -= code_size;
              // Interpret the code
              if (code > available || code == end_of_information) {
                  break;
              }
              if (code == clear) {
                  // Reset decoder.
                  code_size = data_size + 1;
                  code_mask = (1 << code_size) - 1;
                  available = clear + 2;
                  old_code = nullCode;
                  continue;
              }
              if (old_code == nullCode) {
                  pixelStack[top++] = suffix[code];
                  old_code = code;
                  first = code;
                  continue;
              }
              in_code = code;
              if (code == available) {
                  pixelStack[top++] = first;
                  code = old_code;
              }
              while (code > clear) {
                  pixelStack[top++] = suffix[code];
                  code = prefix[code];
              }
              first = suffix[code] & 0xff;
              pixelStack[top++] = first;
              // add a new string to the table, but only if space is available
              // if not, just continue with current table until a clear code is found
              // (deferred clear code implementation as per GIF spec)
              if (available < MAX_STACK_SIZE) {
                  prefix[available] = old_code;
                  suffix[available] = first;
                  available++;
                  if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
                      code_size++;
                      code_mask += available;
                  }
              }
              old_code = in_code;
          }
          // Pop a pixel off the pixel stack.
          top--;
          dstPixels[pi++] = pixelStack[top];
          i++;
      }
      for (i = pi; i < npix; i++) {
          dstPixels[i] = 0; // clear missing pixels
      }
      return dstPixels;
  };

  (function (exports) {
  	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
  	    return (mod && mod.__esModule) ? mod : { "default": mod };
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	exports.decompressFrames = exports.decompressFrame = exports.parseGIF = void 0;
  	var gif_1 = __importDefault(gif);
  	var js_binary_schema_parser_1 = lib;
  	var uint8_1 = uint8;
  	var deinterlace_1 = deinterlace;
  	var lzw_1 = lzw;
  	exports.parseGIF = function (arrayBuffer) {
  	    var byteData = new Uint8Array(arrayBuffer);
  	    return js_binary_schema_parser_1.parse(uint8_1.buildStream(byteData), gif_1.default);
  	};
  	var generatePatch = function (image) {
  	    var totalPixels = image.pixels.length;
  	    var patchData = new Uint8ClampedArray(totalPixels * 4);
  	    for (var i = 0; i < totalPixels; i++) {
  	        var pos = i * 4;
  	        var colorIndex = image.pixels[i];
  	        var color = image.colorTable[colorIndex];
  	        patchData[pos] = color[0];
  	        patchData[pos + 1] = color[1];
  	        patchData[pos + 2] = color[2];
  	        patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
  	    }
  	    return patchData;
  	};
  	exports.decompressFrame = function (frame, gct, buildImagePatch) {
  	    if (!frame.image) {
  	        console.warn('gif frame does not have associated image.');
  	        return;
  	    }
  	    var image = frame.image;
  	    // get the number of pixels
  	    var totalPixels = image.descriptor.width * image.descriptor.height;
  	    // do lzw decompression
  	    var pixels = lzw_1.lzw(image.data.minCodeSize, image.data.blocks, totalPixels);
  	    // deal with interlacing if necessary
  	    if (image.descriptor.lct.interlaced) {
  	        pixels = deinterlace_1.deinterlace(pixels, image.descriptor.width);
  	    }
  	    var resultImage = {
  	        pixels: pixels,
  	        dims: {
  	            top: frame.image.descriptor.top,
  	            left: frame.image.descriptor.left,
  	            width: frame.image.descriptor.width,
  	            height: frame.image.descriptor.height
  	        }
  	    };
  	    // color table
  	    if (image.descriptor.lct && image.descriptor.lct.exists) {
  	        resultImage.colorTable = image.lct;
  	    }
  	    else {
  	        resultImage.colorTable = gct;
  	    }
  	    // add per frame relevant gce information
  	    if (frame.gce) {
  	        resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms
  	        resultImage.disposalType = frame.gce.extras.disposal;
  	        // transparency
  	        if (frame.gce.extras.transparentColorGiven) {
  	            resultImage.transparentIndex = frame.gce.transparentColorIndex;
  	        }
  	    }
  	    // create canvas usable imagedata if desired
  	    if (buildImagePatch) {
  	        resultImage.patch = generatePatch(resultImage);
  	    }
  	    return resultImage;
  	};
  	exports.decompressFrames = function (parsedGif, buildImagePatches) {
  	    return parsedGif.frames
  	        .filter(function (f) { return f.image; })
  	        .map(function (f) { return exports.decompressFrame(f, parsedGif.gct, buildImagePatches); });
  	};
  } (gifuctJs));

  /* NeuQuant Neural-Net Quantization Algorithm
   * ------------------------------------------
   *
   * Copyright (c) 1994 Anthony Dekker
   *
   * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.
   * See "Kohonen neural networks for optimal colour quantization"
   * in "Network: Computation in Neural Systems" Vol. 5 (1994) pp 351-367.
   * for a discussion of the algorithm.
   * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML
   *
   * Any party obtaining a copy of these files from the author, directly or
   * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
   * world-wide, paid up, royalty-free, nonexclusive right and license to deal
   * in this software and documentation files (the "Software"), including without
   * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons who receive
   * copies from any such party to do so, with the only requirement being
   * that this copyright notice remain intact.
   *
   * (JavaScript port 2012 by Johan Nordberg)
   */
  var ncycles = 100; // number of learning cycles
  var netsize = 256; // number of colors used
  var maxnetpos = netsize - 1;
  // defs for freq and bias
  var netbiasshift = 4; // bias for colour values
  var intbiasshift = 16; // bias for fractions
  var intbias = (1 << intbiasshift);
  var gammashift = 10;
  var betashift = 10;
  var beta = (intbias >> betashift); /* beta = 1/1024 */
  var betagamma = (intbias << (gammashift - betashift));
  // defs for decreasing radius factor
  var initrad = (netsize >> 3); // for 256 cols, radius starts
  var radiusbiasshift = 6; // at 32.0 biased by 6 bits
  var radiusbias = (1 << radiusbiasshift);
  var initradius = (initrad * radiusbias); //and decreases by a
  var radiusdec = 30; // factor of 1/30 each cycle
  // defs for decreasing alpha factor
  var alphabiasshift = 10; // alpha starts at 1.0
  var initalpha = (1 << alphabiasshift);
  /* radbias and alpharadbias used for radpower calculation */
  var radbiasshift = 8;
  var radbias = (1 << radbiasshift);
  var alpharadbshift = (alphabiasshift + radbiasshift);
  var alpharadbias = (1 << alpharadbshift);
  // four primes near 500 - assume no image has a length so large that it is
  // divisible by all four primes
  var prime1 = 499;
  var prime2 = 491;
  var prime3 = 487;
  var prime4 = 503;
  var minpicturebytes = (3 * prime4);
  /*
    Constructor: NeuQuant

    Arguments:

    pixels - array of pixels in RGB format
    samplefac - sampling factor 1 to 30 where lower is better quality

    >
    > pixels = [r, g, b, r, g, b, r, g, b, ..]
    >
  */
  function NeuQuant$1(pixels, samplefac) {
      var network; // int[netsize][4]
      var netindex; // for network lookup - really 256
      // bias and freq arrays for learning
      var bias;
      var freq;
      var radpower;
      /*
        Private Method: init
    
        sets up arrays
      */
      function init() {
          network = [];
          netindex = new Int32Array(256);
          bias = new Int32Array(netsize);
          freq = new Int32Array(netsize);
          radpower = new Int32Array(netsize >> 3);
          var i, v;
          for (i = 0; i < netsize; i++) {
              v = (i << (netbiasshift + 8)) / netsize;
              network[i] = new Float64Array([v, v, v, 0]);
              //network[i] = [v, v, v, 0]
              freq[i] = intbias / netsize;
              bias[i] = 0;
          }
      }
      /*
        Private Method: unbiasnet
    
        unbiases network to give byte values 0..255 and record position i to prepare for sort
      */
      function unbiasnet() {
          for (var i = 0; i < netsize; i++) {
              network[i][0] >>= netbiasshift;
              network[i][1] >>= netbiasshift;
              network[i][2] >>= netbiasshift;
              network[i][3] = i; // record color number
          }
      }
      /*
        Private Method: altersingle
    
        moves neuron *i* towards biased (b,g,r) by factor *alpha*
      */
      function altersingle(alpha, i, b, g, r) {
          network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
          network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
          network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
      }
      /*
        Private Method: alterneigh
    
        moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
      */
      function alterneigh(radius, i, b, g, r) {
          var lo = Math.abs(i - radius);
          var hi = Math.min(i + radius, netsize);
          var j = i + 1;
          var k = i - 1;
          var m = 1;
          var p, a;
          while ((j < hi) || (k > lo)) {
              a = radpower[m++];
              if (j < hi) {
                  p = network[j++];
                  p[0] -= (a * (p[0] - b)) / alpharadbias;
                  p[1] -= (a * (p[1] - g)) / alpharadbias;
                  p[2] -= (a * (p[2] - r)) / alpharadbias;
              }
              if (k > lo) {
                  p = network[k--];
                  p[0] -= (a * (p[0] - b)) / alpharadbias;
                  p[1] -= (a * (p[1] - g)) / alpharadbias;
                  p[2] -= (a * (p[2] - r)) / alpharadbias;
              }
          }
      }
      /*
        Private Method: contest
    
        searches for biased BGR values
      */
      function contest(b, g, r) {
          /*
            finds closest neuron (min dist) and updates freq
            finds best neuron (min dist-bias) and returns position
            for frequently chosen neurons, freq[i] is high and bias[i] is negative
            bias[i] = gamma * ((1 / netsize) - freq[i])
          */
          var bestd = ~(1 << 31);
          var bestbiasd = bestd;
          var bestpos = -1;
          var bestbiaspos = bestpos;
          var i, n, dist, biasdist, betafreq;
          for (i = 0; i < netsize; i++) {
              n = network[i];
              dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
              if (dist < bestd) {
                  bestd = dist;
                  bestpos = i;
              }
              biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));
              if (biasdist < bestbiasd) {
                  bestbiasd = biasdist;
                  bestbiaspos = i;
              }
              betafreq = (freq[i] >> betashift);
              freq[i] -= betafreq;
              bias[i] += (betafreq << gammashift);
          }
          freq[bestpos] += beta;
          bias[bestpos] -= betagamma;
          return bestbiaspos;
      }
      /*
        Private Method: inxbuild
    
        sorts network and builds netindex[0..255]
      */
      function inxbuild() {
          var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
          for (i = 0; i < netsize; i++) {
              p = network[i];
              smallpos = i;
              smallval = p[1]; // index on g
              // find smallest in i..netsize-1
              for (j = i + 1; j < netsize; j++) {
                  q = network[j];
                  if (q[1] < smallval) { // index on g
                      smallpos = j;
                      smallval = q[1]; // index on g
                  }
              }
              q = network[smallpos];
              // swap p (i) and q (smallpos) entries
              if (i != smallpos) {
                  j = q[0];
                  q[0] = p[0];
                  p[0] = j;
                  j = q[1];
                  q[1] = p[1];
                  p[1] = j;
                  j = q[2];
                  q[2] = p[2];
                  p[2] = j;
                  j = q[3];
                  q[3] = p[3];
                  p[3] = j;
              }
              // smallval entry is now in position i
              if (smallval != previouscol) {
                  netindex[previouscol] = (startpos + i) >> 1;
                  for (j = previouscol + 1; j < smallval; j++)
                      netindex[j] = i;
                  previouscol = smallval;
                  startpos = i;
              }
          }
          netindex[previouscol] = (startpos + maxnetpos) >> 1;
          for (j = previouscol + 1; j < 256; j++)
              netindex[j] = maxnetpos; // really 256
      }
      /*
        Private Method: inxsearch
    
        searches for BGR values 0..255 and returns a color index
      */
      function inxsearch(b, g, r) {
          var a, p, dist;
          var bestd = 1000; // biggest possible dist is 256*3
          var best = -1;
          var i = netindex[g]; // index on g
          var j = i - 1; // start at netindex[g] and work outwards
          while ((i < netsize) || (j >= 0)) {
              if (i < netsize) {
                  p = network[i];
                  dist = p[1] - g; // inx key
                  if (dist >= bestd)
                      i = netsize; // stop iter
                  else {
                      i++;
                      if (dist < 0)
                          dist = -dist;
                      a = p[0] - b;
                      if (a < 0)
                          a = -a;
                      dist += a;
                      if (dist < bestd) {
                          a = p[2] - r;
                          if (a < 0)
                              a = -a;
                          dist += a;
                          if (dist < bestd) {
                              bestd = dist;
                              best = p[3];
                          }
                      }
                  }
              }
              if (j >= 0) {
                  p = network[j];
                  dist = g - p[1]; // inx key - reverse dif
                  if (dist >= bestd)
                      j = -1; // stop iter
                  else {
                      j--;
                      if (dist < 0)
                          dist = -dist;
                      a = p[0] - b;
                      if (a < 0)
                          a = -a;
                      dist += a;
                      if (dist < bestd) {
                          a = p[2] - r;
                          if (a < 0)
                              a = -a;
                          dist += a;
                          if (dist < bestd) {
                              bestd = dist;
                              best = p[3];
                          }
                      }
                  }
              }
          }
          return best;
      }
      /*
        Private Method: learn
    
        "Main Learning Loop"
      */
      function learn() {
          var i;
          var lengthcount = pixels.length;
          var alphadec = 30 + ((samplefac - 1) / 3);
          var samplepixels = lengthcount / (3 * samplefac);
          var delta = ~~(samplepixels / ncycles);
          var alpha = initalpha;
          var radius = initradius;
          var rad = radius >> radiusbiasshift;
          if (rad <= 1)
              rad = 0;
          for (i = 0; i < rad; i++)
              radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));
          var step;
          if (lengthcount < minpicturebytes) {
              samplefac = 1;
              step = 3;
          }
          else if ((lengthcount % prime1) !== 0) {
              step = 3 * prime1;
          }
          else if ((lengthcount % prime2) !== 0) {
              step = 3 * prime2;
          }
          else if ((lengthcount % prime3) !== 0) {
              step = 3 * prime3;
          }
          else {
              step = 3 * prime4;
          }
          var b, g, r, j;
          var pix = 0; // current pixel
          i = 0;
          while (i < samplepixels) {
              b = (pixels[pix] & 0xff) << netbiasshift;
              g = (pixels[pix + 1] & 0xff) << netbiasshift;
              r = (pixels[pix + 2] & 0xff) << netbiasshift;
              j = contest(b, g, r);
              altersingle(alpha, j, b, g, r);
              if (rad !== 0)
                  alterneigh(rad, j, b, g, r); // alter neighbours
              pix += step;
              if (pix >= lengthcount)
                  pix -= lengthcount;
              i++;
              if (delta === 0)
                  delta = 1;
              if (i % delta === 0) {
                  alpha -= alpha / alphadec;
                  radius -= radius / radiusdec;
                  rad = radius >> radiusbiasshift;
                  if (rad <= 1)
                      rad = 0;
                  for (j = 0; j < rad; j++)
                      radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));
              }
          }
      }
      /*
        Method: buildColormap
    
        1. initializes network
        2. trains it
        3. removes misconceptions
        4. builds colorindex
      */
      function buildColormap() {
          init();
          learn();
          unbiasnet();
          inxbuild();
      }
      this.buildColormap = buildColormap;
      /*
        Method: getColormap
    
        builds colormap from the index
    
        returns array in the format:
    
        >
        > [r, g, b, r, g, b, r, g, b, ..]
        >
      */
      function getColormap() {
          var map = [];
          var index = [];
          for (var i = 0; i < netsize; i++)
              index[network[i][3]] = i;
          var k = 0;
          for (var l = 0; l < netsize; l++) {
              var j = index[l];
              map[k++] = (network[j][0]);
              map[k++] = (network[j][1]);
              map[k++] = (network[j][2]);
          }
          return map;
      }
      this.getColormap = getColormap;
      /*
        Method: lookupRGB
    
        looks for the closest *r*, *g*, *b* color in the map and
        returns its index
      */
      this.lookupRGB = inxsearch;
  }
  var TypedNeuQuant = NeuQuant$1;

  /*
    LZWEncoder.js

    Authors
    Kevin Weiner (original Java version - kweiner@fmsware.com)
    Thibault Imbert (AS3 version - bytearray.org)
    Johan Nordberg (JS version - code@johan-nordberg.com)

    Acknowledgements
    GIFCOMPR.C - GIF Image compression routines
    Lempel-Ziv compression based on 'compress'. GIF modifications by
    David Rowley (mgardi@watdcsu.waterloo.edu)
    GIF Image compression - modified 'compress'
    Based on: compress.c - File compression ala IEEE Computer, June 1984.
    By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)
    Jim McKie (decvax!mcvax!jim)
    Steve Davies (decvax!vax135!petsd!peora!srd)
    Ken Turkowski (decvax!decwrl!turtlevax!ken)
    James A. Woods (decvax!ihnp4!ames!jaw)
    Joe Orost (decvax!vax135!petsd!joe)
  */
  var EOF = -1;
  var BITS = 12;
  var HSIZE = 5003; // 80% occupancy
  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,
      0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,
      0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];
  function LZWEncoder$1(width, height, pixels, colorDepth) {
      var initCodeSize = Math.max(2, colorDepth);
      var accum = new Uint8Array(256);
      var htab = new Int32Array(HSIZE);
      var codetab = new Int32Array(HSIZE);
      var cur_accum, cur_bits = 0;
      var a_count;
      var free_ent = 0; // first unused entry
      var maxcode;
      // block compression parameters -- after all codes are used up,
      // and compression rate changes, start over.
      var clear_flg = false;
      // Algorithm: use open addressing double hashing (no chaining) on the
      // prefix code / next character combination. We do a variant of Knuth's
      // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
      // secondary probe. Here, the modular division first probe is gives way
      // to a faster exclusive-or manipulation. Also do block compression with
      // an adaptive reset, whereby the code table is cleared when the compression
      // ratio decreases, but after the table fills. The variable-length output
      // codes are re-sized at this point, and a special CLEAR code is generated
      // for the decompressor. Late addition: construct the table according to
      // file size for noticeable speed improvement on small files. Please direct
      // questions about this implementation to ames!jaw.
      var g_init_bits, ClearCode, EOFCode;
      var remaining, curPixel, n_bits;
      // Add a character to the end of the current packet, and if it is 254
      // characters, flush the packet to disk.
      function char_out(c, outs) {
          accum[a_count++] = c;
          if (a_count >= 254)
              flush_char(outs);
      }
      // Clear out the hash table
      // table clear for block compress
      function cl_block(outs) {
          cl_hash(HSIZE);
          free_ent = ClearCode + 2;
          clear_flg = true;
          output(ClearCode, outs);
      }
      // Reset code table
      function cl_hash(hsize) {
          for (var i = 0; i < hsize; ++i)
              htab[i] = -1;
      }
      function compress(init_bits, outs) {
          var fcode, c, i, ent, disp, hsize_reg, hshift;
          // Set up the globals: g_init_bits - initial number of bits
          g_init_bits = init_bits;
          // Set up the necessary values
          clear_flg = false;
          n_bits = g_init_bits;
          maxcode = MAXCODE(n_bits);
          ClearCode = 1 << (init_bits - 1);
          EOFCode = ClearCode + 1;
          free_ent = ClearCode + 2;
          a_count = 0; // clear packet
          ent = nextPixel();
          hshift = 0;
          for (fcode = HSIZE; fcode < 65536; fcode *= 2)
              ++hshift;
          hshift = 8 - hshift; // set hash code range bound
          hsize_reg = HSIZE;
          cl_hash(hsize_reg); // clear hash table
          output(ClearCode, outs);
          outer_loop: while ((c = nextPixel()) != EOF) {
              fcode = (c << BITS) + ent;
              i = (c << hshift) ^ ent; // xor hashing
              if (htab[i] === fcode) {
                  ent = codetab[i];
                  continue;
              }
              else if (htab[i] >= 0) { // non-empty slot
                  disp = hsize_reg - i; // secondary hash (after G. Knott)
                  if (i === 0)
                      disp = 1;
                  do {
                      if ((i -= disp) < 0)
                          i += hsize_reg;
                      if (htab[i] === fcode) {
                          ent = codetab[i];
                          continue outer_loop;
                      }
                  } while (htab[i] >= 0);
              }
              output(ent, outs);
              ent = c;
              if (free_ent < 1 << BITS) {
                  codetab[i] = free_ent++; // code -> hashtable
                  htab[i] = fcode;
              }
              else {
                  cl_block(outs);
              }
          }
          // Put out the final code.
          output(ent, outs);
          output(EOFCode, outs);
      }
      function encode(outs) {
          outs.writeByte(initCodeSize); // write "initial code size" byte
          remaining = width * height; // reset navigation variables
          curPixel = 0;
          compress(initCodeSize + 1, outs); // compress and write the pixel data
          outs.writeByte(0); // write block terminator
      }
      // Flush the packet to disk, and reset the accumulator
      function flush_char(outs) {
          if (a_count > 0) {
              outs.writeByte(a_count);
              outs.writeBytes(accum, 0, a_count);
              a_count = 0;
          }
      }
      function MAXCODE(n_bits) {
          return (1 << n_bits) - 1;
      }
      // Return the next pixel from the image
      function nextPixel() {
          if (remaining === 0)
              return EOF;
          --remaining;
          var pix = pixels[curPixel++];
          return pix & 0xff;
      }
      function output(code, outs) {
          cur_accum &= masks[cur_bits];
          if (cur_bits > 0)
              cur_accum |= (code << cur_bits);
          else
              cur_accum = code;
          cur_bits += n_bits;
          while (cur_bits >= 8) {
              char_out((cur_accum & 0xff), outs);
              cur_accum >>= 8;
              cur_bits -= 8;
          }
          // If the next entry is going to be too big for the code size,
          // then increase it, if possible.
          if (free_ent > maxcode || clear_flg) {
              if (clear_flg) {
                  maxcode = MAXCODE(n_bits = g_init_bits);
                  clear_flg = false;
              }
              else {
                  ++n_bits;
                  if (n_bits == BITS)
                      maxcode = 1 << BITS;
                  else
                      maxcode = MAXCODE(n_bits);
              }
          }
          if (code == EOFCode) {
              // At EOF, write the rest of the buffer.
              while (cur_bits > 0) {
                  char_out((cur_accum & 0xff), outs);
                  cur_accum >>= 8;
                  cur_bits -= 8;
              }
              flush_char(outs);
          }
      }
      this.encode = encode;
  }
  var LZWEncoder_1 = LZWEncoder$1;

  /*
    GIFEncoder.js

    Authors
    Kevin Weiner (original Java version - kweiner@fmsware.com)
    Thibault Imbert (AS3 version - bytearray.org)
    Johan Nordberg (JS version - code@johan-nordberg.com)
    Makito (Optimized for AwesomeQR - sumimakito@hotmail,com)
  */
  var NeuQuant = TypedNeuQuant;
  var LZWEncoder = LZWEncoder_1;
  function ByteArray() {
      this.page = -1;
      this.pages = [];
      this.newPage();
  }
  ByteArray.pageSize = 4096;
  ByteArray.charMap = {};
  for (var i = 0; i < 256; i++)
      ByteArray.charMap[i] = String.fromCharCode(i);
  ByteArray.prototype.newPage = function () {
      this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);
      this.cursor = 0;
  };
  ByteArray.prototype.getData = function () {
      var rv = "";
      for (var p = 0; p < this.pages.length; p++) {
          for (var i = 0; i < ByteArray.pageSize; i++) {
              rv += ByteArray.charMap[this.pages[p][i]];
          }
      }
      return rv;
  };
  ByteArray.prototype.toFlattenUint8Array = function () {
      var chunks = [];
      for (var p = 0; p < this.pages.length; p++) {
          if (p === this.pages.length - 1) {
              var chunk = Uint8Array.from(this.pages[p].slice(0, this.cursor));
              chunks.push(chunk);
          }
          else {
              chunks.push(this.pages[p]);
          }
      }
      var flatten = new Uint8Array(chunks.reduce(function (acc, chunk) { return acc + chunk.length; }, 0));
      chunks.reduce(function (lastLength, chunk) {
          flatten.set(chunk, lastLength);
          return lastLength + chunk.length;
      }, 0);
      return flatten;
  };
  ByteArray.prototype.writeByte = function (val) {
      if (this.cursor >= ByteArray.pageSize)
          this.newPage();
      this.pages[this.page][this.cursor++] = val;
  };
  ByteArray.prototype.writeUTFBytes = function (string) {
      for (var l = string.length, i = 0; i < l; i++)
          this.writeByte(string.charCodeAt(i));
  };
  ByteArray.prototype.writeBytes = function (array, offset, length) {
      for (var l = length || array.length, i = offset || 0; i < l; i++)
          this.writeByte(array[i]);
  };
  function GIFEncoder(width, height) {
      // image size
      this.width = ~~width;
      this.height = ~~height;
      // transparent color if given
      this.transparent = null;
      // transparent index in color table
      this.transIndex = 0;
      // -1 = no repeat, 0 = forever. anything else is repeat count
      this.repeat = -1;
      // frame delay (hundredths)
      this.delay = 0;
      this.image = null; // current frame
      this.pixels = null; // BGR byte array from frame
      this.indexedPixels = null; // converted frame indexed to palette
      this.colorDepth = null; // number of bit planes
      this.colorTab = null; // RGB palette
      this.neuQuant = null; // NeuQuant instance that was used to generate this.colorTab.
      this.usedEntry = new Array(); // active palette entries
      this.palSize = 7; // color table size (bits-1)
      this.dispose = -1; // disposal code (-1 = use default)
      this.firstFrame = true;
      this.sample = 10; // default sample interval for quantizer
      this.dither = false; // default dithering
      this.globalPalette = false;
      this.out = new ByteArray();
  }
  /*
    Sets the delay time between each frame, or changes it for subsequent frames
    (applies to last frame added)
  */
  GIFEncoder.prototype.setDelay = function (milliseconds) {
      this.delay = Math.round(milliseconds / 10);
  };
  /*
    Sets frame rate in frames per second.
  */
  GIFEncoder.prototype.setFrameRate = function (fps) {
      this.delay = Math.round(100 / fps);
  };
  /*
    Sets the GIF frame disposal code for the last added frame and any
    subsequent frames.

    Default is 0 if no transparent color has been set, otherwise 2.
  */
  GIFEncoder.prototype.setDispose = function (disposalCode) {
      if (disposalCode >= 0)
          this.dispose = disposalCode;
  };
  /*
    Sets the number of times the set of GIF frames should be played.

    -1 = play once
    0 = repeat indefinitely

    Default is -1

    Must be invoked before the first image is added
  */
  GIFEncoder.prototype.setRepeat = function (repeat) {
      this.repeat = repeat;
  };
  /*
    Sets the transparent color for the last added frame and any subsequent
    frames. Since all colors are subject to modification in the quantization
    process, the color in the final palette for each frame closest to the given
    color becomes the transparent color for that frame. May be set to null to
    indicate no transparent color.
  */
  GIFEncoder.prototype.setTransparent = function (color) {
      this.transparent = color;
  };
  /*
    Adds next GIF frame. The frame is not written immediately, but is
    actually deferred until the next frame is received so that timing
    data can be inserted.  Invoking finish() flushes all frames.
  */
  GIFEncoder.prototype.addFrame = function (imageData) {
      this.image = imageData;
      this.colorTab = this.globalPalette && this.globalPalette.slice ? this.globalPalette : null;
      this.getImagePixels(); // convert to correct format if necessary
      this.analyzePixels(); // build color table & map pixels
      if (this.globalPalette === true)
          this.globalPalette = this.colorTab;
      if (this.firstFrame) {
          this.writeHeader();
          this.writeLSD(); // logical screen descriptior
          this.writePalette(); // global color table
          if (this.repeat >= 0) {
              // use NS app extension to indicate reps
              this.writeNetscapeExt();
          }
      }
      this.writeGraphicCtrlExt(); // write graphic control extension
      this.writeImageDesc(); // image descriptor
      if (!this.firstFrame && !this.globalPalette)
          this.writePalette(); // local color table
      this.writePixels(); // encode and write pixel data
      this.firstFrame = false;
  };
  /*
    Adds final trailer to the GIF stream, if you don't call the finish method
    the GIF stream will not be valid.
  */
  GIFEncoder.prototype.finish = function () {
      this.out.writeByte(0x3b); // gif trailer
  };
  /*
    Sets quality of color quantization (conversion of images to the maximum 256
    colors allowed by the GIF specification). Lower values (minimum = 1)
    produce better colors, but slow processing significantly. 10 is the
    default, and produces good color mapping at reasonable speeds. Values
    greater than 20 do not yield significant improvements in speed.
  */
  GIFEncoder.prototype.setQuality = function (quality) {
      if (quality < 1)
          quality = 1;
      this.sample = quality;
  };
  /*
    Sets dithering method. Available are:
    - FALSE no dithering
    - TRUE or FloydSteinberg
    - FalseFloydSteinberg
    - Stucki
    - Atkinson
    You can add '-serpentine' to use serpentine scanning
  */
  GIFEncoder.prototype.setDither = function (dither) {
      if (dither === true)
          dither = "FloydSteinberg";
      this.dither = dither;
  };
  /*
    Sets global palette for all frames.
    You can provide TRUE to create global palette from first picture.
    Or an array of r,g,b,r,g,b,...
  */
  GIFEncoder.prototype.setGlobalPalette = function (palette) {
      this.globalPalette = palette;
  };
  /*
    Returns global palette used for all frames.
    If setGlobalPalette(true) was used, then this function will return
    calculated palette after the first frame is added.
  */
  GIFEncoder.prototype.getGlobalPalette = function () {
      return (this.globalPalette && this.globalPalette.slice && this.globalPalette.slice(0)) || this.globalPalette;
  };
  /*
    Writes GIF file header
  */
  GIFEncoder.prototype.writeHeader = function () {
      this.out.writeUTFBytes("GIF89a");
  };
  /*
    Analyzes current frame colors and creates color map.
  */
  GIFEncoder.prototype.analyzePixels = function () {
      if (!this.colorTab) {
          this.neuQuant = new NeuQuant(this.pixels, this.sample);
          this.neuQuant.buildColormap(); // create reduced palette
          this.colorTab = this.neuQuant.getColormap();
      }
      // map image pixels to new palette
      if (this.dither) {
          this.ditherPixels(this.dither.replace("-serpentine", ""), this.dither.match(/-serpentine/) !== null);
      }
      else {
          this.indexPixels();
      }
      this.pixels = null;
      this.colorDepth = 8;
      this.palSize = 7;
      // get closest match to transparent color if specified
      if (this.transparent !== null) {
          this.transIndex = this.findClosest(this.transparent, true);
      }
  };
  /*
    Index pixels, without dithering
  */
  GIFEncoder.prototype.indexPixels = function (imgq) {
      var nPix = this.pixels.length / 3;
      this.indexedPixels = new Uint8Array(nPix);
      var k = 0;
      for (var j = 0; j < nPix; j++) {
          var index = this.findClosestRGB(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);
          this.usedEntry[index] = true;
          this.indexedPixels[j] = index;
      }
  };
  /*
    Taken from http://jsbin.com/iXofIji/2/edit by PAEz
  */
  GIFEncoder.prototype.ditherPixels = function (kernel, serpentine) {
      var kernels = {
          FalseFloydSteinberg: [
              [3 / 8, 1, 0],
              [3 / 8, 0, 1],
              [2 / 8, 1, 1],
          ],
          FloydSteinberg: [
              [7 / 16, 1, 0],
              [3 / 16, -1, 1],
              [5 / 16, 0, 1],
              [1 / 16, 1, 1],
          ],
          Stucki: [
              [8 / 42, 1, 0],
              [4 / 42, 2, 0],
              [2 / 42, -2, 1],
              [4 / 42, -1, 1],
              [8 / 42, 0, 1],
              [4 / 42, 1, 1],
              [2 / 42, 2, 1],
              [1 / 42, -2, 2],
              [2 / 42, -1, 2],
              [4 / 42, 0, 2],
              [2 / 42, 1, 2],
              [1 / 42, 2, 2],
          ],
          Atkinson: [
              [1 / 8, 1, 0],
              [1 / 8, 2, 0],
              [1 / 8, -1, 1],
              [1 / 8, 0, 1],
              [1 / 8, 1, 1],
              [1 / 8, 0, 2],
          ],
      };
      if (!kernel || !kernels[kernel]) {
          throw "Unknown dithering kernel: " + kernel;
      }
      var ds = kernels[kernel];
      var index = 0, height = this.height, width = this.width, data = this.pixels;
      var direction = serpentine ? -1 : 1;
      this.indexedPixels = new Uint8Array(this.pixels.length / 3);
      for (var y = 0; y < height; y++) {
          if (serpentine)
              direction = direction * -1;
          for (var x = direction == 1 ? 0 : width - 1, xend = direction == 1 ? width : 0; x !== xend; x += direction) {
              index = y * width + x;
              // Get original colour
              var idx = index * 3;
              var r1 = data[idx];
              var g1 = data[idx + 1];
              var b1 = data[idx + 2];
              // Get converted colour
              idx = this.findClosestRGB(r1, g1, b1);
              this.usedEntry[idx] = true;
              this.indexedPixels[index] = idx;
              idx *= 3;
              var r2 = this.colorTab[idx];
              var g2 = this.colorTab[idx + 1];
              var b2 = this.colorTab[idx + 2];
              var er = r1 - r2;
              var eg = g1 - g2;
              var eb = b1 - b2;
              for (var i = direction == 1 ? 0 : ds.length - 1, end = direction == 1 ? ds.length : 0; i !== end; i += direction) {
                  var x1 = ds[i][1]; // *direction;  //  Should this by timesd by direction?..to make the kernel go in the opposite direction....got no idea....
                  var y1 = ds[i][2];
                  if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                      var d = ds[i][0];
                      idx = index + x1 + y1 * width;
                      idx *= 3;
                      data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));
                      data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));
                      data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));
                  }
              }
          }
      }
  };
  /*
    Returns index of palette color closest to c
  */
  GIFEncoder.prototype.findClosest = function (c, used) {
      return this.findClosestRGB((c & 0xff0000) >> 16, (c & 0x00ff00) >> 8, c & 0x0000ff, used);
  };
  GIFEncoder.prototype.findClosestRGB = function (r, g, b, used) {
      if (this.colorTab === null)
          return -1;
      if (this.neuQuant && !used) {
          return this.neuQuant.lookupRGB(r, g, b);
      }
      var minpos = 0;
      var dmin = 256 * 256 * 256;
      var len = this.colorTab.length;
      for (var i = 0, index = 0; i < len; index++) {
          var dr = r - (this.colorTab[i++] & 0xff);
          var dg = g - (this.colorTab[i++] & 0xff);
          var db = b - (this.colorTab[i++] & 0xff);
          var d = dr * dr + dg * dg + db * db;
          if ((!used || this.usedEntry[index]) && d < dmin) {
              dmin = d;
              minpos = index;
          }
      }
      return minpos;
  };
  /*
    Extracts image pixels into byte array pixels
    (removes alphachannel from canvas imagedata)
  */
  GIFEncoder.prototype.getImagePixels = function () {
      var w = this.width;
      var h = this.height;
      this.pixels = new Uint8Array(w * h * 3);
      var data = this.image;
      var srcPos = 0;
      var count = 0;
      for (var i = 0; i < h; i++) {
          for (var j = 0; j < w; j++) {
              this.pixels[count++] = data[srcPos++];
              this.pixels[count++] = data[srcPos++];
              this.pixels[count++] = data[srcPos++];
              srcPos++;
          }
      }
  };
  /*
    Writes Graphic Control Extension
  */
  GIFEncoder.prototype.writeGraphicCtrlExt = function () {
      this.out.writeByte(0x21); // extension introducer
      this.out.writeByte(0xf9); // GCE label
      this.out.writeByte(4); // data block size
      var transp, disp;
      if (this.transparent === null) {
          transp = 0;
          disp = 0; // dispose = no action
      }
      else {
          transp = 1;
          disp = 2; // force clear if using transparent color
      }
      if (this.dispose >= 0) {
          disp = this.dispose & 7; // user override
      }
      disp <<= 2;
      // packed fields
      this.out.writeByte(0 | // 1:3 reserved
          disp | // 4:6 disposal
          0 | // 7 user input - 0 = none
          transp // 8 transparency flag
      );
      this.writeShort(this.delay); // delay x 1/100 sec
      this.out.writeByte(this.transIndex); // transparent color index
      this.out.writeByte(0); // block terminator
  };
  /*
    Writes Image Descriptor
  */
  GIFEncoder.prototype.writeImageDesc = function () {
      this.out.writeByte(0x2c); // image separator
      this.writeShort(0); // image position x,y = 0,0
      this.writeShort(0);
      this.writeShort(this.width); // image size
      this.writeShort(this.height);
      // packed fields
      if (this.firstFrame || this.globalPalette) {
          // no LCT - GCT is used for first (or only) frame
          this.out.writeByte(0);
      }
      else {
          // specify normal LCT
          this.out.writeByte(0x80 | // 1 local color table 1=yes
              0 | // 2 interlace - 0=no
              0 | // 3 sorted - 0=no
              0 | // 4-5 reserved
              this.palSize // 6-8 size of color table
          );
      }
  };
  /*
    Writes Logical Screen Descriptor
  */
  GIFEncoder.prototype.writeLSD = function () {
      // logical screen size
      this.writeShort(this.width);
      this.writeShort(this.height);
      // packed fields
      this.out.writeByte(0x80 | // 1 : global color table flag = 1 (gct used)
          0x70 | // 2-4 : color resolution = 7
          0x00 | // 5 : gct sort flag = 0
          this.palSize // 6-8 : gct size
      );
      this.out.writeByte(0); // background color index
      this.out.writeByte(0); // pixel aspect ratio - assume 1:1
  };
  /*
    Writes Netscape application extension to define repeat count.
  */
  GIFEncoder.prototype.writeNetscapeExt = function () {
      this.out.writeByte(0x21); // extension introducer
      this.out.writeByte(0xff); // app extension label
      this.out.writeByte(11); // block size
      this.out.writeUTFBytes("NETSCAPE2.0"); // app id + auth code
      this.out.writeByte(3); // sub-block size
      this.out.writeByte(1); // loop sub-block id
      this.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)
      this.out.writeByte(0); // block terminator
  };
  /*
    Writes color table
  */
  GIFEncoder.prototype.writePalette = function () {
      this.out.writeBytes(this.colorTab);
      var n = 3 * 256 - this.colorTab.length;
      for (var i = 0; i < n; i++)
          this.out.writeByte(0);
  };
  GIFEncoder.prototype.writeShort = function (pValue) {
      this.out.writeByte(pValue & 0xff);
      this.out.writeByte((pValue >> 8) & 0xff);
  };
  /*
    Encodes and writes pixel data
  */
  GIFEncoder.prototype.writePixels = function () {
      var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
      enc.encode(this.out);
  };
  /*
    Retrieves the GIF stream
  */
  GIFEncoder.prototype.stream = function () {
      return this.out;
  };
  var GIFEncoder_1$1 = GIFEncoder;

  var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  };
  var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(awesomeQr, "__esModule", { value: true });
  awesomeQr.AwesomeQR = void 0;
  var canvas_1 = browser;
  var gifuct_js_1 = gifuctJs;
  var qrcode_1 = qrcode;
  var GIFEncoder_1 = __importDefault(GIFEncoder_1$1);
  var defaultScale = 0.4;
  var AwesomeQR = /** @class */ (function () {
      function AwesomeQR(options) {
          var _options = Object.assign({}, options);
          Object.keys(AwesomeQR.defaultOptions).forEach(function (k) {
              if (!(k in _options)) {
                  Object.defineProperty(_options, k, { value: AwesomeQR.defaultOptions[k], enumerable: true, writable: true });
              }
          });
          if (!_options.components) {
              _options.components = AwesomeQR.defaultComponentOptions;
          }
          else if (typeof _options.components === "object") {
              Object.keys(AwesomeQR.defaultComponentOptions).forEach(function (k) {
                  if (!(k in _options.components)) {
                      Object.defineProperty(_options.components, k, {
                          value: AwesomeQR.defaultComponentOptions[k],
                          enumerable: true,
                          writable: true,
                      });
                  }
                  else {
                      Object.defineProperty(_options.components, k, {
                          value: __assign(__assign({}, AwesomeQR.defaultComponentOptions[k]), _options.components[k]),
                          enumerable: true,
                          writable: true,
                      });
                  }
              });
          }
          if (_options.dotScale !== null && _options.dotScale !== undefined) {
              if (_options.dotScale <= 0 || _options.dotScale > 1) {
                  throw new Error("dotScale should be in range (0, 1].");
              }
              _options.components.data.scale = _options.dotScale;
              _options.components.timing.scale = _options.dotScale;
              _options.components.alignment.scale = _options.dotScale;
          }
          this.options = _options;
          this.canvas = canvas_1.createCanvas(options.size, options.size);
          this.canvasContext = this.canvas.getContext("2d");
          this.qrCode = new qrcode_1.QRCodeModel(-1, this.options.correctLevel);
          if (Number.isInteger(this.options.maskPattern)) {
              this.qrCode.maskPattern = this.options.maskPattern;
          }
          if (Number.isInteger(this.options.version)) {
              this.qrCode.typeNumber = this.options.version;
          }
          this.qrCode.addData(this.options.text);
          this.qrCode.make();
      }
      AwesomeQR.prototype.draw = function () {
          var _this = this;
          return new Promise(function (resolve) { return _this._draw().then(resolve); });
      };
      AwesomeQR.prototype._clear = function () {
          this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      AwesomeQR._prepareRoundedCornerClip = function (canvasContext, x, y, w, h, r) {
          canvasContext.beginPath();
          canvasContext.moveTo(x, y);
          canvasContext.arcTo(x + w, y, x + w, y + h, r);
          canvasContext.arcTo(x + w, y + h, x, y + h, r);
          canvasContext.arcTo(x, y + h, x, y, r);
          canvasContext.arcTo(x, y, x + w, y, r);
          canvasContext.closePath();
      };
      AwesomeQR._getAverageRGB = function (image) {
          var blockSize = 5;
          var defaultRGB = {
              r: 0,
              g: 0,
              b: 0,
          };
          var width, height;
          var i = -4;
          var rgb = {
              r: 0,
              g: 0,
              b: 0,
          };
          var count = 0;
          height = image.naturalHeight || image.height;
          width = image.naturalWidth || image.width;
          var canvas = canvas_1.createCanvas(width, height);
          var context = canvas.getContext("2d");
          if (!context) {
              return defaultRGB;
          }
          context.drawImage(image, 0, 0);
          var data;
          try {
              data = context.getImageData(0, 0, width, height);
          }
          catch (e) {
              return defaultRGB;
          }
          while ((i += blockSize * 4) < data.data.length) {
              if (data.data[i] > 200 || data.data[i + 1] > 200 || data.data[i + 2] > 200)
                  continue;
              ++count;
              rgb.r += data.data[i];
              rgb.g += data.data[i + 1];
              rgb.b += data.data[i + 2];
          }
          rgb.r = ~~(rgb.r / count);
          rgb.g = ~~(rgb.g / count);
          rgb.b = ~~(rgb.b / count);
          return rgb;
      };
      AwesomeQR._drawDot = function (canvasContext, centerX, centerY, nSize, xyOffset, dotScale) {
          if (xyOffset === void 0) { xyOffset = 0; }
          if (dotScale === void 0) { dotScale = 1; }
          canvasContext.fillRect((centerX + xyOffset) * nSize, (centerY + xyOffset) * nSize, dotScale * nSize, dotScale * nSize);
      };
      AwesomeQR._drawAlignProtector = function (canvasContext, centerX, centerY, nSize) {
          canvasContext.clearRect((centerX - 2) * nSize, (centerY - 2) * nSize, 5 * nSize, 5 * nSize);
          canvasContext.fillRect((centerX - 2) * nSize, (centerY - 2) * nSize, 5 * nSize, 5 * nSize);
      };
      AwesomeQR._drawAlign = function (canvasContext, centerX, centerY, nSize, xyOffset, dotScale, colorDark, hasProtector) {
          if (xyOffset === void 0) { xyOffset = 0; }
          if (dotScale === void 0) { dotScale = 1; }
          var oldFillStyle = canvasContext.fillStyle;
          canvasContext.fillStyle = colorDark;
          new Array(4).fill(0).map(function (_, i) {
              AwesomeQR._drawDot(canvasContext, centerX - 2 + i, centerY - 2, nSize, xyOffset, dotScale);
              AwesomeQR._drawDot(canvasContext, centerX + 2, centerY - 2 + i, nSize, xyOffset, dotScale);
              AwesomeQR._drawDot(canvasContext, centerX + 2 - i, centerY + 2, nSize, xyOffset, dotScale);
              AwesomeQR._drawDot(canvasContext, centerX - 2, centerY + 2 - i, nSize, xyOffset, dotScale);
          });
          AwesomeQR._drawDot(canvasContext, centerX, centerY, nSize, xyOffset, dotScale);
          if (!hasProtector) {
              canvasContext.fillStyle = "rgba(255, 255, 255, 0.6)";
              new Array(2).fill(0).map(function (_, i) {
                  AwesomeQR._drawDot(canvasContext, centerX - 1 + i, centerY - 1, nSize, xyOffset, dotScale);
                  AwesomeQR._drawDot(canvasContext, centerX + 1, centerY - 1 + i, nSize, xyOffset, dotScale);
                  AwesomeQR._drawDot(canvasContext, centerX + 1 - i, centerY + 1, nSize, xyOffset, dotScale);
                  AwesomeQR._drawDot(canvasContext, centerX - 1, centerY + 1 - i, nSize, xyOffset, dotScale);
              });
          }
          canvasContext.fillStyle = oldFillStyle;
      };
      AwesomeQR.prototype._draw = function () {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
          return __awaiter(this, void 0, void 0, function () {
              var nCount, rawSize, rawMargin, margin, rawViewportSize, whiteMargin, backgroundDimming, nSize, viewportSize, size, mainCanvas, mainCanvasContext, backgroundCanvas, backgroundCanvasContext, parsedGIFBackground, gifFrames, gif, r, g, b, count, i, c, backgroundImage, avgRGB, alignmentPatternCenters, dataScale, dataXyOffset, row, col, bIsDark, isBlkPosCtr, isTiming, isProtected, i, nLeft, nTop, inAgnRange, cornerAlignmentCenter, protectorStyle, i, j, agnX, agnY, timingScale, timingXyOffset, i, cornerAlignmentScale, cornerAlignmentXyOffset, alignmentScale, alignmentXyOffset, i, j, agnX, agnY, logoImage, logoScale, logoMargin, logoCornerRadius, logoSize, x, y, oldGlobalCompositeOperation, gifOutput_1, backgroundCanvas_1, backgroundCanvasContext_1, patchCanvas_1, patchCanvasContext_1, patchData_1, u8array, binary, outCanvas, outCanvasContext;
              return __generator(this, function (_v) {
                  switch (_v.label) {
                      case 0:
                          nCount = (_a = this.qrCode) === null || _a === void 0 ? void 0 : _a.moduleCount;
                          rawSize = this.options.size;
                          rawMargin = this.options.margin;
                          if (rawMargin < 0 || rawMargin * 2 >= rawSize) {
                              rawMargin = 0;
                          }
                          margin = Math.ceil(rawMargin);
                          rawViewportSize = rawSize - 2 * rawMargin;
                          whiteMargin = this.options.whiteMargin;
                          backgroundDimming = this.options.backgroundDimming;
                          nSize = Math.ceil(rawViewportSize / nCount);
                          viewportSize = nSize * nCount;
                          size = viewportSize + 2 * margin;
                          mainCanvas = canvas_1.createCanvas(size, size);
                          mainCanvasContext = mainCanvas.getContext("2d");
                          this._clear();
                          // Translate to make the top and left margins off the viewport
                          mainCanvasContext.save();
                          mainCanvasContext.translate(margin, margin);
                          backgroundCanvas = canvas_1.createCanvas(size, size);
                          backgroundCanvasContext = backgroundCanvas.getContext("2d");
                          parsedGIFBackground = null;
                          gifFrames = [];
                          if (!!!this.options.gifBackground) return [3 /*break*/, 1];
                          gif = gifuct_js_1.parseGIF(this.options.gifBackground);
                          parsedGIFBackground = gif;
                          gifFrames = gifuct_js_1.decompressFrames(gif, true);
                          if (this.options.autoColor) {
                              r = 0, g = 0, b = 0;
                              count = 0;
                              for (i = 0; i < gifFrames[0].colorTable.length; i++) {
                                  c = gifFrames[0].colorTable[i];
                                  if (c[0] > 200 || c[1] > 200 || c[2] > 200)
                                      continue;
                                  if (c[0] === 0 && c[1] === 0 && c[2] === 0)
                                      continue;
                                  count++;
                                  r += c[0];
                                  g += c[1];
                                  b += c[2];
                              }
                              r = ~~(r / count);
                              g = ~~(g / count);
                              b = ~~(b / count);
                              this.options.colorDark = "rgb(" + r + "," + g + "," + b + ")";
                          }
                          return [3 /*break*/, 4];
                      case 1:
                          if (!!!this.options.backgroundImage) return [3 /*break*/, 3];
                          return [4 /*yield*/, canvas_1.loadImage(this.options.backgroundImage)];
                      case 2:
                          backgroundImage = _v.sent();
                          if (this.options.autoColor) {
                              avgRGB = AwesomeQR._getAverageRGB(backgroundImage);
                              this.options.colorDark = "rgb(" + avgRGB.r + "," + avgRGB.g + "," + avgRGB.b + ")";
                          }
                          backgroundCanvasContext.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height, 0, 0, size, size);
                          backgroundCanvasContext.rect(0, 0, size, size);
                          backgroundCanvasContext.fillStyle = backgroundDimming;
                          backgroundCanvasContext.fill();
                          return [3 /*break*/, 4];
                      case 3:
                          backgroundCanvasContext.rect(0, 0, size, size);
                          backgroundCanvasContext.fillStyle = this.options.colorLight;
                          backgroundCanvasContext.fill();
                          _v.label = 4;
                      case 4:
                          alignmentPatternCenters = qrcode_1.QRUtil.getPatternPosition(this.qrCode.typeNumber);
                          dataScale = ((_c = (_b = this.options.components) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.scale) || defaultScale;
                          dataXyOffset = (1 - dataScale) * 0.5;
                          for (row = 0; row < nCount; row++) {
                              for (col = 0; col < nCount; col++) {
                                  bIsDark = this.qrCode.isDark(row, col);
                                  isBlkPosCtr = (col < 8 && (row < 8 || row >= nCount - 8)) || (col >= nCount - 8 && row < 8);
                                  isTiming = (row == 6 && col >= 8 && col <= nCount - 8) || (col == 6 && row >= 8 && row <= nCount - 8);
                                  isProtected = isBlkPosCtr || isTiming;
                                  for (i = 1; i < alignmentPatternCenters.length - 1; i++) {
                                      isProtected =
                                          isProtected ||
                                              (row >= alignmentPatternCenters[i] - 2 &&
                                                  row <= alignmentPatternCenters[i] + 2 &&
                                                  col >= alignmentPatternCenters[i] - 2 &&
                                                  col <= alignmentPatternCenters[i] + 2);
                                  }
                                  nLeft = col * nSize + (isProtected ? 0 : dataXyOffset * nSize);
                                  nTop = row * nSize + (isProtected ? 0 : dataXyOffset * nSize);
                                  mainCanvasContext.strokeStyle = bIsDark ? this.options.colorDark : this.options.colorLight;
                                  mainCanvasContext.lineWidth = 0.5;
                                  mainCanvasContext.fillStyle = bIsDark ? this.options.colorDark : "rgba(255, 255, 255, 0.6)";
                                  if (alignmentPatternCenters.length === 0) {
                                      if (!isProtected) {
                                          mainCanvasContext.fillRect(nLeft, nTop, (isProtected ? (isBlkPosCtr ? 1 : 1) : dataScale) * nSize, (isProtected ? (isBlkPosCtr ? 1 : 1) : dataScale) * nSize);
                                      }
                                  }
                                  else {
                                      inAgnRange = col < nCount - 4 && col >= nCount - 4 - 5 && row < nCount - 4 && row >= nCount - 4 - 5;
                                      if (!isProtected && !inAgnRange) {
                                          // if align pattern list is empty, then it means that we don't need to leave room for the align patterns
                                          mainCanvasContext.fillRect(nLeft, nTop, (isProtected ? (isBlkPosCtr ? 1 : 1) : dataScale) * nSize, (isProtected ? (isBlkPosCtr ? 1 : 1) : dataScale) * nSize);
                                      }
                                  }
                              }
                          }
                          cornerAlignmentCenter = alignmentPatternCenters[alignmentPatternCenters.length - 1];
                          protectorStyle = "rgba(255, 255, 255, 0.6)";
                          // - FINDER PROTECTORS
                          mainCanvasContext.fillStyle = protectorStyle;
                          mainCanvasContext.fillRect(0, 0, 8 * nSize, 8 * nSize);
                          mainCanvasContext.fillRect(0, (nCount - 8) * nSize, 8 * nSize, 8 * nSize);
                          mainCanvasContext.fillRect((nCount - 8) * nSize, 0, 8 * nSize, 8 * nSize);
                          // - TIMING PROTECTORS
                          if ((_e = (_d = this.options.components) === null || _d === void 0 ? void 0 : _d.timing) === null || _e === void 0 ? void 0 : _e.protectors) {
                              mainCanvasContext.fillRect(8 * nSize, 6 * nSize, (nCount - 8 - 8) * nSize, nSize);
                              mainCanvasContext.fillRect(6 * nSize, 8 * nSize, nSize, (nCount - 8 - 8) * nSize);
                          }
                          // - CORNER ALIGNMENT PROTECTORS
                          if ((_g = (_f = this.options.components) === null || _f === void 0 ? void 0 : _f.cornerAlignment) === null || _g === void 0 ? void 0 : _g.protectors) {
                              AwesomeQR._drawAlignProtector(mainCanvasContext, cornerAlignmentCenter, cornerAlignmentCenter, nSize);
                          }
                          // - ALIGNMENT PROTECTORS
                          if ((_j = (_h = this.options.components) === null || _h === void 0 ? void 0 : _h.alignment) === null || _j === void 0 ? void 0 : _j.protectors) {
                              for (i = 0; i < alignmentPatternCenters.length; i++) {
                                  for (j = 0; j < alignmentPatternCenters.length; j++) {
                                      agnX = alignmentPatternCenters[j];
                                      agnY = alignmentPatternCenters[i];
                                      if (agnX === 6 && (agnY === 6 || agnY === cornerAlignmentCenter)) {
                                          continue;
                                      }
                                      else if (agnY === 6 && (agnX === 6 || agnX === cornerAlignmentCenter)) {
                                          continue;
                                      }
                                      else if (agnX === cornerAlignmentCenter && agnY === cornerAlignmentCenter) {
                                          continue;
                                      }
                                      else {
                                          AwesomeQR._drawAlignProtector(mainCanvasContext, agnX, agnY, nSize);
                                      }
                                  }
                              }
                          }
                          // - FINDER
                          mainCanvasContext.fillStyle = this.options.colorDark;
                          mainCanvasContext.fillRect(0, 0, 7 * nSize, nSize);
                          mainCanvasContext.fillRect((nCount - 7) * nSize, 0, 7 * nSize, nSize);
                          mainCanvasContext.fillRect(0, 6 * nSize, 7 * nSize, nSize);
                          mainCanvasContext.fillRect((nCount - 7) * nSize, 6 * nSize, 7 * nSize, nSize);
                          mainCanvasContext.fillRect(0, (nCount - 7) * nSize, 7 * nSize, nSize);
                          mainCanvasContext.fillRect(0, (nCount - 7 + 6) * nSize, 7 * nSize, nSize);
                          mainCanvasContext.fillRect(0, 0, nSize, 7 * nSize);
                          mainCanvasContext.fillRect(6 * nSize, 0, nSize, 7 * nSize);
                          mainCanvasContext.fillRect((nCount - 7) * nSize, 0, nSize, 7 * nSize);
                          mainCanvasContext.fillRect((nCount - 7 + 6) * nSize, 0, nSize, 7 * nSize);
                          mainCanvasContext.fillRect(0, (nCount - 7) * nSize, nSize, 7 * nSize);
                          mainCanvasContext.fillRect(6 * nSize, (nCount - 7) * nSize, nSize, 7 * nSize);
                          mainCanvasContext.fillRect(2 * nSize, 2 * nSize, 3 * nSize, 3 * nSize);
                          mainCanvasContext.fillRect((nCount - 7 + 2) * nSize, 2 * nSize, 3 * nSize, 3 * nSize);
                          mainCanvasContext.fillRect(2 * nSize, (nCount - 7 + 2) * nSize, 3 * nSize, 3 * nSize);
                          timingScale = ((_l = (_k = this.options.components) === null || _k === void 0 ? void 0 : _k.timing) === null || _l === void 0 ? void 0 : _l.scale) || defaultScale;
                          timingXyOffset = (1 - timingScale) * 0.5;
                          for (i = 0; i < nCount - 8; i += 2) {
                              AwesomeQR._drawDot(mainCanvasContext, 8 + i, 6, nSize, timingXyOffset, timingScale);
                              AwesomeQR._drawDot(mainCanvasContext, 6, 8 + i, nSize, timingXyOffset, timingScale);
                          }
                          cornerAlignmentScale = ((_o = (_m = this.options.components) === null || _m === void 0 ? void 0 : _m.cornerAlignment) === null || _o === void 0 ? void 0 : _o.scale) || defaultScale;
                          cornerAlignmentXyOffset = (1 - cornerAlignmentScale) * 0.5;
                          AwesomeQR._drawAlign(mainCanvasContext, cornerAlignmentCenter, cornerAlignmentCenter, nSize, cornerAlignmentXyOffset, cornerAlignmentScale, this.options.colorDark, ((_q = (_p = this.options.components) === null || _p === void 0 ? void 0 : _p.cornerAlignment) === null || _q === void 0 ? void 0 : _q.protectors) || false);
                          alignmentScale = ((_s = (_r = this.options.components) === null || _r === void 0 ? void 0 : _r.alignment) === null || _s === void 0 ? void 0 : _s.scale) || defaultScale;
                          alignmentXyOffset = (1 - alignmentScale) * 0.5;
                          for (i = 0; i < alignmentPatternCenters.length; i++) {
                              for (j = 0; j < alignmentPatternCenters.length; j++) {
                                  agnX = alignmentPatternCenters[j];
                                  agnY = alignmentPatternCenters[i];
                                  if (agnX === 6 && (agnY === 6 || agnY === cornerAlignmentCenter)) {
                                      continue;
                                  }
                                  else if (agnY === 6 && (agnX === 6 || agnX === cornerAlignmentCenter)) {
                                      continue;
                                  }
                                  else if (agnX === cornerAlignmentCenter && agnY === cornerAlignmentCenter) {
                                      continue;
                                  }
                                  else {
                                      AwesomeQR._drawAlign(mainCanvasContext, agnX, agnY, nSize, alignmentXyOffset, alignmentScale, this.options.colorDark, ((_u = (_t = this.options.components) === null || _t === void 0 ? void 0 : _t.alignment) === null || _u === void 0 ? void 0 : _u.protectors) || false);
                                  }
                              }
                          }
                          // Fill the margin
                          if (whiteMargin) {
                              mainCanvasContext.fillStyle = "#FFFFFF";
                              mainCanvasContext.fillRect(-margin, -margin, size, margin);
                              mainCanvasContext.fillRect(-margin, viewportSize, size, margin);
                              mainCanvasContext.fillRect(viewportSize, -margin, margin, size);
                              mainCanvasContext.fillRect(-margin, -margin, margin, size);
                          }
                          if (!!!this.options.logoImage) return [3 /*break*/, 6];
                          return [4 /*yield*/, canvas_1.loadImage(this.options.logoImage)];
                      case 5:
                          logoImage = _v.sent();
                          logoScale = this.options.logoScale;
                          logoMargin = this.options.logoMargin;
                          logoCornerRadius = this.options.logoCornerRadius;
                          if (logoScale <= 0 || logoScale >= 1.0) {
                              logoScale = 0.2;
                          }
                          if (logoMargin < 0) {
                              logoMargin = 0;
                          }
                          if (logoCornerRadius < 0) {
                              logoCornerRadius = 0;
                          }
                          logoSize = viewportSize * logoScale;
                          x = 0.5 * (size - logoSize);
                          y = x;
                          // Restore the canvas
                          // After restoring, the top and left margins should be taken into account
                          mainCanvasContext.restore();
                          // Clean the area that the logo covers (including margins)
                          mainCanvasContext.fillStyle = "#FFFFFF";
                          mainCanvasContext.save();
                          AwesomeQR._prepareRoundedCornerClip(mainCanvasContext, x - logoMargin, y - logoMargin, logoSize + 2 * logoMargin, logoSize + 2 * logoMargin, logoCornerRadius + logoMargin);
                          mainCanvasContext.clip();
                          oldGlobalCompositeOperation = mainCanvasContext.globalCompositeOperation;
                          mainCanvasContext.globalCompositeOperation = "destination-out";
                          mainCanvasContext.fill();
                          mainCanvasContext.globalCompositeOperation = oldGlobalCompositeOperation;
                          mainCanvasContext.restore();
                          // Draw logo image
                          mainCanvasContext.save();
                          AwesomeQR._prepareRoundedCornerClip(mainCanvasContext, x, y, logoSize, logoSize, logoCornerRadius);
                          mainCanvasContext.clip();
                          mainCanvasContext.drawImage(logoImage, x, y, logoSize, logoSize);
                          mainCanvasContext.restore();
                          // Re-translate the canvas to translate the top and left margins into invisible area
                          mainCanvasContext.save();
                          mainCanvasContext.translate(margin, margin);
                          _v.label = 6;
                      case 6:
                          if (!!parsedGIFBackground) {
                              gifFrames.forEach(function (frame) {
                                  if (!gifOutput_1) {
                                      gifOutput_1 = new GIFEncoder_1.default(rawSize, rawSize);
                                      gifOutput_1.setDelay(frame.delay);
                                      gifOutput_1.setRepeat(0);
                                  }
                                  var _a = frame.dims, width = _a.width, height = _a.height;
                                  if (!backgroundCanvas_1) {
                                      backgroundCanvas_1 = canvas_1.createCanvas(width, height);
                                      backgroundCanvasContext_1 = backgroundCanvas_1.getContext("2d");
                                      backgroundCanvasContext_1.rect(0, 0, backgroundCanvas_1.width, backgroundCanvas_1.height);
                                      backgroundCanvasContext_1.fillStyle = "#ffffff";
                                      backgroundCanvasContext_1.fill();
                                  }
                                  if (!patchCanvas_1 || !patchData_1 || width !== patchCanvas_1.width || height !== patchCanvas_1.height) {
                                      patchCanvas_1 = canvas_1.createCanvas(width, height);
                                      patchCanvasContext_1 = patchCanvas_1.getContext("2d");
                                      patchData_1 = patchCanvasContext_1.createImageData(width, height);
                                  }
                                  patchData_1.data.set(frame.patch);
                                  patchCanvasContext_1.putImageData(patchData_1, 0, 0);
                                  backgroundCanvasContext_1.drawImage(patchCanvas_1, frame.dims.left, frame.dims.top);
                                  var unscaledCanvas = canvas_1.createCanvas(size, size);
                                  var unscaledCanvasContext = unscaledCanvas.getContext("2d");
                                  unscaledCanvasContext.drawImage(backgroundCanvas_1, 0, 0, size, size);
                                  unscaledCanvasContext.rect(0, 0, size, size);
                                  unscaledCanvasContext.fillStyle = backgroundDimming;
                                  unscaledCanvasContext.fill();
                                  unscaledCanvasContext.drawImage(mainCanvas, 0, 0, size, size);
                                  // Scale the final image
                                  var outCanvas = canvas_1.createCanvas(rawSize, rawSize);
                                  var outCanvasContext = outCanvas.getContext("2d");
                                  outCanvasContext.drawImage(unscaledCanvas, 0, 0, rawSize, rawSize);
                                  gifOutput_1.addFrame(outCanvasContext.getImageData(0, 0, outCanvas.width, outCanvas.height).data);
                              });
                              if (!gifOutput_1) {
                                  throw new Error("No frames.");
                              }
                              gifOutput_1.finish();
                              if (isElement(this.canvas)) {
                                  u8array = gifOutput_1.stream().toFlattenUint8Array();
                                  binary = u8array.reduce(function (bin, u8) { return bin + String.fromCharCode(u8); }, "");
                                  return [2 /*return*/, Promise.resolve("data:image/gif;base64," + window.btoa(binary))];
                              }
                              return [2 /*return*/, Promise.resolve(Buffer.from(gifOutput_1.stream().toFlattenUint8Array()))];
                          }
                          else {
                              // Swap and merge the foreground and the background
                              backgroundCanvasContext.drawImage(mainCanvas, 0, 0, size, size);
                              mainCanvasContext.drawImage(backgroundCanvas, -margin, -margin, size, size);
                              outCanvas = canvas_1.createCanvas(rawSize, rawSize);
                              outCanvasContext = outCanvas.getContext("2d");
                              outCanvasContext.drawImage(mainCanvas, 0, 0, rawSize, rawSize);
                              this.canvas = outCanvas;
                              if (isElement(this.canvas)) {
                                  return [2 /*return*/, Promise.resolve(this.canvas.toDataURL())];
                              }
                              return [2 /*return*/, Promise.resolve(this.canvas.toBuffer())];
                          }
                  }
              });
          });
      };
      AwesomeQR.CorrectLevel = qrcode_1.QRErrorCorrectLevel;
      AwesomeQR.defaultComponentOptions = {
          data: {
              scale: 1,
          },
          timing: {
              scale: 1,
              protectors: false,
          },
          alignment: {
              scale: 1,
              protectors: false,
          },
          cornerAlignment: {
              scale: 1,
              protectors: true,
          },
      };
      AwesomeQR.defaultOptions = {
          text: "",
          size: 400,
          margin: 20,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: qrcode_1.QRErrorCorrectLevel.M,
          backgroundImage: undefined,
          backgroundDimming: "rgba(0,0,0,0)",
          logoImage: undefined,
          logoScale: 0.2,
          logoMargin: 4,
          logoCornerRadius: 8,
          whiteMargin: true,
          components: AwesomeQR.defaultComponentOptions,
          autoColor: true,
      };
      return AwesomeQR;
  }());
  awesomeQr.AwesomeQR = AwesomeQR;
  function isElement(obj) {
      try {
          //Using W3 DOM2 (works for FF, Opera and Chrome)
          return obj instanceof HTMLElement;
      }
      catch (e) {
          //Browsers not supporting W3 DOM2 don't have HTMLElement and
          //an exception is thrown and we end up here. Testing some
          //properties that all elements have (works on IE7)
          return (typeof obj === "object" &&
              obj.nodeType === 1 &&
              typeof obj.style === "object" &&
              typeof obj.ownerDocument === "object");
      }
  }

  (function (exports) {
  	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  	}) : (function(o, m, k, k2) {
  	    if (k2 === undefined) k2 = k;
  	    o[k2] = m[k];
  	}));
  	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
  	    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
  	};
  	Object.defineProperty(exports, "__esModule", { value: true });
  	__exportStar(qrcode, exports);
  	var awesome_qr_1 = awesomeQr;
  	Object.defineProperty(exports, "AwesomeQR", { enumerable: true, get: function () { return awesome_qr_1.AwesomeQR; } });
  } (lib$1));

  var InstallModal = function (_a) {
      var link = _a.link;
      var div = document.createElement('div');
      div.innerHTML = "<div id=\"modal\" style=\"display:none; position: fixed; left: 50%; transform: translate(-50%, -50%); z-index: 99999; background: #fff; padding: 20px; border-radius: 5px; font-family: sans-serif; top: 50%;\">\n        <h2>Install MetaMask Extension</h2>\n        <a id=\"install-extension\" style=\"background: rgb(3, 125, 214); cursor: pointer; text-align: center; transition: all 300ms ease 0s; color: rgb(255, 255, 255); min-height: 52px; display: inline-flex; -webkit-box-align: center; align-items: center; -webkit-box-pack: center; justify-content: center; padding: 8px 20px; border-radius: 999px; font-size: 16px; line-height: 1.3;\">\n          Install MetaMask Extension\n        </a>\n        <h2>Or scan with MetaMask Mobile</h2>\n        <span>Open your MetaMask Mobile on your phone and scan</span>\n        <div id=\"qr\"/>\n    </div>";
      document.body.appendChild(div);
      var fader = document.createElement('div');
      fader.innerHTML = "<div id=\"fader\" style=\"display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; z-index: 99998; background: rgba(0,0,0,0.6);\">\n    </div>";
      document.body.appendChild(fader);
      function showModalWindow() {
          document.getElementById('fader').style.display = 'block';
          document.getElementById('modal').style.display = 'block';
      }
      function hideAllModalWindows() {
          var modalFader = document.getElementById('fader');
          var modalWindow = document.getElementById('modal');
          modalFader.style.display = 'none';
          modalWindow.style.display = 'none';
      }
      var qr = document.getElementById('qr');
      new lib$1.AwesomeQR({
          text: link,
          size: 500,
      })
          .draw()
          .then(function (dataURL) {
          var img = document.createElement('img');
          // @ts-ignore
          img.src = dataURL;
          img.width = 200;
          img.height = 200;
          qr.appendChild(img);
      });
      showModalWindow();
      document.getElementById('fader').addEventListener('click', function () {
          hideAllModalWindows();
      });
      document.getElementById('install-extension').addEventListener('click', function () {
          hideAllModalWindows();
          ManageMetaMaskInstallation.startDesktopOnboarding();
      });
  };

  var connector = new WalletConnect$1({
      bridge: 'https://bridge.walletconnect.org', // Required
  });
  var WalletConnect = {
      connector: connector,
      forceRestart: false,
      isConnected: function () {
          return connector.connected;
      },
      isDesktop: false,
      sentFirstConnect: false,
      startConnection: function () {
          var _this = this;
          return new Promise(function (resolve, reject) {
              if (connector.connected) {
                  return resolve(true);
              }
              connector
                  .createSession()
                  .then(function () {
                  var link = "" + 'https://metamask.app.link/wc?uri=' + encodeURIComponent(connector.uri);
                  if (_this.isDesktop) {
                      InstallModal({ link: link });
                  }
                  else {
                      // window.location.assign(link);
                      if(window.ReactNativeWebView){
                        window.ReactNativeWebView.postMessage(JSON.stringify({method: 'openLink', link}))
                      }else{
                        window.open(link, '_self');
                      }
                  }
                  WalletConnect.connector.on('connect', function () {
                      if (_this.sentFirstConnect) {
                          return;
                      }
                      resolve(true);
                      _this.sentFirstConnect = true;
                  });
              })
                  .catch(function (error) { return reject(error); });
          });
      },
  };

  var waitPromise = function (time) {
      return new Promise(function (resolve) {
          setTimeout(function () {
              resolve(true);
          }, time);
      });
  };

  // ethereum.on('connect', handler: (connectInfo: ConnectInfo) => void);
  // ethereum.on('disconnect', handler: (error: ProviderRpcError) => void);
  var ManageMetaMaskInstallation = {
      isInstalling: false,
      hasInstalled: false,
      resendRequest: null,
      preferDesktop: false,
      startDesktopOnboarding: function () {
          delete window.ethereum;
          var onboardingExtension = new Onboarding();
          onboardingExtension.startOnboarding();
      },
      redirectToProperInstall: function () {
          return __awaiter$2(this, void 0, void 0, function () {
              var startedWCConnection, startedWCConnection;
              return __generator$2(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // If it's running on our mobile in-app browser but communication is still not working
                          if (isMetaMaskMobileWebView()) {
                              // eslint-disable-next-line no-alert
                              alert('Please save your seedphrase and try to reinstall MetaMask Mobile');
                              return [2 /*return*/, false];
                          }
                          if (!!isMobile$1()) return [3 /*break*/, 2];
                          this.isInstalling = true;
                          if (this.preferDesktop) {
                              this.startDesktopOnboarding();
                              return [2 /*return*/, false];
                          }
                          return [4 /*yield*/, WalletConnect.startConnection()];
                      case 1:
                          startedWCConnection = _a.sent();
                          if (startedWCConnection) {
                              this.isInstalling = false;
                              this.hasInstalled = true;
                          }
                          return [2 /*return*/, startedWCConnection];
                      case 2:
                          if (!isMobile$1()) return [3 /*break*/, 4];
                          this.isInstalling = true;
                          return [4 /*yield*/, WalletConnect.startConnection()];
                      case 3:
                          startedWCConnection = _a.sent();
                          if (startedWCConnection) {
                              this.isInstalling = false;
                              this.hasInstalled = true;
                          }
                          return [2 /*return*/, startedWCConnection];
                      case 4: return [2 /*return*/, false];
                  }
              });
          });
      },
      checkInstallation: function () {
          return __awaiter$2(this, void 0, void 0, function () {
              var isInstalled;
              return __generator$2(this, function (_a) {
                  isInstalled = isMetaMaskInstalled();
                  // No need to do anything
                  if (isInstalled) {
                      return [2 /*return*/, true];
                  }
                  return [2 /*return*/, this.redirectToProperInstall()];
              });
          });
      },
      start: function (_a) {
          var _b = _a.wait, wait = _b === void 0 ? false : _b;
          return __awaiter$2(this, void 0, void 0, function () {
              return __generator$2(this, function (_c) {
                  switch (_c.label) {
                      case 0:
                          if (!wait) return [3 /*break*/, 2];
                          return [4 /*yield*/, waitPromise(1000)];
                      case 1:
                          _c.sent();
                          _c.label = 2;
                      case 2: return [2 /*return*/, this.checkInstallation()];
                  }
              });
          });
      },
  };

  var initializeProvider = function (_a) {
      var _b = _a.checkInstallationOnAllCalls, checkInstallationOnAllCalls = _b === void 0 ? false : _b;
      // Setup stream for content script communication
      var metamaskStream = new dist.WindowPostMessageStream({
          name: ProviderConstants.INPAGE,
          target: ProviderConstants.CONTENT_SCRIPT,
      });
      // Initialize provider object (window.ethereum)
      dist$6.initializeProvider({
          // @ts-ignore
          connectionStream: metamaskStream,
          shouldSendMetadata: false,
      });
      // Wrap ethereum.request call to check if the user needs to install MetaMask
      // eslint-disable-next-line prefer-destructuring
      var request = window.ethereum.request;
      window.ethereum.request = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return __awaiter$2(void 0, void 0, void 0, function () {
              var isInstalled, isConnectedNow;
              var _a;
              return __generator$2(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          isInstalled = isMetaMaskInstalled();
                          if (!!isInstalled) return [3 /*break*/, 3];
                          if (!(((_a = args[0]) === null || _a === void 0 ? void 0 : _a.method) === 'eth_requestAccounts' ||
                              checkInstallationOnAllCalls)) return [3 /*break*/, 2];
                          return [4 /*yield*/, ManageMetaMaskInstallation.start({
                                  wait: false,
                              })];
                      case 1:
                          isConnectedNow = _b.sent();
                          // Installation/connection is now completed so we are sending the request
                          if (isConnectedNow) {
                              return [2 /*return*/, request.apply(void 0, args)];
                          }
                          _b.label = 2;
                      case 2: throw new Error('Wait until MetaMask is installed');
                      case 3: return [2 /*return*/, request.apply(void 0, args)];
                  }
              });
          });
      };
  };

  var readable = {exports: {}};

  (function (module, exports) {
  	var Stream = require$$0;
  	if (browser$1$1.env.READABLE_STREAM === 'disable' && Stream) {
  	  module.exports = Stream;
  	  exports = module.exports = Stream.Readable;
  	  exports.Readable = Stream.Readable;
  	  exports.Writable = Stream.Writable;
  	  exports.Duplex = Stream.Duplex;
  	  exports.Transform = Stream.Transform;
  	  exports.PassThrough = Stream.PassThrough;
  	  exports.Stream = Stream;
  	} else {
  	  exports = module.exports = require_stream_readable$1();
  	  exports.Stream = Stream || exports;
  	  exports.Readable = exports;
  	  exports.Writable = require_stream_writable$1();
  	  exports.Duplex = require_stream_duplex$1();
  	  exports.Transform = require_stream_transform();
  	  exports.PassThrough = require_stream_passthrough();
  	}
  } (readable, readable.exports));

  const { Duplex } = readable.exports;
  const endOfStream = endOfStream$1;
  const once = once$4.exports;

  const IGNORE_SUBSTREAM = {};


  class ObjectMultiplex extends Duplex {

    constructor(_opts = {}) {
      const opts = Object.assign({}, _opts, {
        objectMode: true,
      });
      super(opts);

      this._substreams = {};
    }

    createStream (name) {
      // validate name
      if (!name) throw new Error('ObjectMultiplex - name must not be empty')
      if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')

      // create substream
      const substream = new Substream({ parent: this, name: name });
      this._substreams[name] = substream;

      // listen for parent stream to end
      anyStreamEnd(this, (err) => {
        substream.destroy(err);
      });

      return substream
    }

    // ignore streams (dont display orphaned data warning)
    ignoreStream (name) {
      // validate name
      if (!name) throw new Error('ObjectMultiplex - name must not be empty')
      if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')
      // set
      this._substreams[name] = IGNORE_SUBSTREAM;
    }

    // stream plumbing

    _read () {}

    _write(chunk, encoding, callback) {
      // parse message
      const name = chunk.name;
      const data = chunk.data;
      if (!name) {
        console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`);
        return callback()
      }

      // get corresponding substream
      const substream = this._substreams[name];
      if (!substream) {
        console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`);
        return callback()
      }

      // push data into substream
      if (substream !== IGNORE_SUBSTREAM) {
        substream.push(data);
      }

      callback();
    }

  }


  class Substream extends Duplex {

    constructor ({ parent, name }) {
      super({
        objectMode: true,
      });

      this._parent = parent;
      this._name = name;
    }

    _read () {}

    _write (chunk, enc, callback) {
      this._parent.push({
        name: this._name,
        data: chunk,
      });
      callback();
    }

  }

  var objMultiplex = ObjectMultiplex;

  // util

  function anyStreamEnd(stream, _cb) {
    const cb = once(_cb);
    endOfStream(stream, { readable: false }, cb);
    endOfStream(stream, { writable: false }, cb);
  }

  /**
   * Setup function called from content script after the DOM is ready.
   */
  function setupProviderStreams(PortStream) {
      // the transport-specific streams for communication between inpage and background
      var pageStream = new dist.WindowPostMessageStream({
          name: ProviderConstants.CONTENT_SCRIPT,
          target: ProviderConstants.INPAGE,
      });
      var appStream = new PortStream({
          name: ProviderConstants.CONTENT_SCRIPT,
      });
      // create and connect channel muxes
      // so we can handle the channels individually
      var pageMux = new objMultiplex();
      pageMux.setMaxListeners(25);
      var appMux = new objMultiplex();
      appMux.setMaxListeners(25);
      pump_1$1(pageMux, pageStream, pageMux, function (err) {
          return logStreamDisconnectWarning('MetaMask Inpage Multiplex', err);
      });
      pump_1$1(appMux, appStream, appMux, function (err) {
          logStreamDisconnectWarning('MetaMask Background Multiplex', err);
          notifyProviderOfStreamFailure();
      });
      // forward communication across inpage-background for these channels only
      forwardTrafficBetweenMuxes(ProviderConstants.PROVIDER, pageMux, appMux);
      // add web3 shim
      dist$6.shimWeb3(window.ethereum);
  }
  /**
   * Set up two-way communication between muxes for a single, named channel.
   *
   * @param {string} channelName - The name of the channel.
   * @param {ObjectMultiplex} muxA - The first mux.
   * @param {ObjectMultiplex} muxB - The second mux.
   */
  function forwardTrafficBetweenMuxes(channelName, muxA, muxB) {
      var channelA = muxA.createStream(channelName);
      var channelB = muxB.createStream(channelName);
      pump_1$1(channelA, channelB, channelA, function (err) {
          return logStreamDisconnectWarning("MetaMask muxed traffic for channel \"" + channelName + "\" failed.", err);
      });
  }
  /**
   * Error handler for page to extension stream disconnections
   *
   * @param {string} remoteLabel - Remote stream name
   * @param {Error} err - Stream connection error
   */
  function logStreamDisconnectWarning(remoteLabel, err) {
      var warningMsg = "MetamaskContentscript - lost connection to " + remoteLabel;
      if (err) {
          warningMsg += "\n" + err.stack;
      }
      console.warn(warningMsg);
      console.error(err);
  }
  /**
   * This function must ONLY be called in pump destruction/close callbacks.
   * Notifies the inpage context that streams have failed, via window.postMessage.
   * Relies on @metamask/object-multiplex and post-message-stream implementation details.
   */
  function notifyProviderOfStreamFailure() {
      window.postMessage({
          target: ProviderConstants.INPAGE,
          data: {
              // this object gets passed to object-multiplex
              name: ProviderConstants.PROVIDER,
              data: {
                  jsonrpc: '2.0',
                  method: 'METAMASK_STREAM_FAILURE',
              },
          },
      }, window.location.origin);
  }

  var noop$1 = function () { return undefined; };
  /**
   * Creates a stream that's both readable and writable.
   * The stream supports arbitrary objects.
   *
   * @class
   * @param {Object} port Remote Port object
   */
  var MobilePortStream = /** @class */ (function (_super) {
      __extends(MobilePortStream, _super);
      function MobilePortStream(port) {
          var _this = _super.call(this) || this;
          Duplex$2.call(_this, {
              objectMode: true,
          });
          _this._name = port.name;
          _this._targetWindow = window;
          _this._port = port;
          _this._origin = location.origin;
          window.addEventListener('message', _this._onMessage.bind(_this), false);
          return _this;
      }
      return MobilePortStream;
  }(Duplex$2));
  /**
   * Callback triggered when a message is received from
   * the remote Port associated with this Stream.
   *
   * @private
   * @param {Object} msg - Payload from the onMessage listener of Port
   */
  MobilePortStream.prototype._onMessage = function (event) {
      var _a;
      var msg = event.data;
      // validate message
      if (this._origin !== '*' && event.origin !== this._origin) {
          return;
      }
      if (!msg || typeof msg !== 'object') {
          return;
      }
      if (!msg.data || typeof msg.data !== 'object') {
          return;
      }
      if (msg.target && msg.target !== this._name) {
          return;
      }
      // Filter outgoing messages
      if ((_a = msg.data.data) === null || _a === void 0 ? void 0 : _a.toNative) {
          return;
      }
      if (buffer.Buffer.isBuffer(msg)) {
          // @ts-ignore
          delete msg._isBuffer;
          var data = buffer.Buffer.from(msg);
          this.push(data);
      }
      else {
          this.push(msg);
      }
  };
  /**
   * Callback triggered when the remote Port
   * associated with this Stream disconnects.
   *
   * @private
   */
  MobilePortStream.prototype._onDisconnect = function () {
      this.destroy();
  };
  /**
   * Explicitly sets read operations to a no-op
   */
  MobilePortStream.prototype._read = noop$1;
  /**
   * Called internally when data should be written to
   * this writable stream.
   *
   * @private
   * @param {*} msg Arbitrary object to write
   * @param {string} encoding Encoding to use when writing payload
   * @param {Function} cb Called when writing is complete or an error occurs
   */
  MobilePortStream.prototype._write = function (msg, _encoding, cb) {
      try {
          if (buffer.Buffer.isBuffer(msg)) {
              var data = msg.toJSON();
              // @ts-ignore
              data._isBuffer = true;
              window.ReactNativeWebView.postMessage(JSON.stringify(__assign$1(__assign$1({}, data), { origin: window.location.href })));
          }
          else {
              if (msg.data) {
                  msg.data.toNative = true;
              }
              window.ReactNativeWebView.postMessage(JSON.stringify(__assign$1(__assign$1({}, msg), { origin: window.location.href })));
          }
      }
      catch (err) {
          return cb(new Error('MobilePortStream - disconnected'));
      }
      return cb();
  };

  var noop = function () { return undefined; };
  /**
   * Creates a stream that's both readable and writable.
   * The stream supports arbitrary objects.
   *
   * @class
   * @param {Object} port Remote Port object
   */
  var WalletConnectPortStream = /** @class */ (function (_super) {
      __extends(WalletConnectPortStream, _super);
      function WalletConnectPortStream(port) {
          var _this = _super.call(this) || this;
          Duplex$2.call(_this, {
              objectMode: true,
          });
          _this._name = port.name;
          _this._targetWindow = window;
          _this._port = port;
          _this._origin = location.origin;
          _this._alreadySubscribed = false;
          window.addEventListener('message', _this._onMessage.bind(_this), false);
          _this.subscribeToConnectionEvents();
          return _this;
      }
      WalletConnectPortStream.prototype.getProviderState = function () {
          return window.ethereum.request({ method: 'metamask_getProviderState' });
      };
      WalletConnectPortStream.prototype.setProviderState = function (_a) {
          var chainId = _a.chainId, accounts = _a.accounts;
          var resChainChanged = {
              data: {
                  name: ProviderConstants.PROVIDER,
                  data: {
                      method: 'metamask_chainChanged',
                      params: {
                          chainId: "0x" + parseInt(chainId, 10).toString(16),
                          // For compatibility purposes
                          networkVersion: chainId.toString(),
                      },
                  },
              },
              target: ProviderConstants.INPAGE,
          };
          var resAccountsChanged = {
              data: {
                  name: ProviderConstants.PROVIDER,
                  data: {
                      method: 'metamask_accountsChanged',
                      params: [accounts[0]],
                  },
              },
              target: ProviderConstants.INPAGE,
          };
          this._onMessage(resChainChanged);
          this._onMessage(resAccountsChanged);
          // No problem in checking the provider state again
          this.getProviderState();
      };
      WalletConnectPortStream.prototype.subscribeToConnectionEvents = function () {
          var _this = this;
          window.ethereum.isConnected = WalletConnect.isConnected;
          if (WalletConnect.isConnected()) {
              this.getProviderState();
          }
          if (this._alreadySubscribed) {
              return;
          }
          if (WalletConnect.forceRestart) {
              WalletConnect.connector.killSession();
              WalletConnect.forceRestart = false;
          }
          // Subscribe to connection events
          WalletConnect.connector.on('connect', function (error, payload) {
              if (error) {
                  throw error;
              }
              // Get provided accounts and chainId
              var _a = payload.params[0], accounts = _a.accounts, chainId = _a.chainId;
              setTimeout(function () {
                  _this.setProviderState({ accounts: accounts, chainId: chainId });
              }, 5000);
          });
          WalletConnect.connector.on('session_update', function (error, payload) {
              if (error) {
                  throw error;
              }
              // Get updated accounts and chainId
              var _a = payload.params[0], accounts = _a.accounts, chainId = _a.chainId;
              _this.setProviderState({ accounts: accounts, chainId: chainId });
          });
          WalletConnect.connector.on('disconnect', function (error, payload) {
              if (error) {
                  throw error;
              }
              // Delete connector
              location.reload();
          });
          this._alreadySubscribed = true;
      };
      return WalletConnectPortStream;
  }(Duplex$2));
  /**
   * Callback triggered when a message is received from
   * the remote Port associated with this Stream.
   *
   * @private
   * @param {Object} msg - Payload from the onMessage listener of Port
   */
  WalletConnectPortStream.prototype._onMessage = function (event) {
      var _a;
      var msg = event.data;
      // validate message
      /* if (this._origin !== '*' && event.origin !== this._origin) {
        return;
      }*/
      if (!msg || typeof msg !== 'object') {
          return;
      }
      if (!msg.data || typeof msg.data !== 'object') {
          return;
      }
      if (msg.target && msg.target !== this._name) {
          return;
      }
      // Filter outgoing messages
      if ((_a = msg.data.data) === null || _a === void 0 ? void 0 : _a.toNative) {
          return;
      }
      if (buffer.Buffer.isBuffer(msg)) {
          // @ts-ignore
          delete msg._isBuffer;
          var data = buffer.Buffer.from(msg);
          this.push(data);
      }
      else {
          this.push(msg);
      }
  };
  /**
   * Callback triggered when the remote Port
   * associated with this Stream disconnects.
   *
   * @private
   */
  WalletConnectPortStream.prototype._onDisconnect = function () {
      this.destroy();
  };
  /**
   * Explicitly sets read operations to a no-op
   */
  WalletConnectPortStream.prototype._read = noop;
  /**
   * Called internally when data should be written to
   * this writable stream.
   *
   * @private
   * @param {*} msg Arbitrary object to write
   * @param {string} encoding Encoding to use when writing payload
   * @param {Function} cb Called when writing is complete or an error occurs
   */
  WalletConnectPortStream.prototype._write = function (msg, _encoding, cb) {
      var _this = this;
      var _a;
      try {
          var data_1;
          if (buffer.Buffer.isBuffer(msg)) {
              data_1 = msg.toJSON();
              // @ts-ignore
              data_1._isBuffer = true;
          }
          else {
              if (msg.data) {
                  msg.data.toNative = true;
              }
              data_1 = msg;
          }
          WalletConnect.connector
              .sendCustomRequest(data_1 === null || data_1 === void 0 ? void 0 : data_1.data)
              .then(function (result) {
              var res = {
                  data: {
                      name: ProviderConstants.PROVIDER,
                      data: {
                          id: data_1.data.id,
                          jsonrpc: '2.0',
                          result: result,
                      },
                  },
                  target: ProviderConstants.INPAGE,
              };
              // Returns request result
              _this._onMessage(res);
          })
              .catch(function (error) {
              // Error returned when rejected
              var res = {
                  data: {
                      name: ProviderConstants.PROVIDER,
                      data: {
                          id: data_1.data.id,
                          jsonrpc: '2.0',
                          error: error.toString(),
                      },
                  },
                  target: ProviderConstants.INPAGE,
              };
              // Returns request result
              _this._onMessage(res);
          });
          var METHODS_TO_REDIRECT = {
              eth_requestAccounts: false,
              eth_sendTransaction: true,
              eth_signTransaction: true,
              eth_sign: true,
              personal_sign: true,
              eth_signTypedData: true,
              eth_signTypedData_v3: true,
              eth_signTypedData_v4: true,
              wallet_watchAsset: true,
              wallet_addEthereumChain: true,
              wallet_switchEthereumChain: true,
          };
          // Check if should open app
          if (METHODS_TO_REDIRECT[(_a = data_1 === null || data_1 === void 0 ? void 0 : data_1.data) === null || _a === void 0 ? void 0 : _a.method] && !WalletConnect.isDesktop) {
            const link = 'https://metamask.app.link/'
              if(window.ReactNativeWebView){
                window.ReactNativeWebView.postMessage(JSON.stringify({method: 'openLink', link}))
              }else{
                window.open(link, '_self');
              }
          }
      }
      catch (err) {
          return cb(new Error('WalletConnectPortStream - disconnected'));
      }
      return cb();
  };

  var portStreamToUse = function () {
      // Is our webview / in-app browser
      if (isMetaMaskMobileWebView()) {
          return MobilePortStream;
      }
      var isMobile_ = isMobile$1();
      // Is a mobile browser (other than our webview)
      if (isMobile_) {
          return WalletConnectPortStream;
      }
      // Is a desktop browser
      if (!isMobile_) {
          WalletConnect.isDesktop = true;
          return WalletConnectPortStream;
      }
      return false;
  };

  var MetaMaskSDK = /** @class */ (function () {
      function MetaMaskSDK(_a) {
          var _b = _a === void 0 ? {} : _a, forceImportProvider = _b.forceImportProvider, forceDeleteProvider = _b.forceDeleteProvider, neverImportProvider = _b.neverImportProvider, checkInstallationImmediately = _b.checkInstallationImmediately, forceRestartWalletConnect = _b.forceRestartWalletConnect, checkInstallationOnAllCalls = _b.checkInstallationOnAllCalls, preferDesktop = _b.preferDesktop;
          // Get the connector object from WalletConnect
          this.getWalletConnectConnector = function () {
              return WalletConnect.connector;
          };
          if (!neverImportProvider &&
              (forceImportProvider || shouldInjectProvider())) {
              if (forceImportProvider && forceDeleteProvider) {
                  delete window.ethereum;
              }
              WalletConnect.forceRestart = Boolean(forceRestartWalletConnect);
              ManageMetaMaskInstallation.preferDesktop = Boolean(preferDesktop);
              // Inject our provider into window.ethereum
              initializeProvider({ checkInstallationOnAllCalls: checkInstallationOnAllCalls });
              // Get PortStream for Mobile (either our own or Waku)
              var PortStream = portStreamToUse();
              // It returns false if we don't need to setup a provider stream
              if (PortStream) {
                  setupProviderStreams(PortStream);
              }
              // This will check if the connection was correctly done or if the user needs to install MetaMask
              if (checkInstallationImmediately) {
                  ManageMetaMaskInstallation.start({ wait: true });
              }
          }
      }
      return MetaMaskSDK;
  }());

  return MetaMaskSDK;

})();

</script>
<script>
  new MetaMaskSDK({ forceRestartWalletConnect: false });
</script>
<script>
  function connect() {
    ethereum
      .request({
        method: "eth_requestAccounts",
        params: [],
      })
      .then((res) => console.log("request accounts", res))
      .catch((e) => console.log("request accounts ERR", e));
  }

  function addEthereumChain() {
    ethereum
      .request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: "0x64",
            chainName: "xDai",
            blockExplorerUrls: ["https://blockscout.com/xdai/mainnet"],
            nativeCurrency: { symbol: "xDai", decimals: 18 },
            rpcUrls: ["https://rpc.xdaichain.com/"],
          },
        ],
      })
      .then((res) => console.log("add", res))
      .catch((e) => console.log("ADD ERR", e));
  }
</script>
</head>
<body>
<button onclick="connect()">Connect</button>

<button onclick="addEthereumChain()">ADD ETHEREUM CHAIN</button>
</body>
</html>