function ue(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Me(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Ct(t,...n){if(!Me(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error("Uint8Array expected of length "+n+", got length="+t.length)}function Pe(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ue(t.outputLen),ue(t.blockLen)}function Lt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function je(t,n){Ct(t);const e=n.outputLen;if(t.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}const wt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Kt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),$=(t,n)=>t<<32-n|t>>>n;function Ke(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function re(t){return typeof t=="string"&&(t=Ke(t)),Ct(t),t}function De(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];Ct(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}class Ee{clone(){return this._cloneInto()}}function Ye(t){const n=r=>t().update(re(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Be(t=32){if(wt&&typeof wt.getRandomValues=="function")return wt.getRandomValues(new Uint8Array(t));if(wt&&typeof wt.randomBytes=="function")return wt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function Ge(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),i=BigInt(4294967295),c=Number(e>>o&i),f=Number(e&i),s=r?4:0,u=r?0:4;t.setUint32(n+s,c,r),t.setUint32(n+u,f,r)}const $e=(t,n,e)=>t&n^~t&e,We=(t,n,e)=>t&n^t&e^n&e;class Xe extends Ee{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Kt(this.buffer)}update(n){Lt(this);const{view:e,buffer:r,blockLen:o}=this;n=re(n);const i=n.length;for(let c=0;c<i;){const f=Math.min(o-this.pos,i-c);if(f===o){const s=Kt(n);for(;o<=i-c;c+=o)this.process(s,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Lt(this),je(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let l=c;l<o;l++)e[l]=0;Ge(r,o-8,BigInt(this.length*8),i),this.process(r,0);const f=Kt(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=s/4,g=this.get();if(u>g.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)f.setUint32(4*l,g[l],i)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:i,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=i,n.destroyed=c,o%e&&n.buffer.set(r),n}}const Qe=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64);class Je extends Xe{constructor(){super(64,32,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:n,B:e,C:r,D:o,E:i,F:c,G:f,H:s}=this;return[n,e,r,o,i,c,f,s]}set(n,e,r,o,i,c,f,s){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=c|0,this.G=f|0,this.H=s|0}process(n,e){for(let l=0;l<16;l++,e+=4)nt[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const d=nt[l-15],w=nt[l-2],B=$(d,7)^$(d,18)^d>>>3,y=$(w,17)^$(w,19)^w>>>10;nt[l]=y+nt[l-7]+B+nt[l-16]|0}let{A:r,B:o,C:i,D:c,E:f,F:s,G:u,H:g}=this;for(let l=0;l<64;l++){const d=$(f,6)^$(f,11)^$(f,25),w=g+d+$e(f,s,u)+Qe[l]+nt[l]|0,y=($(r,2)^$(r,13)^$(r,22))+We(r,o,i)|0;g=u,u=s,s=f,f=c+w|0,c=i,i=o,o=r,r=w+y|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,c=c+this.D|0,f=f+this.E|0,s=s+this.F|0,u=u+this.G|0,g=g+this.H|0,this.set(r,o,i,c,f,s,u,g)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ut=Ye(()=>new Je);class ve extends Ee{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Pe(n);const r=re(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return Lt(this),this.iHash.update(n),this}digestInto(n){Lt(this),Ct(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:c,outputLen:f}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Se=(t,n,e)=>new ve(t,n).update(e).digest();Se.create=(t,n)=>new ve(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt(0),Zt=BigInt(1),Fe=BigInt(2);function lt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function X(t){if(!lt(t))throw new Error("Uint8Array expected")}function yt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}const tn=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function pt(t){X(t);let n="";for(let e=0;e<t.length;e++)n+=tn[t[e]];return n}function bt(t){const n=t.toString(16);return n.length&1?"0"+n:n}function oe(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Vt:BigInt("0x"+t)}const J={_0:48,_9:57,A:65,F:70,a:97,f:102};function le(t){if(t>=J._0&&t<=J._9)return t-J._0;if(t>=J.A&&t<=J.F)return t-(J.A-10);if(t>=J.a&&t<=J.f)return t-(J.a-10)}function xt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){const c=le(t.charCodeAt(i)),f=le(t.charCodeAt(i+1));if(c===void 0||f===void 0){const s=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=c*16+f}return r}function W(t){return oe(pt(t))}function ie(t){return X(t),oe(pt(Uint8Array.from(t).reverse()))}function st(t,n){return xt(t.toString(16).padStart(n*2,"0"))}function se(t,n){return st(t,n).reverse()}function en(t){return xt(bt(t))}function Z(t,n,e){let r;if(typeof n=="string")try{r=xt(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(lt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function K(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];X(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}function nn(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function zt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Dt=t=>typeof t=="bigint"&&Vt<=t;function Et(t,n,e){return Dt(t)&&Dt(n)&&Dt(e)&&n<=t&&t<e}function it(t,n,e,r){if(!Et(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function Ae(t){let n;for(n=0;t>Vt;t>>=Zt,n+=1);return n}function rn(t,n){return t>>BigInt(n)&Zt}function on(t,n,e){return t|(e?Zt:Vt)<<BigInt(n)}const ce=t=>(Fe<<BigInt(t-1))-Zt,Yt=t=>new Uint8Array(t),de=t=>Uint8Array.from(t);function Ie(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Yt(t),o=Yt(t),i=0;const c=()=>{r.fill(1),o.fill(0),i=0},f=(...l)=>e(o,r,...l),s=(l=Yt())=>{o=f(de([0]),l),r=f(),l.length!==0&&(o=f(de([1]),l),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const d=[];for(;l<n;){r=f();const w=r.slice();d.push(w),l+=r.length}return K(...d)};return(l,d)=>{c(),s(l);let w;for(;!(w=d(u()));)s();return c(),w}}const sn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||lt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Bt(t,n,e={}){const r=(o,i,c)=>{const f=sn[i];if(typeof f!="function")throw new Error("invalid validator function");const s=t[o];if(!(c&&s===void 0)&&!f(s,t))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+s)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const cn=()=>{throw new Error("not implemented")};function Jt(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(o!==void 0)return o;const i=t(e,...r);return n.set(e,i),i}}const fn=Object.freeze(Object.defineProperty({__proto__:null,aInRange:it,abool:yt,abytes:X,bitGet:rn,bitLen:Ae,bitMask:ce,bitSet:on,bytesToHex:pt,bytesToNumberBE:W,bytesToNumberLE:ie,concatBytes:K,createHmacDrbg:Ie,ensureBytes:Z,equalBytes:nn,hexToBytes:xt,hexToNumber:oe,inRange:Et,isBytes:lt,memoized:Jt,notImplemented:cn,numberToBytesBE:st,numberToBytesLE:se,numberToHexUnpadded:bt,numberToVarBytesBE:en,utf8ToBytes:zt,validateObject:Bt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),H=BigInt(1),ut=BigInt(2),an=BigInt(3),Ft=BigInt(4),he=BigInt(5),ge=BigInt(8);function k(t,n){const e=t%n;return e>=C?e:n+e}function un(t,n,e){if(n<C)throw new Error("invalid exponent, negatives unsupported");if(e<=C)throw new Error("invalid modulus");if(e===H)return C;let r=H;for(;n>C;)n&H&&(r=r*t%e),t=t*t%e,n>>=H;return r}function D(t,n,e){let r=t;for(;n-- >C;)r*=r,r%=e;return r}function te(t,n){if(t===C)throw new Error("invert: expected non-zero number");if(n<=C)throw new Error("invert: expected positive modulus, got "+n);let e=k(t,n),r=n,o=C,i=H;for(;e!==C;){const f=r/e,s=r%e,u=o-i*f;r=e,e=s,o=i,i=u}if(r!==H)throw new Error("invert: does not exist");return k(o,n)}function ln(t){const n=(t-H)/ut;let e,r,o;for(e=t-H,r=0;e%ut===C;e/=ut,r++);for(o=ut;o<t&&un(o,n,t)!==t-H;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(t+H)/Ft;return function(s,u){const g=s.pow(u,c);if(!s.eql(s.sqr(g),u))throw new Error("Cannot find square root");return g}}const i=(e+H)/ut;return function(f,s){if(f.pow(s,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let u=r,g=f.pow(f.mul(f.ONE,o),e),l=f.pow(s,i),d=f.pow(s,e);for(;!f.eql(d,f.ONE);){if(f.eql(d,f.ZERO))return f.ZERO;let w=1;for(let y=f.sqr(d);w<u&&!f.eql(y,f.ONE);w++)y=f.sqr(y);const B=f.pow(g,H<<BigInt(u-w-1));g=f.sqr(B),l=f.mul(l,B),d=f.mul(d,g),u=w}return l}}function dn(t){if(t%Ft===an){const n=(t+H)/Ft;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%ge===he){const n=(t-he)/ge;return function(r,o){const i=r.mul(o,ut),c=r.pow(i,n),f=r.mul(o,c),s=r.mul(r.mul(f,ut),c),u=r.mul(f,r.sub(s,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return ln(t)}const hn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function _e(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=hn.reduce((r,o)=>(r[o]="function",r),n);return Bt(t,e)}function gn(t,n,e){if(e<C)throw new Error("invalid exponent, negatives unsupported");if(e===C)return t.ONE;if(e===H)return n;let r=t.ONE,o=n;for(;e>C;)e&H&&(r=t.mul(r,o)),o=t.sqr(o),e>>=H;return r}function wn(t,n){const e=new Array(n.length),r=n.reduce((i,c,f)=>t.is0(c)?i:(e[f]=i,t.mul(i,c)),t.ONE),o=t.inv(r);return n.reduceRight((i,c,f)=>t.is0(c)?i:(e[f]=t.mul(i,e[f]),t.mul(i,c)),o),e}function Oe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function qe(t,n,e=!1,r={}){if(t<=C)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=Oe(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:ce(o),ZERO:C,ONE:H,create:s=>k(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return C<=s&&s<t},is0:s=>s===C,isOdd:s=>(s&H)===H,neg:s=>k(-s,t),eql:(s,u)=>s===u,sqr:s=>k(s*s,t),add:(s,u)=>k(s+u,t),sub:(s,u)=>k(s-u,t),mul:(s,u)=>k(s*u,t),pow:(s,u)=>gn(f,s,u),div:(s,u)=>k(s*te(u,t),t),sqrN:s=>s*s,addN:(s,u)=>s+u,subN:(s,u)=>s-u,mulN:(s,u)=>s*u,inv:s=>te(s,t),sqrt:r.sqrt||(s=>(c||(c=dn(t)),c(f,s))),invertBatch:s=>wn(f,s),cmov:(s,u,g)=>g?u:s,toBytes:s=>e?se(s,i):st(s,i),fromBytes:s=>{if(s.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+s.length);return e?ie(s):W(s)}});return Object.freeze(f)}function Ne(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Le(t){const n=Ne(t);return n+Math.ceil(n/2)}function bn(t,n,e=!1){const r=t.length,o=Ne(n),i=Le(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const c=e?W(t):ie(t),f=k(c,n-H)+H;return e?se(f,o):st(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const we=BigInt(0),Nt=BigInt(1);function Gt(t,n){const e=n.negate();return t?e:n}function Ue(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function $t(t,n){Ue(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1);return{windows:e,windowSize:r}}function mn(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function yn(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Wt=new WeakMap,Te=new WeakMap;function Xt(t){return Te.get(t)||1}function pn(t,n){return{constTimeNegate:Gt,hasPrecomputes(e){return Xt(e)!==1},unsafeLadder(e,r,o=t.ZERO){let i=e;for(;r>we;)r&Nt&&(o=o.add(i)),i=i.double(),r>>=Nt;return o},precomputeWindow(e,r){const{windows:o,windowSize:i}=$t(r,n),c=[];let f=e,s=f;for(let u=0;u<o;u++){s=f,c.push(s);for(let g=1;g<i;g++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(e,r,o){const{windows:i,windowSize:c}=$t(e,n);let f=t.ZERO,s=t.BASE;const u=BigInt(2**e-1),g=2**e,l=BigInt(e);for(let d=0;d<i;d++){const w=d*c;let B=Number(o&u);o>>=l,B>c&&(B-=g,o+=Nt);const y=w,a=w+Math.abs(B)-1,h=d%2!==0,b=B<0;B===0?s=s.add(Gt(h,r[y])):f=f.add(Gt(b,r[a]))}return{p:f,f:s}},wNAFUnsafe(e,r,o,i=t.ZERO){const{windows:c,windowSize:f}=$t(e,n),s=BigInt(2**e-1),u=2**e,g=BigInt(e);for(let l=0;l<c;l++){const d=l*f;if(o===we)break;let w=Number(o&s);if(o>>=g,w>f&&(w-=u,o+=Nt),w===0)continue;let B=r[d+Math.abs(w)-1];w<0&&(B=B.negate()),i=i.add(B)}return i},getPrecomputes(e,r,o){let i=Wt.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&Wt.set(r,o(i))),i},wNAFCached(e,r,o){const i=Xt(e);return this.wNAF(i,this.getPrecomputes(i,e,o),r)},wNAFCachedUnsafe(e,r,o,i){const c=Xt(e);return c===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,i)},setWindowSize(e,r){Ue(r,n),Te.set(e,r),Wt.delete(e)}}}function xn(t,n,e,r){if(mn(e,t),yn(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=Ae(BigInt(e.length)),c=i>12?i-3:i>4?i-2:i?2:1,f=(1<<c)-1,s=new Array(f+1).fill(o),u=Math.floor((n.BITS-1)/c)*c;let g=o;for(let l=u;l>=0;l-=c){s.fill(o);for(let w=0;w<r.length;w++){const B=r[w],y=Number(B>>BigInt(l)&BigInt(f));s[y]=s[y].add(e[w])}let d=o;for(let w=s.length-1,B=o;w>0;w--)B=B.add(s[w]),d=d.add(B);if(g=g.add(d),l!==0)for(let w=0;w<c;w++)g=g.double()}return g}function He(t){return _e(t.Fp),Bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function be(t){t.lowS!==void 0&&yt("lowS",t.lowS),t.prehash!==void 0&&yt("prehash",t.prehash)}function En(t){const n=He(t);Bt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Bn,hexToBytes:vn}=fn,F={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(t,n)=>{const{Err:e}=F;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=bt(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?bt(o.length/2|128):"";return bt(t)+i+o+n},decode(t,n){const{Err:e}=F;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++],i=!!(o&128);let c=0;if(!i)c=o;else{const s=o&127;if(!s)throw new e("tlv.decode(long): indefinite length not supported");if(s>4)throw new e("tlv.decode(long): byte length is too big");const u=n.subarray(r,r+s);if(u.length!==s)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const g of u)c=c<<8|g;if(r+=s,c<128)throw new e("tlv.decode(long): not minimal encoding")}const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=F;if(t<G)throw new n("integer: negative integers are not allowed");let e=bt(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=F;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return Bn(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=F,o=typeof t=="string"?vn(t):t;X(o);const{v:i,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:s}=r.decode(2,i),{v:u,l:g}=r.decode(2,s);if(g.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(u)}},hexFromSig(t){const{_tlv:n,_int:e}=F,r=n.encode(2,e.encode(t.r)),o=n.encode(2,e.encode(t.s)),i=r+o;return n.encode(48,i)}},G=BigInt(0),U=BigInt(1),rt=BigInt(2),Tt=BigInt(3),me=BigInt(4);function Sn(t){const n=En(t),{Fp:e}=n,r=qe(n.n,n.nBitLength),o=n.toBytes||((y,a,h)=>{const b=a.toAffine();return K(Uint8Array.from([4]),e.toBytes(b.x),e.toBytes(b.y))}),i=n.fromBytes||(y=>{const a=y.subarray(1),h=e.fromBytes(a.subarray(0,e.BYTES)),b=e.fromBytes(a.subarray(e.BYTES,2*e.BYTES));return{x:h,y:b}});function c(y){const{a,b:h}=n,b=e.sqr(y),p=e.mul(b,y);return e.add(e.add(p,e.mul(y,a)),h)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(y){return Et(y,U,n.n)}function s(y){const{allowedPrivateKeyLengths:a,nByteLength:h,wrapPrivateKey:b,n:p}=n;if(a&&typeof y!="bigint"){if(lt(y)&&(y=pt(y)),typeof y!="string"||!a.includes(y.length))throw new Error("invalid private key");y=y.padStart(h*2,"0")}let v;try{v=typeof y=="bigint"?y:W(Z("private key",y,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof y)}return b&&(v=k(v,p)),it("private key",v,U,p),v}function u(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}const g=Jt((y,a)=>{const{px:h,py:b,pz:p}=y;if(e.eql(p,e.ONE))return{x:h,y:b};const v=y.is0();a==null&&(a=v?e.ONE:e.inv(p));const q=e.mul(h,a),_=e.mul(b,a),S=e.mul(p,a);if(v)return{x:e.ZERO,y:e.ZERO};if(!e.eql(S,e.ONE))throw new Error("invZ was invalid");return{x:q,y:_}}),l=Jt(y=>{if(y.is0()){if(n.allowInfinityPoint&&!e.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:a,y:h}=y.toAffine();if(!e.isValid(a)||!e.isValid(h))throw new Error("bad point: x or y not FE");const b=e.sqr(h),p=c(a);if(!e.eql(b,p))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(a,h,b){if(this.px=a,this.py=h,this.pz=b,a==null||!e.isValid(a))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(b==null||!e.isValid(b))throw new Error("z required");Object.freeze(this)}static fromAffine(a){const{x:h,y:b}=a||{};if(!a||!e.isValid(h)||!e.isValid(b))throw new Error("invalid affine point");if(a instanceof d)throw new Error("projective point not allowed");const p=v=>e.eql(v,e.ZERO);return p(h)&&p(b)?d.ZERO:new d(h,b,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const h=e.invertBatch(a.map(b=>b.pz));return a.map((b,p)=>b.toAffine(h[p])).map(d.fromAffine)}static fromHex(a){const h=d.fromAffine(i(Z("pointHex",a)));return h.assertValidity(),h}static fromPrivateKey(a){return d.BASE.multiply(s(a))}static msm(a,h){return xn(d,r,a,h)}_setWindowSize(a){B.setWindowSize(this,a)}assertValidity(){l(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw new Error("Field doesn't support isOdd")}equals(a){u(a);const{px:h,py:b,pz:p}=this,{px:v,py:q,pz:_}=a,S=e.eql(e.mul(h,_),e.mul(v,p)),I=e.eql(e.mul(b,_),e.mul(q,p));return S&&I}negate(){return new d(this.px,e.neg(this.py),this.pz)}double(){const{a,b:h}=n,b=e.mul(h,Tt),{px:p,py:v,pz:q}=this;let _=e.ZERO,S=e.ZERO,I=e.ZERO,A=e.mul(p,p),V=e.mul(v,v),T=e.mul(q,q),L=e.mul(p,v);return L=e.add(L,L),I=e.mul(p,q),I=e.add(I,I),_=e.mul(a,I),S=e.mul(b,T),S=e.add(_,S),_=e.sub(V,S),S=e.add(V,S),S=e.mul(_,S),_=e.mul(L,_),I=e.mul(b,I),T=e.mul(a,T),L=e.sub(A,T),L=e.mul(a,L),L=e.add(L,I),I=e.add(A,A),A=e.add(I,A),A=e.add(A,T),A=e.mul(A,L),S=e.add(S,A),T=e.mul(v,q),T=e.add(T,T),A=e.mul(T,L),_=e.sub(_,A),I=e.mul(T,V),I=e.add(I,I),I=e.add(I,I),new d(_,S,I)}add(a){u(a);const{px:h,py:b,pz:p}=this,{px:v,py:q,pz:_}=a;let S=e.ZERO,I=e.ZERO,A=e.ZERO;const V=n.a,T=e.mul(n.b,Tt);let L=e.mul(h,v),j=e.mul(b,q),m=e.mul(p,_),x=e.add(h,b),E=e.add(v,q);x=e.mul(x,E),E=e.add(L,j),x=e.sub(x,E),E=e.add(h,p);let O=e.add(v,_);return E=e.mul(E,O),O=e.add(L,m),E=e.sub(E,O),O=e.add(b,p),S=e.add(q,_),O=e.mul(O,S),S=e.add(j,m),O=e.sub(O,S),A=e.mul(V,E),S=e.mul(T,m),A=e.add(S,A),S=e.sub(j,A),A=e.add(j,A),I=e.mul(S,A),j=e.add(L,L),j=e.add(j,L),m=e.mul(V,m),E=e.mul(T,E),j=e.add(j,m),m=e.sub(L,m),m=e.mul(V,m),E=e.add(E,m),L=e.mul(j,E),I=e.add(I,L),L=e.mul(O,E),S=e.mul(x,S),S=e.sub(S,L),L=e.mul(x,j),A=e.mul(O,A),A=e.add(A,L),new d(S,I,A)}subtract(a){return this.add(a.negate())}is0(){return this.equals(d.ZERO)}wNAF(a){return B.wNAFCached(this,a,d.normalizeZ)}multiplyUnsafe(a){const{endo:h,n:b}=n;it("scalar",a,G,b);const p=d.ZERO;if(a===G)return p;if(this.is0()||a===U)return this;if(!h||B.hasPrecomputes(this))return B.wNAFCachedUnsafe(this,a,d.normalizeZ);let{k1neg:v,k1:q,k2neg:_,k2:S}=h.splitScalar(a),I=p,A=p,V=this;for(;q>G||S>G;)q&U&&(I=I.add(V)),S&U&&(A=A.add(V)),V=V.double(),q>>=U,S>>=U;return v&&(I=I.negate()),_&&(A=A.negate()),A=new d(e.mul(A.px,h.beta),A.py,A.pz),I.add(A)}multiply(a){const{endo:h,n:b}=n;it("scalar",a,U,b);let p,v;if(h){const{k1neg:q,k1:_,k2neg:S,k2:I}=h.splitScalar(a);let{p:A,f:V}=this.wNAF(_),{p:T,f:L}=this.wNAF(I);A=B.constTimeNegate(q,A),T=B.constTimeNegate(S,T),T=new d(e.mul(T.px,h.beta),T.py,T.pz),p=A.add(T),v=V.add(L)}else{const{p:q,f:_}=this.wNAF(a);p=q,v=_}return d.normalizeZ([p,v])[0]}multiplyAndAddUnsafe(a,h,b){const p=d.BASE,v=(_,S)=>S===G||S===U||!_.equals(p)?_.multiplyUnsafe(S):_.multiply(S),q=v(this,h).add(v(a,b));return q.is0()?void 0:q}toAffine(a){return g(this,a)}isTorsionFree(){const{h:a,isTorsionFree:h}=n;if(a===U)return!0;if(h)return h(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:h}=n;return a===U?this:h?h(d,this):this.multiplyUnsafe(n.h)}toRawBytes(a=!0){return yt("isCompressed",a),this.assertValidity(),o(d,this,a)}toHex(a=!0){return yt("isCompressed",a),pt(this.toRawBytes(a))}}d.BASE=new d(n.Gx,n.Gy,e.ONE),d.ZERO=new d(e.ZERO,e.ONE,e.ZERO);const w=n.nBitLength,B=pn(d,n.endo?Math.ceil(w/2):w);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:f}}function An(t){const n=He(t);return Bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function In(t){const n=An(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function c(m){return k(m,r)}function f(m){return te(m,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:u,weierstrassEquation:g,isWithinCurveOrder:l}=Sn({...n,toBytes(m,x,E){const O=x.toAffine(),N=e.toBytes(O.x),R=K;return yt("isCompressed",E),E?R(Uint8Array.from([x.hasEvenY()?2:3]),N):R(Uint8Array.from([4]),N,e.toBytes(O.y))},fromBytes(m){const x=m.length,E=m[0],O=m.subarray(1);if(x===o&&(E===2||E===3)){const N=W(O);if(!Et(N,U,e.ORDER))throw new Error("Point is not on curve");const R=g(N);let M;try{M=e.sqrt(R)}catch(Y){const P=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+P)}const z=(M&U)===U;return(E&1)===1!==z&&(M=e.neg(M)),{x:N,y:M}}else if(x===i&&E===4){const N=e.fromBytes(O.subarray(0,e.BYTES)),R=e.fromBytes(O.subarray(e.BYTES,2*e.BYTES));return{x:N,y:R}}else{const N=o,R=i;throw new Error("invalid Point, expected length of "+N+", or uncompressed "+R+", got "+x)}}}),d=m=>pt(st(m,n.nByteLength));function w(m){const x=r>>U;return m>x}function B(m){return w(m)?c(-m):m}const y=(m,x,E)=>W(m.slice(x,E));class a{constructor(x,E,O){this.r=x,this.s=E,this.recovery=O,this.assertValidity()}static fromCompact(x){const E=n.nByteLength;return x=Z("compactSignature",x,E*2),new a(y(x,0,E),y(x,E,2*E))}static fromDER(x){const{r:E,s:O}=F.toSig(Z("DER",x));return new a(E,O)}assertValidity(){it("r",this.r,U,r),it("s",this.s,U,r)}addRecoveryBit(x){return new a(this.r,this.s,x)}recoverPublicKey(x){const{r:E,s:O,recovery:N}=this,R=_(Z("msgHash",x));if(N==null||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const M=N===2||N===3?E+n.n:E;if(M>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=N&1?"03":"02",Q=s.fromHex(z+d(M)),Y=f(M),P=c(-R*Y),dt=c(O*Y),tt=s.BASE.multiplyAndAddUnsafe(Q,P,dt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return xt(this.toDERHex())}toDERHex(){return F.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return xt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const h={isValidPrivateKey(m){try{return u(m),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const m=Le(n.n);return bn(n.randomBytes(m),n.n)},precompute(m=8,x=s.BASE){return x._setWindowSize(m),x.multiply(BigInt(3)),x}};function b(m,x=!0){return s.fromPrivateKey(m).toRawBytes(x)}function p(m){const x=lt(m),E=typeof m=="string",O=(x||E)&&m.length;return x?O===o||O===i:E?O===2*o||O===2*i:m instanceof s}function v(m,x,E=!0){if(p(m))throw new Error("first arg must be private key");if(!p(x))throw new Error("second arg must be public key");return s.fromHex(x).multiply(u(m)).toRawBytes(E)}const q=n.bits2int||function(m){if(m.length>8192)throw new Error("input is too large");const x=W(m),E=m.length*8-n.nBitLength;return E>0?x>>BigInt(E):x},_=n.bits2int_modN||function(m){return c(q(m))},S=ce(n.nBitLength);function I(m){return it("num < 2^"+n.nBitLength,m,G,S),st(m,n.nByteLength)}function A(m,x,E=V){if(["recovered","canonical"].some(ft=>ft in E))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:N}=n;let{lowS:R,prehash:M,extraEntropy:z}=E;R==null&&(R=!0),m=Z("msgHash",m),be(E),M&&(m=Z("prehashed msgHash",O(m)));const Q=_(m),Y=u(x),P=[I(Y),I(Q)];if(z!=null&&z!==!1){const ft=z===!0?N(e.BYTES):z;P.push(Z("extraEntropy",ft))}const dt=K(...P),tt=Q;function Pt(ft){const ht=q(ft);if(!l(ht))return;const jt=f(ht),vt=s.BASE.multiply(ht).toAffine(),at=c(vt.x);if(at===G)return;const St=c(jt*c(tt+at*Y));if(St===G)return;let At=(vt.x===at?0:2)|Number(vt.y&U),gt=St;return R&&w(St)&&(gt=B(St),At^=1),new a(at,gt,At)}return{seed:dt,k2sig:Pt}}const V={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function L(m,x,E=V){const{seed:O,k2sig:N}=A(m,x,E),R=n;return Ie(R.hash.outputLen,R.nByteLength,R.hmac)(O,N)}s.BASE._setWindowSize(8);function j(m,x,E,O=T){var At;const N=m;x=Z("msgHash",x),E=Z("publicKey",E);const{lowS:R,prehash:M,format:z}=O;if(be(O),"strict"in O)throw new Error("options.strict was renamed to lowS");if(z!==void 0&&z!=="compact"&&z!=="der")throw new Error("format must be compact or der");const Q=typeof N=="string"||lt(N),Y=!Q&&!z&&typeof N=="object"&&N!==null&&typeof N.r=="bigint"&&typeof N.s=="bigint";if(!Q&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let P,dt;try{if(Y&&(P=new a(N.r,N.s)),Q){try{z!=="compact"&&(P=a.fromDER(N))}catch(gt){if(!(gt instanceof F.Err))throw gt}!P&&z!=="der"&&(P=a.fromCompact(N))}dt=s.fromHex(E)}catch{return!1}if(!P||R&&P.hasHighS())return!1;M&&(x=n.hash(x));const{r:tt,s:Pt}=P,ft=_(x),ht=f(Pt),jt=c(ft*ht),vt=c(tt*ht),at=(At=s.BASE.multiplyAndAddUnsafe(dt,jt,vt))==null?void 0:At.toAffine();return at?c(at.x)===tt:!1}return{CURVE:n,getPublicKey:b,getSharedSecret:v,sign:L,verify:j,ProjectivePoint:s,Signature:a,utils:h}}function _n(t,n){const e=t.ORDER;let r=G;for(let B=e-U;B%rt===G;B/=rt)r+=U;const o=r,i=rt<<o-U-U,c=i*rt,f=(e-U)/c,s=(f-U)/rt,u=c-U,g=i,l=t.pow(n,f),d=t.pow(n,(f+U)/rt);let w=(B,y)=>{let a=l,h=t.pow(y,u),b=t.sqr(h);b=t.mul(b,y);let p=t.mul(B,b);p=t.pow(p,s),p=t.mul(p,h),h=t.mul(p,y),b=t.mul(p,B);let v=t.mul(b,h);p=t.pow(v,g);let q=t.eql(p,t.ONE);h=t.mul(b,d),p=t.mul(v,a),b=t.cmov(h,b,q),v=t.cmov(p,v,q);for(let _=o;_>U;_--){let S=_-rt;S=rt<<S-U;let I=t.pow(v,S);const A=t.eql(I,t.ONE);h=t.mul(b,a),a=t.mul(a,a),I=t.mul(v,a),b=t.cmov(h,b,A),v=t.cmov(I,v,A)}return{isValid:q,value:b}};if(t.ORDER%me===Tt){const B=(t.ORDER-Tt)/me,y=t.sqrt(t.neg(n));w=(a,h)=>{let b=t.sqr(h);const p=t.mul(a,h);b=t.mul(b,p);let v=t.pow(b,B);v=t.mul(v,p);const q=t.mul(v,y),_=t.mul(t.sqr(v),h),S=t.eql(_,a);let I=t.cmov(q,v,S);return{isValid:S,value:I}}}return w}function On(t,n){if(_e(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=_n(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,c,f,s,u,g,l;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),c=t.add(i,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),f=t.mul(f,n.A),i=t.sqr(c),u=t.sqr(f),s=t.mul(u,n.A),i=t.add(i,s),i=t.mul(i,c),u=t.mul(u,f),s=t.mul(u,n.B),i=t.add(i,s),g=t.mul(o,c);const{isValid:d,value:w}=e(i,u);l=t.mul(o,r),l=t.mul(l,w),g=t.cmov(g,c,d),l=t.cmov(l,w,d);const B=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,B),g=t.div(g,f),{x:g,y:l}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function qn(t){return{hash:t,hmac:(n,...e)=>Se(t,n,De(...e)),randomBytes:Be}}function Nn(t,n){const e=r=>In({...t,...qn(r)});return Object.freeze({...e(n),create:e})}const Ln=W;function ot(t,n){if(It(t),It(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Un(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function It(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Tn(t,n,e,r){X(t),X(n),It(e),n.length>255&&(n=r(K(zt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,c=Math.ceil(e/o);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=K(n,ot(n.length,1)),s=ot(0,i),u=ot(e,2),g=new Array(c),l=r(K(s,t,u,ot(0,1),f));g[0]=r(K(l,ot(1,1),f));for(let w=1;w<=c;w++){const B=[Un(l,g[w-1]),ot(w+1,1),f];g[w]=r(K(...B))}return K(...g).slice(0,e)}function Hn(t,n,e,r,o){if(X(t),X(n),It(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(zt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(ot(e,2)).update(n).update(ot(n.length,1)).digest()}function ye(t,n,e){Bt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:c,expand:f,DST:s}=e;X(t),It(n);const u=typeof s=="string"?zt(s):s,g=r.toString(2).length,l=Math.ceil((g+o)/8),d=n*i*l;let w;if(f==="xmd")w=Tn(t,u,d,c);else if(f==="xof")w=Hn(t,u,d,o,c);else if(f==="_internal_pass")w=t;else throw new Error('expand must be "xmd" or "xof"');const B=new Array(n);for(let y=0;y<n;y++){const a=new Array(i);for(let h=0;h<i;h++){const b=l*(h+y*i),p=w.subarray(b,b+l);a[h]=k(Ln(p),r)}B[y]=a}return B}function Rn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[i,c,f,s]=e.map(u=>u.reduce((g,l)=>t.add(t.mul(g,r),l)));return r=t.div(i,c),o=t.mul(o,t.div(f,s)),{x:r,y:o}}}function kn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=ye(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(i[0])),f=t.fromAffine(n(i[1])),s=c.add(f).clearCofactor();return s.assertValidity(),s},encodeToCurve(r,o){const i=ye(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(i[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const i of r)if(typeof i!="bigint")throw new Error("mapToCurve: expected array of bigints");const o=t.fromAffine(n(r)).clearCofactor();return o.assertValidity(),o}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ht=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_t=BigInt(1),Rt=BigInt(2),pe=(t,n)=>(t+n/Rt)/n;function Re(t){const n=qt,e=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),c=BigInt(23),f=BigInt(44),s=BigInt(88),u=t*t*t%n,g=u*u*t%n,l=D(g,e,n)*g%n,d=D(l,e,n)*g%n,w=D(d,Rt,n)*u%n,B=D(w,o,n)*w%n,y=D(B,i,n)*B%n,a=D(y,f,n)*y%n,h=D(a,s,n)*a%n,b=D(h,f,n)*y%n,p=D(b,e,n)*g%n,v=D(p,c,n)*B%n,q=D(v,r,n)*u%n,_=D(q,Rt,n);if(!ct.eql(ct.sqr(_),t))throw new Error("Cannot find square root");return _}const ct=qe(qt,void 0,void 0,{sqrt:Re}),Mt=Nn({a:BigInt(0),b:BigInt(7),Fp:ct,n:Ht,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Ht,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_t*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,c=BigInt("0x100000000000000000000000000000000"),f=pe(i*t,n),s=pe(-r*t,n);let u=k(t-f*e-s*o,n),g=k(-f*r-s*i,n);const l=u>c,d=g>c;if(l&&(u=n-u),d&&(g=n-g),u>c||g>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:d,k2:g}}}},Ut),ke=BigInt(0),xe={};function kt(t,...n){let e=xe[t];if(e===void 0){const r=Ut(Uint8Array.from(t,o=>o.charCodeAt(0)));e=K(r,r),xe[t]=e}return Ut(K(e,...n))}const fe=t=>t.toRawBytes(!0).slice(1),ee=t=>st(t,32),Qt=t=>k(t,qt),Ot=t=>k(t,Ht),ae=Mt.ProjectivePoint,Cn=(t,n,e)=>ae.BASE.multiplyAndAddUnsafe(t,n,e);function ne(t){let n=Mt.utils.normPrivateKeyToScalar(t),e=ae.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:Ot(-n),bytes:fe(e)}}function Ce(t){it("x",t,_t,qt);const n=Qt(t*t),e=Qt(n*t+BigInt(7));let r=Re(e);r%Rt!==ke&&(r=Qt(-r));const o=new ae(t,r,_t);return o.assertValidity(),o}const mt=W;function Ve(...t){return Ot(mt(kt("BIP0340/challenge",...t)))}function Vn(t){return ne(t).bytes}function Zn(t,n,e=Be(32)){const r=Z("message",t),{bytes:o,scalar:i}=ne(n),c=Z("auxRand",e,32),f=ee(i^mt(kt("BIP0340/aux",c))),s=kt("BIP0340/nonce",f,o,r),u=Ot(mt(s));if(u===ke)throw new Error("sign failed: k is zero");const{bytes:g,scalar:l}=ne(u),d=Ve(g,o,r),w=new Uint8Array(64);if(w.set(g,0),w.set(ee(Ot(l+d*i)),32),!Ze(w,r,o))throw new Error("sign: Invalid signature produced");return w}function Ze(t,n,e){const r=Z("signature",t,64),o=Z("message",n),i=Z("publicKey",e,32);try{const c=Ce(mt(i)),f=mt(r.subarray(0,32));if(!Et(f,_t,qt))return!1;const s=mt(r.subarray(32,64));if(!Et(s,_t,Ht))return!1;const u=Ve(ee(f),fe(c),o),g=Cn(c,s,Ot(-u));return!(!g||!g.hasEvenY()||g.toAffine().x!==f)}catch{return!1}}const jn={getPublicKey:Vn,sign:Zn,verify:Ze,utils:{randomPrivateKey:Mt.utils.randomPrivateKey,lift_x:Ce,pointToBytes:fe,numberToBytesBE:st,bytesToNumberBE:W,taggedHash:kt,mod:k}},zn=Rn(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Mn=On(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}),ze=kn(Mt.ProjectivePoint,t=>{const{x:n,y:e}=Mn(ct.create(t[0]));return zn(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:Ut}),Kn=ze.hashToCurve,Dn=ze.encodeToCurve;export{Dn as encodeToCurve,Kn as hashToCurve,jn as schnorr,Mt as secp256k1};
