"use strict";var e=require("cross-fetch"),t=require("tty"),n=require("util"),o=require("os"),i=require("buffer"),s=require("eciesjs"),r=require("eventemitter2"),a=require("uuid"),c=require("socket.io-client");function l(e,t,n,o){return new(n||(n=Promise))((function(i,s){function r(e){try{c(o.next(e))}catch(e){s(e)}}function a(e){try{c(o.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,a)}c((o=o.apply(e,t||[])).next())}))}function d(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}"function"==typeof SuppressedError&&SuppressedError;var u,h,m,y,p,g={exports:{}},v={exports:{}};function E(){if(h)return u;h=1;var e=1e3,t=60*e,n=60*t,o=24*n,i=7*o,s=365.25*o;function r(e,t,n,o){var i=t>=1.5*n;return Math.round(e/n)+" "+o+(i?"s":"")}return u=function(a,c){c=c||{};var l=typeof a;if("string"===l&&a.length>0)return function(r){if((r=String(r)).length>100)return;var a=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!a)return;var c=parseFloat(a[1]);switch((a[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return c*s;case"weeks":case"week":case"w":return c*i;case"days":case"day":case"d":return c*o;case"hours":case"hour":case"hrs":case"hr":case"h":return c*n;case"minutes":case"minute":case"mins":case"min":case"m":return c*t;case"seconds":case"second":case"secs":case"sec":case"s":return c*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return c;default:return}}(a);if("number"===l&&isFinite(a))return c.long?function(i){var s=Math.abs(i);if(s>=o)return r(i,s,o,"day");if(s>=n)return r(i,s,n,"hour");if(s>=t)return r(i,s,t,"minute");if(s>=e)return r(i,s,e,"second");return i+" ms"}(a):function(i){var s=Math.abs(i);if(s>=o)return Math.round(i/o)+"d";if(s>=n)return Math.round(i/n)+"h";if(s>=t)return Math.round(i/t)+"m";if(s>=e)return Math.round(i/e)+"s";return i+"ms"}(a);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(a))}}function C(){if(y)return m;return y=1,m=function(e){function t(e){let o,i,s,r=null;function a(...e){if(!a.enabled)return;const n=a,i=Number(new Date),s=i-(o||i);n.diff=s,n.prev=o,n.curr=i,o=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let r=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((o,i)=>{if("%%"===o)return"%";r++;const s=t.formatters[i];if("function"==typeof s){const t=e[r];o=s.call(n,t),e.splice(r,1),r--}return o})),t.formatArgs.call(n,e);(n.log||t.log).apply(n,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=n,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==r?r:(i!==t.namespaces&&(i=t.namespaces,s=t.enabled(e)),s),set:e=>{r=e}}),"function"==typeof t.init&&t.init(a),a}function n(e,n){const o=t(this.namespace+(void 0===n?":":n)+e);return o.log=this.log,o}function o(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack||e.message;return e},t.disable=function(){const e=[...t.names.map(o),...t.skips.map(o).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const o=("string"==typeof e?e:"").split(/[\s,]+/),i=o.length;for(n=0;n<i;n++)o[n]&&("-"===(e=o[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,o;for(n=0,o=t.skips.length;n<o;n++)if(t.skips[n].test(e))return!1;for(n=0,o=t.names.length;n<o;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=E(),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((n=>{t[n]=e[n]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t},m}var S,x,f,k,T,K={exports:{}};function I(){return x?S:(x=1,S=(e,t=process.argv)=>{const n=e.startsWith("-")?"":1===e.length?"-":"--",o=t.indexOf(n+e),i=t.indexOf("--");return-1!==o&&(-1===i||o<i)})}"undefined"==typeof process||"renderer"===process.type||!0===process.browser||process.__nwjs?g.exports=(p||(p=1,function(e,t){t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(o++,"%c"===e&&(i=o))})),t.splice(i,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e},t.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=C()(t);const{formatters:n}=e.exports;n.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}(v,v.exports)),v.exports):g.exports=(T||(T=1,function(e,i){const s=t,r=n;i.init=function(e){e.inspectOpts={};const t=Object.keys(i.inspectOpts);for(let n=0;n<t.length;n++)e.inspectOpts[t[n]]=i.inspectOpts[t[n]]},i.log=function(...e){return process.stderr.write(r.format(...e)+"\n")},i.formatArgs=function(t){const{namespace:n,useColors:o}=this;if(o){const o=this.color,i="[3"+(o<8?o:"8;5;"+o),s=`  ${i};1m${n} [0m`;t[0]=s+t[0].split("\n").join("\n"+s),t.push(i+"m+"+e.exports.humanize(this.diff)+"[0m")}else t[0]=(i.inspectOpts.hideDate?"":(new Date).toISOString()+" ")+n+" "+t[0]},i.save=function(e){e?process.env.DEBUG=e:delete process.env.DEBUG},i.load=function(){return process.env.DEBUG},i.useColors=function(){return"colors"in i.inspectOpts?Boolean(i.inspectOpts.colors):s.isatty(process.stderr.fd)},i.destroy=r.deprecate((()=>{}),"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."),i.colors=[6,2,3,4,5,1];try{const e=function(){if(k)return f;k=1;const e=o,n=t,i=I(),{env:s}=process;let r;function a(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function c(t,n){if(0===r)return 0;if(i("color=16m")||i("color=full")||i("color=truecolor"))return 3;if(i("color=256"))return 2;if(t&&!n&&void 0===r)return 0;const o=r||0;if("dumb"===s.TERM)return o;if("win32"===process.platform){const t=e.release().split(".");return Number(t[0])>=10&&Number(t[2])>=10586?Number(t[2])>=14931?3:2:1}if("CI"in s)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some((e=>e in s))||"codeship"===s.CI_NAME?1:o;if("TEAMCITY_VERSION"in s)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(s.TEAMCITY_VERSION)?1:0;if("truecolor"===s.COLORTERM)return 3;if("TERM_PROGRAM"in s){const e=parseInt((s.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(s.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(s.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(s.TERM)||"COLORTERM"in s?1:o}return i("no-color")||i("no-colors")||i("color=false")||i("color=never")?r=0:(i("color")||i("colors")||i("color=true")||i("color=always"))&&(r=1),"FORCE_COLOR"in s&&(r="true"===s.FORCE_COLOR?1:"false"===s.FORCE_COLOR?0:0===s.FORCE_COLOR.length?1:Math.min(parseInt(s.FORCE_COLOR,10),3)),f={supportsColor:function(e){return a(c(e,e&&e.isTTY))},stdout:a(c(!0,n.isatty(1))),stderr:a(c(!0,n.isatty(2)))}}();e&&(e.stderr||e).level>=2&&(i.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221])}catch(e){}i.inspectOpts=Object.keys(process.env).filter((e=>/^debug_/i.test(e))).reduce(((e,t)=>{const n=t.substring(6).toLowerCase().replace(/_([a-z])/g,((e,t)=>t.toUpperCase()));let o=process.env[t];return o=!!/^(yes|on|true|enabled)$/i.test(o)||!/^(no|off|false|disabled)$/i.test(o)&&("null"===o?null:Number(o)),e[n]=o,e}),{}),e.exports=C()(i);const{formatters:a}=e.exports;a.o=function(e){return this.inspectOpts.colors=this.useColors,r.inspect(e,this.inspectOpts).split("\n").map((e=>e.trim())).join(" ")},a.O=function(e){return this.inspectOpts.colors=this.useColors,r.inspect(e,this.inspectOpts)}}(K,K.exports)),K.exports);var _=d(g.exports);const A=_("KeyExchange:Layer"),O=_("SocketService:Layer"),N=_("Ecies:Layer"),R=_("RemoteCommunication:Layer");A.color="##95c44e",O.color="#f638d7",N.color="#465b9c",R.color="#47a2be";const b={KeyExchange:A,SocketService:O,Ecies:N,RemoteCommunication:R};let w,M=[],P=[];function D(t){return l(this,void 0,void 0,(function*(){if(!w||!t)return;!function(){const e=P;P=M,M=e}();const n=w.endsWith("/")?`${w}evt`:`${w}/evt`,o=Object.assign({},t);if(delete o.params,t.params)for(const[e,n]of Object.entries(t.params))o[e]=n;const i=JSON.stringify(o);b.RemoteCommunication(`[sendBufferedEvents] Sending ${M.length} analytics events to ${n}`);try{const t=yield e(n,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:i}),o=yield t.text();b.RemoteCommunication(`[sendBufferedEvents] Response: ${o}`),M.length=0}catch(e){console.warn("Error sending analytics",e)}}))}const L=(e,t)=>l(void 0,void 0,void 0,(function*(){var n;w=t,n=e,P.push(n),D(e).catch((()=>{}))}));class ${constructor(e){this.enabled=!0,(null==e?void 0:e.debug)&&_.enable("Ecies:Layer"),(null==e?void 0:e.privateKey)?this.ecies=s.PrivateKey.fromHex(e.privateKey):this.ecies=new s.PrivateKey,b.Ecies("[ECIES constructor()] initialized secret: ",this.ecies.toHex()),b.Ecies("[ECIES constructor()] initialized public: ",this.ecies.publicKey.toHex()),b.Ecies("[ECIES constructor()] init with",this)}generateECIES(){this.ecies=new s.PrivateKey}getPublicKey(){return this.ecies.publicKey.toHex()}encrypt(e,t){let n=e;if(this.enabled)try{b.Ecies("[ECIES: encrypt()] using otherPublicKey",t);const o=i.Buffer.from(e),r=s.encrypt(t,o);n=i.Buffer.from(r).toString("base64")}catch(n){throw b.Ecies("[ECIES: encrypt()] error encrypt:",n),b.Ecies("[ECIES: encrypt()] private: ",this.ecies.toHex()),b.Ecies("[ECIES: encrypt()] data: ",e),b.Ecies("[ECIES: encrypt()] otherkey: ",t),n}return n}decrypt(e){let t=e;if(this.enabled)try{b.Ecies("[ECIES: decrypt()] using privateKey",this.ecies.toHex());const n=i.Buffer.from(e.toString(),"base64");t=s.decrypt(this.ecies.toHex(),n).toString()}catch(t){throw b.Ecies("[ECIES: decrypt()] error decrypt",t),b.Ecies("[ECIES: decrypt()] private: ",this.ecies.toHex()),b.Ecies("[ECIES: decrypt()] encryptedData: ",e),t}return t}getKeyInfo(){return{private:this.ecies.toHex(),public:this.ecies.publicKey.toHex()}}toString(){b.Ecies("[ECIES: toString()]",this.getKeyInfo())}}var H={name:"@metamask/sdk-communication-layer",version:"0.30.0",description:"",homepage:"https://github.com/MetaMask/metamask-sdk#readme",bugs:{url:"https://github.com/MetaMask/metamask-sdk/issues"},repository:{type:"git",url:"https://github.com/MetaMask/metamask-sdk.git",directory:"packages/sdk-communication-layer"},main:"dist/node/cjs/metamask-sdk-communication-layer.js",unpkg:"dist/browser/umd/metamask-sdk-communication-layer.js",module:"dist/node/es/metamask-sdk-communication-layer.js",browser:"dist/browser/es/metamask-sdk-communication-layer.js","react-native":"dist/react-native/es/metamask-sdk-communication-layer.js",types:"dist/browser/es/src/index.d.ts",files:["/dist"],scripts:{build:"rimraf dist && rollup -c --bundleConfigAsCjs","build:tsc":"tsc","build:dev":"rimraf dist && NODE_ENV=dev rollup -c --bundleConfigAsCjs","build:post-tsc":"echo 'N/A'","build:pre-tsc":"echo 'N/A'",size:"size-limit",clean:"rimraf ./dist",lint:"yarn lint:eslint && yarn lint:misc --check","lint:changelog":"../../scripts/validate-changelog.sh @metamask/sdk-communication-layer","lint:eslint":"eslint . --cache --ext js,ts","lint:fix":"yarn lint:eslint --fix && yarn lint:misc --write","lint:misc":"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore","publish:preview":"yarn npm publish --tag preview",prepack:"../../scripts/prepack.sh",reset:"yarn clean && rimraf ./node_modules/",test:'jest --testPathIgnorePatterns "/e2e/"',"test:e2e":'jest --testPathPattern "/e2e/"',"test:coverage":"jest --coverage","test:ci":'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"',"test:dev":"jest",watch:"rollup -c --bundleConfigAsCjs -w"},dependencies:{bufferutil:"^4.0.8","date-fns":"^2.29.3",debug:"^4.3.4","utf-8-validate":"^5.0.2",uuid:"^8.3.2"},devDependencies:{"@jest/globals":"^29.3.1","@lavamoat/allow-scripts":"^2.3.1","@metamask/auto-changelog":"3.1.0","@metamask/eslint-config":"^6.0.0","@metamask/eslint-config-nodejs":"^6.0.0","@metamask/eslint-config-typescript":"^6.0.0","@rollup/plugin-commonjs":"^25.0.0","@rollup/plugin-json":"^6.0.0","@rollup/plugin-node-resolve":"^15.0.2","@rollup/plugin-terser":"^0.4.1","@size-limit/preset-big-lib":"^11.0.2","@types/jest":"^29.2.4","@types/node":"^20.1.3","@types/uuid":"^9.0.0","@typescript-eslint/eslint-plugin":"^4.26.0","@typescript-eslint/parser":"^4.26.0","cross-fetch":"^4.0.0",eciesjs:"^0.3.16",eslint:"^7.30.0","eslint-config-prettier":"^8.3.0","eslint-plugin-import":"^2.23.4","eslint-plugin-jest":"^24.4.0","eslint-plugin-jsdoc":"^36.1.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^3.4.0",eventemitter2:"^6.4.7",jest:"^29.3.1",prettier:"^2.3.0",rimraf:"^3.0.2",rollup:"^3.21.7","rollup-plugin-jscc":"^2.0.0","rollup-plugin-natives":"^0.7.5","rollup-plugin-node-builtins":"^2.1.2","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-peer-deps-external":"^2.2.4","rollup-plugin-sizes":"^1.0.6","rollup-plugin-typescript2":"^0.31.2","rollup-plugin-visualizer":"^5.9.2","size-limit":"^11.0.2","socket.io-client":"^4.5.1","stream-browserify":"^3.0.0","ts-jest":"^29.0.3","ts-node":"^10.9.1",typescript:"^4.3.2"},peerDependencies:{"cross-fetch":"^4.0.0",eciesjs:"^0.3.16",eventemitter2:"^6.4.7","readable-stream":"^3.6.2","socket.io-client":"^4.5.1"},publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},lavamoat:{allowScripts:{"@lavamoat/preinstall-always-fail":!1,canvas:!0,"eciesjs>secp256k1":!1,"socket.io-client>engine.io-client>ws>bufferutil":!1,"socket.io-client>engine.io-client>ws>utf-8-validate":!1,bufferutil:!1,"utf-8-validate":!1}}};const j="https://metamask-sdk.api.cx.metamask.io/",F=["websocket"],U=6048e5,Y=3e3,z={METAMASK_GETPROVIDERSTATE:"metamask_getProviderState",ETH_REQUESTACCOUNTS:"eth_requestAccounts"};function G(e){const{context:t}=e;b.RemoteCommunication(`[RemoteCommunication: clean()] context=${t}`),e.channelConfig=void 0,e.ready=!1,e.originatorConnectStarted=!1}var V,W,J,B,q,Z;exports.ConnectionStatus=void 0,(V=exports.ConnectionStatus||(exports.ConnectionStatus={})).DISCONNECTED="disconnected",V.WAITING="waiting",V.TIMEOUT="timeout",V.LINKED="linked",V.PAUSED="paused",V.TERMINATED="terminated",exports.EventType=void 0,(W=exports.EventType||(exports.EventType={})).KEY_INFO="key_info",W.SERVICE_STATUS="service_status",W.PROVIDER_UPDATE="provider_update",W.RPC_UPDATE="rpc_update",W.KEYS_EXCHANGED="keys_exchanged",W.JOIN_CHANNEL="join_channel",W.PUBLIC_KEY="public_key",W.CHANNEL_CREATED="channel_created",W.CLIENTS_CONNECTED="clients_connected",W.CLIENTS_DISCONNECTED="clients_disconnected",W.CLIENTS_WAITING="clients_waiting",W.CLIENTS_READY="clients_ready",W.REJECTED="rejected",W.WALLET_INIT="wallet_init",W.CHANNEL_PERSISTENCE="channel_persistence",W.CONFIG="config",W.MESSAGE_ACK="ack",W.SOCKET_DISCONNECTED="socket_disconnected",W.SOCKET_RECONNECT="socket_reconnect",W.OTP="otp",W.SDK_RPC_CALL="sdk_rpc_call",W.AUTHORIZED="authorized",W.CONNECTION_STATUS="connection_status",W.MESSAGE="message",W.TERMINATE="terminate",function(e){e.KEY_EXCHANGE="key_exchange"}(J||(J={})),exports.KeyExchangeMessageType=void 0,(B=exports.KeyExchangeMessageType||(exports.KeyExchangeMessageType={})).KEY_HANDSHAKE_START="key_handshake_start",B.KEY_HANDSHAKE_CHECK="key_handshake_check",B.KEY_HANDSHAKE_SYN="key_handshake_SYN",B.KEY_HANDSHAKE_SYNACK="key_handshake_SYNACK",B.KEY_HANDSHAKE_ACK="key_handshake_ACK",B.KEY_HANDSHAKE_WALLET="key_handshake_wallet",B.KEY_HANDSHAKE_NONE="none";class X extends r.EventEmitter2{constructor({communicationLayer:e,otherPublicKey:t,context:n,ecies:o,logging:i}){super(),this.keysExchanged=!1,this.step=exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE,this.debug=!1,this.context=n,this.communicationLayer=e,(null==o?void 0:o.privateKey)&&t&&(b.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t} set keysExchanged to true!`,o),this.keysExchanged=!0),this.myECIES=new $(Object.assign(Object.assign({},o),{debug:null==i?void 0:i.eciesLayer})),this.communicationLayer.state.eciesInstance=this.myECIES,this.myPublicKey=this.myECIES.getPublicKey(),this.debug=!0===(null==i?void 0:i.keyExchangeLayer),t&&this.setOtherPublicKey(t),this.communicationLayer.on(J.KEY_EXCHANGE,this.onKeyExchangeMessage.bind(this))}onKeyExchangeMessage(e){const{relayPersistence:t}=this.communicationLayer.remote.state;if(b.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t}`,e),t)return void b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");const{message:n}=e;this.keysExchanged&&b.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`),this.emit(exports.EventType.KEY_INFO,n.type),n.type===exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYN?(this.checkStep([exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE,exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK]),b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN",n),n.pubkey&&this.setOtherPublicKey(n.pubkey),this.communicationLayer.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey}).catch((e=>{b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK",e)})),this.setStep(exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK)):n.type===exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK?(this.checkStep([exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK,exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE]),b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"),n.pubkey&&this.setOtherPublicKey(n.pubkey),this.communicationLayer.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}).catch((e=>{b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK",e)})),this.keysExchanged=!0,this.setStep(exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK),this.emit(exports.EventType.KEYS_EXCHANGED)):n.type===exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK&&(b.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"),this.checkStep([exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK,exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE]),this.keysExchanged=!0,this.setStep(exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK),this.emit(exports.EventType.KEYS_EXCHANGED))}resetKeys(e){this.clean(),this.myECIES=new $(e)}clean(){b.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`),this.setStep(exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE),this.emit(exports.EventType.KEY_INFO,this.step),this.keysExchanged=!1}start({isOriginator:e,force:t}){const{relayPersistence:n,protocolVersion:o}=this.communicationLayer.remote.state,i=o>=2;if(n)return b.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated"),void console.log(`[KeyExchange: start()] relayPersistence=${n}`);b.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${o} isOriginator=${e} step=${this.step} force=${t} relayPersistence=${n} keysExchanged=${this.keysExchanged}`),e?!(this.keysExchanged||this.step!==exports.KeyExchangeMessageType.KEY_HANDSHAKE_NONE&&this.step!==exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK)||t?(b.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t}) -- step=${this.step}`,this.step),this.clean(),this.setStep(exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK),this.communicationLayer.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYN,pubkey:this.myPublicKey,v:2}).catch((e=>{b.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN",e)}))):b.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged?"done":"in progress"} -- aborted.`,this.step):this.keysExchanged&&!0!==t?b.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done."):i?this.communicationLayer.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey,v:2}).catch((e=>{b.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK",e)})):(this.communicationLayer.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_START}).catch((e=>{b.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START",e)})),this.clean())}setStep(e){this.step=e,this.emit(exports.EventType.KEY_INFO,e)}checkStep(e){e.length>0&&-1===e.indexOf(this.step.toString())&&console.warn(`[KeyExchange: checkStep()]  Wrong Step "${this.step}" not within ${e}`)}setRelayPersistence({localKey:e,otherKey:t}){this.otherPublicKey=t,this.myECIES=new $({privateKey:e,debug:this.debug}),this.keysExchanged=!0}setKeysExchanged(e){this.keysExchanged=e}areKeysExchanged(){return this.keysExchanged}getMyPublicKey(){return this.myPublicKey}getOtherPublicKey(){return this.otherPublicKey}setOtherPublicKey(e){b.KeyExchange("[KeyExchange: setOtherPubKey()]",e),this.otherPublicKey=e}encryptMessage(e){if(!this.otherPublicKey)throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.encrypt(e,this.otherPublicKey)}decryptMessage(e){if(!this.otherPublicKey)throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.decrypt(e)}getKeyInfo(){return{ecies:Object.assign(Object.assign({},this.myECIES.getKeyInfo()),{otherPubKey:this.otherPublicKey}),step:this.step,keysExchanged:this.areKeysExchanged()}}toString(){const e={keyInfo:this.getKeyInfo(),keysExchanged:this.keysExchanged,step:this.step};return JSON.stringify(e)}}exports.MessageType=void 0,(q=exports.MessageType||(exports.MessageType={})).TERMINATE="terminate",q.ANSWER="answer",q.OFFER="offer",q.CANDIDATE="candidate",q.JSONRPC="jsonrpc",q.WALLET_INFO="wallet_info",q.WALLET_INIT="wallet_init",q.ORIGINATOR_INFO="originator_info",q.PAUSE="pause",q.OTP="otp",q.AUTHORIZED="authorized",q.PING="ping",q.READY="ready",exports.TrackingEvents=void 0,(Z=exports.TrackingEvents||(exports.TrackingEvents={})).REQUEST="sdk_connect_request_started",Z.REQUEST_MOBILE="sdk_connect_request_started_mobile",Z.RECONNECT="sdk_reconnect_request_started",Z.CONNECTED="sdk_connection_established",Z.CONNECTED_MOBILE="sdk_connection_established_mobile",Z.AUTHORIZED="sdk_connection_authorized",Z.REJECTED="sdk_connection_rejected",Z.TERMINATED="sdk_connection_terminated",Z.DISCONNECTED="sdk_disconnected",Z.SDK_USE_EXTENSION="sdk_use_extension",Z.SDK_RPC_REQUEST="sdk_rpc_request",Z.SDK_RPC_REQUEST_RECEIVED="sdk_rpc_request_received",Z.SDK_RPC_REQUEST_DONE="sdk_rpc_request_done",Z.SDK_EXTENSION_UTILIZED="sdk_extension_utilized",Z.SDK_USE_INAPP_BROWSER="sdk_use_inapp_browser";const Q=(e,t,n)=>l(void 0,void 0,void 0,(function*(){var o,i,s,r,a,c;const{remote:l,state:d}=e,{channelId:u,isOriginator:h}=d;if("error_terminated"===t)return b.SocketService(`handleJoinChannelResults: Channel ${u} terminated`),void e.emit(exports.EventType.TERMINATE);if(!n)return void b.SocketService(`handleJoinChannelResults: No result for channel ${u}`);const{persistence:m,walletKey:y,rejected:p}=n;if(b.SocketService(`handleJoinChannelResults: Channel ${u} persistence=${m} walletKey=${y} rejected=${p}`),p)return b.SocketService(`handleJoinChannelResults: Channel ${u} rejected`),yield e.remote.disconnect({terminate:!0}),e.remote.emit(exports.EventType.REJECTED,{channelId:u}),void e.remote.emitServiceStatusEvent();if(y&&!(null===(o=l.state.channelConfig)||void 0===o?void 0:o.otherKey)){e.getKeyExchange().setOtherPublicKey(y),null===(i=e.state.keyExchange)||void 0===i||i.setKeysExchanged(!0),l.state.ready=!0,l.state.authorized=!0,l.emit(exports.EventType.AUTHORIZED);const{communicationLayer:t,storageManager:n}=l.state,o=Object.assign(Object.assign({},l.state.channelConfig),{channelId:null!==(s=l.state.channelId)&&void 0!==s?s:"",validUntil:Date.now()+U,localKey:null==t?void 0:t.getKeyInfo().ecies.private,otherKey:y});e.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}).catch((e=>{console.error(e)})),null===(r=e.state.socket)||void 0===r||r.emit(exports.MessageType.PING,{id:u,clientType:h?"dapp":"wallet",context:"on_channel_reconnect",message:""}),yield null==n?void 0:n.persistChannelConfig(o),l.emitServiceStatusEvent(),l.setConnectionStatus(exports.ConnectionStatus.LINKED)}m&&(e.emit(exports.EventType.CHANNEL_PERSISTENCE),null===(a=e.state.keyExchange)||void 0===a||a.setKeysExchanged(!0),l.state.ready=!0,l.state.authorized=!0,l.emit(exports.EventType.AUTHORIZED),L(Object.assign(Object.assign({id:null!=u?u:"",event:h?exports.TrackingEvents.CONNECTED:exports.TrackingEvents.CONNECTED_MOBILE},e.remote.state.originatorInfo),{sdkVersion:e.remote.state.sdkVersion,commLayer:e.state.communicationLayerPreference,commLayerVersion:H.version,walletVersion:null===(c=e.remote.state.walletInfo)||void 0===c?void 0:c.version}),d.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)})))}));const ee=e=>new Promise((t=>{setTimeout(t,e)})),te=(e,t,n=200)=>l(void 0,void 0,void 0,(function*(){let o;const i=Date.now();let s=!1;for(;!s;){if(s=Date.now()-i>3e5,o=t[e],void 0!==o.elapsedTime)return o;yield ee(n)}throw new Error(`RPC ${e} timed out`)})),ne=({rpcId:e,instance:t})=>l(void 0,void 0,void 0,(function*(){for(;t.state.lastRpcId===e||void 0===t.state.lastRpcId;)yield ee(200);return t.state.lastRpcId})),oe=e=>l(void 0,void 0,void 0,(function*(){const{state:t}=e,{socket:n,channelId:o,context:i,isOriginator:s,isReconnecting:r}=t;if(r)return b.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping",e),!1;if(!n)return b.SocketService("[SocketService: reconnectSocket()] socket is not defined",e),!1;if(!o)return!1;const{connected:a}=n;t.isReconnecting=!0,t.reconnectionAttempts=0,b.SocketService(`[SocketService: reconnectSocket()] connected=${a} trying to reconnect after socketio disconnection`,e);try{for(;t.reconnectionAttempts<3;){if(b.SocketService(`[SocketService: reconnectSocket()] Attempt ${t.reconnectionAttempts+1} of 3`,e),yield ee(200),n.connected)return b.SocketService("Socket already connected --- ping to retrieve messages"),n.emit(exports.MessageType.PING,{id:o,clientType:s?"dapp":"wallet",context:"on_channel_config",message:""}),!0;t.resumed=!0,n.connect(),e.emit(exports.EventType.SOCKET_RECONNECT);try{if(yield new Promise(((t,r)=>{n.emit(exports.EventType.JOIN_CHANNEL,{channelId:o,context:`${i}connect_again`,clientType:s?"dapp":"wallet"},((n,o)=>l(void 0,void 0,void 0,(function*(){try{yield Q(e,n,o),t()}catch(e){r(e)}}))))})),yield ee(100),n.connected)return b.SocketService(`Reconnection successful on attempt ${t.reconnectionAttempts+1}`),!0}catch(e){b.SocketService(`Error during reconnection attempt ${t.reconnectionAttempts+1}:`,e)}t.reconnectionAttempts+=1,t.reconnectionAttempts<3&&(yield ee(200))}return b.SocketService("Failed to reconnect after 3 attempts"),!1}finally{t.isReconnecting=!1,t.reconnectionAttempts=0}}));function ie(e,t){var n;return l(this,void 0,void 0,(function*(){const o=null===(n=e.state.keyExchange)||void 0===n?void 0:n.encryptMessage(JSON.stringify(t)),i={id:e.state.channelId,context:e.state.context,clientType:e.state.isOriginator?"dapp":"wallet",message:o,plaintext:e.state.hasPlaintext?JSON.stringify(t):void 0};return b.SocketService(`[SocketService: encryptAndSendMessage()] context=${e.state.context}`,i),t.type===exports.MessageType.TERMINATE&&(e.state.manualDisconnect=!0),new Promise(((t,n)=>{var o;null===(o=e.state.socket)||void 0===o||o.emit(exports.EventType.MESSAGE,i,((e,o)=>{var i;e&&(b.SocketService(`[SocketService: encryptAndSendMessage()] error=${e}`),n(e)),b.SocketService("[encryptAndSendMessage] response",o),t(null!==(i=null==o?void 0:o.success)&&void 0!==i&&i)}))}))}))}const se="SDK_CONNECTION_ISSUE";var re;!function(e){e.RPC_CHECK="rpcCheck",e.SKIPPED_RPC="skippedRpc"}(re||(re={}));const ae=["eth_sendTransaction","eth_signTypedData","eth_signTransaction","personal_sign","wallet_requestPermissions","wallet_switchEthereumChain","eth_signTypedData_v3","eth_signTypedData_v4","metamask_connectSign","metamask_connectWith","metamask_batch"].map((e=>e.toLowerCase()));function ce(e,t){var n,o,i;return l(this,void 0,void 0,(function*(){if(!e.state.channelId)throw b.SocketService("handleSendMessage: no channelId - Create a channel first"),new Error("Create a channel first");b.SocketService(`[SocketService: handleSendMessage()] context=${e.state.context} areKeysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`,t);if(null===(o=null==t?void 0:t.type)||void 0===o?void 0:o.startsWith("key_handshake"))return function(e,t){var n;b.SocketService(`[SocketService: handleKeyHandshake()] context=${e.state.context}`,t),null===(n=e.state.socket)||void 0===n||n.emit(exports.EventType.MESSAGE,{id:e.state.channelId,context:e.state.context,clientType:e.state.isOriginator?"dapp":"wallet",message:t})}(e,t),!0;!function(e,t){var n;if(!(null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged())&&!e.remote.state.relayPersistence)throw b.SocketService(`[SocketService: validateKeyExchange()] context=${e.state.context} ERROR keys not exchanged`,t),console.error("[SocketService: validateKeyExchange()] ERROR keys not exchanged",t),new Error("Keys not exchanged BBB")}(e,t),function(e,t){var n;const o=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"",i=null==t?void 0:t.id;e.state.isOriginator&&i&&(e.state.rpcMethodTracker[i]={id:i,timestamp:Date.now(),method:o},e.emit(exports.EventType.RPC_UPDATE,e.state.rpcMethodTracker[i]))}(e,t);const s=yield ie(e,t);return e.remote.state.analytics&&e.remote.state.isOriginator&&t.method&&ae.includes(t.method.toLowerCase())&&L({id:null!==(i=e.remote.state.channelId)&&void 0!==i?i:"",event:exports.TrackingEvents.SDK_RPC_REQUEST,params:{method:t.method,from:"mobile"}},e.remote.state.communicationServerUrl).catch((e=>{console.error("[handleSendMessage] Cannot send analytics",e)})),function(e,t){var n;return l(this,void 0,void 0,(function*(){const o=null==t?void 0:t.id,i=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"";if(e.state.isOriginator&&o)try{const n=te(o,e.state.rpcMethodTracker,200).then((e=>({type:re.RPC_CHECK,result:e}))),s=(()=>l(this,void 0,void 0,(function*(){const t=yield ne({instance:e,rpcId:o}),n=yield te(t,e.state.rpcMethodTracker,200);return{type:re.SKIPPED_RPC,result:n}})))(),r=yield Promise.race([n,s]);if(r.type===re.RPC_CHECK){const e=r.result;b.SocketService(`[SocketService:handleRpcReplies()] id=${t.id} ${i} ( ${e.elapsedTime} ms)`,e.result)}else{if(r.type!==re.SKIPPED_RPC)throw new Error(`Error handling RPC replies for ${o}`);{const{result:t}=r;console.warn(`[SocketService handleRpcReplies()] RPC METHOD HAS BEEN SKIPPED rpcid=${o} method=${i}`,t);const n=Object.assign(Object.assign({},e.state.rpcMethodTracker[o]),{error:new Error(se)});e.emit(exports.EventType.RPC_UPDATE,n);const s={data:Object.assign(Object.assign({},n),{jsonrpc:"2.0"}),name:"metamask-provider"};e.emit(exports.EventType.MESSAGE,{message:s})}}}catch(e){throw console.warn(`[SocketService handleRpcReplies()] Error rpcId=${t.id} ${i}`,e),e}}))}(e,t).catch((e=>{console.warn("[handleSendMessage] Error handleRpcReplies",e)})),s}))}const le=[{event:exports.EventType.CLIENTS_CONNECTED,handler:function(e,t){return n=>l(this,void 0,void 0,(function*(){var n,o,i,s,r,a,c,l,d,u,h;const m=null!==(o=null===(n=e.remote.state.channelConfig)||void 0===n?void 0:n.relayPersistence)&&void 0!==o&&o;if(b.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected-${t}' relayPersistence=${m} resumed=${e.state.resumed}  clientsPaused=${e.state.clientsPaused} keysExchanged=${null===(i=e.state.keyExchange)||void 0===i?void 0:i.areKeysExchanged()} isOriginator=${e.state.isOriginator}`),e.emit(exports.EventType.CLIENTS_CONNECTED,{isOriginator:e.state.isOriginator,keysExchanged:null===(s=e.state.keyExchange)||void 0===s?void 0:s.areKeysExchanged(),context:e.state.context}),e.state.resumed)e.state.isOriginator||(b.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} 'clients_connected' / keysExchanged=${null===(r=e.state.keyExchange)||void 0===r?void 0:r.areKeysExchanged()} -- backward compatibility`),null===(a=e.state.keyExchange)||void 0===a||a.start({isOriginator:null!==(c=e.state.isOriginator)&&void 0!==c&&c})),e.state.resumed=!1;else if(e.state.clientsPaused)b.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");else if(!e.state.isOriginator){const t=!m;b.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected' / keysExchanged=${null===(l=e.state.keyExchange)||void 0===l?void 0:l.areKeysExchanged()} -- force=${t} -- backward compatibility`),b.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected' / keysExchanged=${null===(d=e.state.keyExchange)||void 0===d?void 0:d.areKeysExchanged()} -- force=${t} -- backward compatibility`),null===(u=e.state.keyExchange)||void 0===u||u.start({isOriginator:null!==(h=e.state.isOriginator)&&void 0!==h&&h,force:t})}e.state.clientsConnected=!0,e.state.clientsPaused=!1}))}},{event:exports.EventType.CHANNEL_CREATED,handler:function(e,t){return n=>{b.SocketService(`[SocketService: handleChannelCreated()] context=${e.state.context} on 'channel_created-${t}'`,n),e.emit(exports.EventType.CHANNEL_CREATED,n)}}},{event:exports.EventType.CLIENTS_DISCONNECTED,handler:function(e,t){return()=>{var n;e.state.clientsConnected=!1,b.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e.state.context} on 'clients_disconnected-${t}'`),e.remote.state.relayPersistence?b.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e.state.context} on 'clients_disconnected-${t}' - relayPersistence enabled, skipping key exchange cleanup.`):(e.state.isOriginator&&!e.state.clientsPaused&&(null===(n=e.state.keyExchange)||void 0===n||n.clean()),e.emit(exports.EventType.CLIENTS_DISCONNECTED,t))}}},{event:exports.EventType.CONFIG,handler:function(e,t){return n=>l(this,void 0,void 0,(function*(){var o,i,s;b.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t}'`,n);const{persistence:r,walletKey:a}=n;e.state.isOriginator&&e.remote.state.channelConfig?(n.walletKey&&!e.remote.state.channelConfig.otherKey&&(b.SocketService(`Setting wallet key ${a}`),e.remote.state.channelConfig.otherKey=a,e.getKeyExchange().setOtherPublicKey(n.walletKey),null===(o=e.state.keyExchange)||void 0===o||o.setKeysExchanged(!0),yield e.remote.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_ACK}),yield e.remote.sendMessage({type:exports.MessageType.PING}),yield null===(i=e.remote.state.storageManager)||void 0===i?void 0:i.persistChannelConfig(e.remote.state.channelConfig)),!0!==r||e.remote.state.channelConfig.relayPersistence||(b.SocketService(`Setting relay persistence ${r}`),e.remote.state.channelConfig.relayPersistence=r,e.remote.state.relayPersistence=!0,e.remote.emit(exports.EventType.CHANNEL_PERSISTENCE),e.remote.state.authorized=!0,e.remote.state.ready=!0,e.remote.emit(exports.EventType.AUTHORIZED),yield null===(s=e.remote.state.storageManager)||void 0===s?void 0:s.persistChannelConfig(e.remote.state.channelConfig))):e.state.isOriginator||n.persistence&&(e.remote.state.relayPersistence=!0,e.remote.emit(exports.EventType.CHANNEL_PERSISTENCE))}))}},{event:exports.EventType.MESSAGE,handler:function(e,t){return n=>{var o,i,s,r,a,c,l,d,u,h,m,y,p,g,v,E,C,S;const{ackId:x,message:f,error:k}=n,T=null!==(o=e.remote.state.relayPersistence)&&void 0!==o&&o;if(b.SocketService(`[SocketService handleMessage()]  relayPersistence=${T}  context=${e.state.context} on 'message' ${t} keysExchanged=${null===(i=e.state.keyExchange)||void 0===i?void 0:i.areKeysExchanged()}`,n),k)throw b.SocketService(`\n      [SocketService handleMessage()] context=${e.state.context}::on 'message' error=${k}`),new Error(k);const K="string"==typeof f;if(!K&&(null==f?void 0:f.type)===exports.KeyExchangeMessageType.KEY_HANDSHAKE_START)return T?void console.warn("[SocketService handleMessage()] Ignoring key exchange message because relay persistence is activated",f):(b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e.state.isOriginator}`,f),void(null===(s=e.state.keyExchange)||void 0===s||s.start({isOriginator:null!==(r=e.state.isOriginator)&&void 0!==r&&r,force:!0})));if(!K&&(null===(a=null==f?void 0:f.type)||void 0===a?void 0:a.startsWith("key_handshake")))return T?void console.warn("[SocketService handleMessage()] Ignoring key exchange message because relay persistence is activated",f):(b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' emit KEY_EXCHANGE`,f),void e.emit(J.KEY_EXCHANGE,{message:f,context:e.state.context}));if(K&&!(null===(c=e.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged())){let t=!1;try{b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' trying to decrypt message`),null===(l=e.state.keyExchange)||void 0===l||l.decryptMessage(f),t=!0}catch(t){b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' error`,t)}if(!t)return e.state.isOriginator?null===(u=e.state.keyExchange)||void 0===u||u.start({isOriginator:null!==(h=e.state.isOriginator)&&void 0!==h&&h}):e.sendMessage({type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_START}).catch((t=>{console.error(`[SocketService handleMessage()] context=${e.state.context}::on 'message' error`,t)})),void b.SocketService(`Message ignored because invalid key exchange status. step=${null===(m=e.state.keyExchange)||void 0===m?void 0:m.getKeyInfo().step}`,null===(y=e.state.keyExchange)||void 0===y?void 0:y.getKeyInfo(),f);b.SocketService("Invalid key exchange status detected --- updating it."),null===(d=e.state.keyExchange)||void 0===d||d.setKeysExchanged(!0)}else if(!K&&(null==f?void 0:f.type))return console.warn("[SocketService handleMessage() ::on 'message' received non encrypted unkwown message"),void e.emit(exports.EventType.MESSAGE,f);if(!K)return console.warn("[SocketService handleMessage() ::on 'message' received unkwown message",f),void e.emit(exports.EventType.MESSAGE,f);const I=null===(p=e.state.keyExchange)||void 0===p?void 0:p.decryptMessage(f),_=JSON.parse(null!=I?I:"{}");if(x&&(null==x?void 0:x.length)>0&&(b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' ackid=${x} channelId=${t}`),null===(g=e.state.socket)||void 0===g||g.emit(exports.EventType.MESSAGE_ACK,{ackId:x,channelId:t,clientType:e.state.isOriginator?"dapp":"wallet"})),(null==_?void 0:_.type)===exports.MessageType.PAUSE?e.state.clientsPaused=!0:e.state.clientsPaused=!1,e.state.isOriginator&&_.data){const t=_.data,n=e.state.rpcMethodTracker[t.id];if(n){const o=Date.now()-n.timestamp;b.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received answer for id=${t.id} method=${n.method} responseTime=${o}`,_),e.remote.state.analytics&&ae.includes(n.method.toLowerCase())&&L(Object.assign(Object.assign({id:null!==(v=e.remote.state.channelId)&&void 0!==v?v:"",event:exports.TrackingEvents.SDK_RPC_REQUEST_DONE,sdkVersion:e.remote.state.sdkVersion,commLayerVersion:H.version},e.remote.state.originatorInfo),{walletVersion:null===(E=e.remote.state.walletInfo)||void 0===E?void 0:E.version,params:{method:n.method,from:"mobile"}}),e.remote.state.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}));const i=Object.assign(Object.assign({},n),{result:t.result,error:t.error?{code:null===(C=t.error)||void 0===C?void 0:C.code,message:null===(S=t.error)||void 0===S?void 0:S.message}:void 0,elapsedTime:o});e.state.rpcMethodTracker[t.id]=i,e.emit(exports.EventType.RPC_UPDATE,i)}}e.emit(exports.EventType.MESSAGE,{message:_})}}},{event:exports.EventType.REJECTED,handler:function(e,t){return n=>l(this,void 0,void 0,(function*(){var n;e.state.isOriginator&&!e.remote.state.ready?(b.SocketService(`[SocketService: handleChannelRejected()] context=${e.state.context} channelId=${t} isOriginator=${e.state.isOriginator} ready=${e.remote.state.ready}`,e.remote.state.originatorInfo),L(Object.assign(Object.assign({id:t,event:exports.TrackingEvents.REJECTED},e.remote.state.originatorInfo),{sdkVersion:e.remote.state.sdkVersion,commLayer:e.state.communicationLayerPreference,commLayerVersion:H.version,walletVersion:null===(n=e.remote.state.walletInfo)||void 0===n?void 0:n.version}),e.remote.state.communicationServerUrl).catch((e=>{console.error("handleChannelRejected:: Error emitting analytics event",e)})),yield e.remote.disconnect({terminate:!0}),e.remote.emit(exports.EventType.REJECTED,{channelId:t}),e.remote.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED)):b.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t} isOriginator=${e.state.isOriginator} ready=${e.remote.state.ready}`)}))}},{event:"clients_waiting_to_join",handler:function(e,t){return n=>{b.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e.state.context} on 'clients_waiting_to_join-${t}'`,n),e.emit(exports.EventType.CLIENTS_WAITING,n)}}}],de=[{event:exports.EventType.KEY_INFO,handler:function(e){return t=>{b.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'",t),e.emit(exports.EventType.KEY_INFO,t)}}},{event:exports.EventType.KEYS_EXCHANGED,handler:function(e){return()=>{var t,n,o;b.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`);const{channelConfig:i}=e.remote.state;if(i){const t=e.getKeyExchange().getKeyInfo().ecies;i.localKey=t.private,i.otherKey=t.otherPubKey,e.remote.state.channelConfig=i,null===(n=e.remote.state.storageManager)||void 0===n||n.persistChannelConfig(i).catch((e=>{console.error("Error persisting channel config",e)}))}e.emit(exports.EventType.KEYS_EXCHANGED,{keysExchanged:null===(o=e.state.keyExchange)||void 0===o?void 0:o.areKeysExchanged(),isOriginator:e.state.isOriginator});const s={keyInfo:e.getKeyInfo()};e.emit(exports.EventType.SERVICE_STATUS,s)}}}];function ue(e,t){b.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} setting socket listeners for channel ${t}...`);const{socket:n}=e.state,{keyExchange:o}=e.state;n&&e.state.isOriginator&&(e.state.debug&&(null==n||n.io.on("error",(t=>{b.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=error`,t)})),null==n||n.io.on("reconnect",(t=>{b.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect`,t),oe(e).catch((e=>{}))})),null==n||n.io.on("reconnect_error",(t=>{b.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_error`,t)})),null==n||n.io.on("reconnect_failed",(()=>{b.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_failed`)}))),null==n||n.on("disconnect",(t=>(b.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t}' begin recovery...`),function(e){return t=>{b.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e.state.manualDisconnect}`,t),e.state.manualDisconnect||(e.emit(exports.EventType.SOCKET_DISCONNECTED),oe(e).catch((e=>{console.error("SocketService::handleDisconnect Error reconnecting socket",e)})))}}(e)(t))))),le.forEach((({event:o,handler:i})=>{const s=`${o}-${t}`;null==n||n.on(s,i(e,t))})),de.forEach((({event:t,handler:n})=>{null==o||o.on(t,n(e))})),e.state.setupChannelListeners=!0}class he extends r.EventEmitter2{constructor(e){super(),this.state={clientsConnected:!1,clientsPaused:!1,manualDisconnect:!1,lastRpcId:void 0,rpcMethodTracker:{},hasPlaintext:!1,communicationServerUrl:"",focusListenerAdded:!1,removeFocusListener:void 0,isReconnecting:!1,reconnectionAttempts:0},this.options=e;const{reconnect:t,communicationLayerPreference:n,communicationServerUrl:o,context:i,remote:s,logging:r}=e;this.state.resumed=t,this.state.context=i,this.state.isOriginator=s.state.isOriginator,this.state.communicationLayerPreference=n,this.state.debug=!0===(null==r?void 0:r.serviceLayer),this.remote=s,!0===(null==r?void 0:r.serviceLayer)&&_.enable("SocketService:Layer"),this.state.communicationServerUrl=o,this.state.hasPlaintext=this.state.communicationServerUrl!==j&&!0===(null==r?void 0:r.plaintext),b.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`),this.initSocket()}initSocket(){var e;const{otherPublicKey:t,ecies:n,logging:o}=this.options,i={autoConnect:!1,transports:F,withCredentials:!0},s=this.state.communicationServerUrl;b.SocketService(`[SocketService: initSocket()] Socket IO url: ${s}`),this.state.socket=c.io(s,i),function(e){if("undefined"!=typeof window&&"undefined"!=typeof document&&(b.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`,e),!e.state.focusListenerAdded)){const t=()=>{b.SocketService("Document has focus --- reconnecting socket"),oe(e).catch((e=>{console.error("setupSocketFocusListeners Error reconnecting socket",e)}))};window.addEventListener("focus",t),e.state.focusListenerAdded=!0,e.state.removeFocusListener=()=>{window.removeEventListener("focus",t),e.state.focusListenerAdded=!1}}}(this);const r={communicationLayer:this,otherPublicKey:t,sendPublicKey:!1,context:null!==(e=this.state.context)&&void 0!==e?e:"",ecies:n,logging:o};this.state.keyExchange=new X(r)}resetKeys(){return e=this,b.SocketService("[SocketService: resetKeys()] Resetting keys."),void(null===(t=e.state.keyExchange)||void 0===t||t.resetKeys());var e,t}createChannel(){return l(this,void 0,void 0,(function*(){return function(e){var t,n,o;return l(this,void 0,void 0,(function*(){if(b.SocketService(`[SocketService: createChannel()] context=${e.state.context}`),e.state.socket||e.initSocket(),null===(t=e.state.socket)||void 0===t?void 0:t.connected)throw console.error("[SocketService: createChannel()] socket already connected"),new Error("socket already connected");null===(n=e.state.socket)||void 0===n||n.connect(),e.state.manualDisconnect=!1,e.state.isOriginator=!0;const i=a.v4();e.state.channelId=i,ue(e,i),yield new Promise(((t,n)=>{var o;null===(o=e.state.socket)||void 0===o||o.emit(exports.EventType.JOIN_CHANNEL,{channelId:i,context:`${e.state.context}createChannel`,clientType:"dapp"},((o,i)=>l(this,void 0,void 0,(function*(){try{yield Q(e,o,i),t()}catch(e){n(e)}}))))}));const s=null===(o=e.state.keyExchange)||void 0===o?void 0:o.getKeyInfo();return{channelId:i,pubKey:(null==s?void 0:s.ecies.public)||"",privKey:(null==s?void 0:s.ecies.private)||""}}))}(this)}))}connectToChannel({channelId:e,withKeyExchange:t=!1,authorized:n}){return function({options:e,instance:t}){return l(this,void 0,void 0,(function*(){const{channelId:n,authorized:o,withKeyExchange:i}=e,{state:s,remote:r}=t,{isOriginator:a=!1,socket:c,keyExchange:d}=s,{channelConfig:u}=r.state;if(null==c?void 0:c.connected)throw console.error("[SocketService: connectToChannel()] socket already connected"),new Error("socket already connected");if(a&&(null==u?void 0:u.relayPersistence)){const{localKey:e,otherKey:t}=u;e&&t?null==d||d.setRelayPersistence({localKey:e,otherKey:t}):console.warn("Missing keys in relay persistence",u)}return Object.assign(s,{manualDisconnect:!1,withKeyExchange:i,isOriginator:a,channelId:n}),null==c||c.connect(),ue(t,n),!a&&o&&(null==d||d.setKeysExchanged(!0),Object.assign(r.state,{ready:!0,authorized:!0})),new Promise((e=>{var i;const r=null===(i=null==d?void 0:d.getKeyInfo())||void 0===i?void 0:i.ecies.public,u=o&&!a?r:void 0;null==c||c.emit(exports.EventType.JOIN_CHANNEL,{channelId:n,context:`${s.context}_connectToChannel`,clientType:a?"dapp":"wallet",publicKey:u},((n,o)=>l(this,void 0,void 0,(function*(){yield Q(t,n,o),e()}))))}))}))}({options:{channelId:e,withKeyExchange:t,authorized:n},instance:this})}getKeyInfo(){return this.state.keyExchange.getKeyInfo()}keyCheck(){var e,t;null===(t=(e=this).state.socket)||void 0===t||t.emit(exports.EventType.MESSAGE,{id:e.state.channelId,context:e.state.context,message:{type:exports.KeyExchangeMessageType.KEY_HANDSHAKE_CHECK,pubkey:e.getKeyInfo().ecies.otherPubKey}})}getKeyExchange(){return this.state.keyExchange}sendMessage(e){return l(this,void 0,void 0,(function*(){return ce(this,e)}))}ping(){return function(e){var t,n;return l(this,void 0,void 0,(function*(){b.SocketService(`[SocketService: ping()] context=${e.state.context} originator=${e.state.isOriginator} keysExchanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),null===(n=e.state.socket)||void 0===n||n.emit(exports.MessageType.PING,{id:e.state.channelId,context:"ping",clientType:e.remote.state.isOriginator?"dapp":"wallet",message:""})}))}(this)}pause(){return function(e){var t,n;return l(this,void 0,void 0,(function*(){b.SocketService(`[SocketService: pause()] context=${e.state.context}`),e.state.manualDisconnect=!0,(null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged())&&(yield e.sendMessage({type:exports.MessageType.PAUSE})),null===(n=e.state.socket)||void 0===n||n.disconnect()}))}(this)}isConnected(){var e;return null===(e=this.state.socket)||void 0===e?void 0:e.connected}resume(){return function(e){return l(this,void 0,void 0,(function*(){const{state:t,remote:n}=e,{socket:o,channelId:i,context:s,keyExchange:r,isOriginator:a}=t,{isOriginator:c}=n.state;if(b.SocketService(`[SocketService: resume()] channelId=${i} context=${s} connected=${null==o?void 0:o.connected} manualDisconnect=${t.manualDisconnect} resumed=${t.resumed} keysExchanged=${null==r?void 0:r.areKeysExchanged()}`),!i)throw b.SocketService("[SocketService: resume()] channelId is not defined"),new Error("ChannelId is not defined");(null==o?void 0:o.connected)?(b.SocketService("[SocketService: resume()] already connected."),o.emit(exports.MessageType.PING,{id:i,clientType:c?"dapp":"wallet",context:"on_channel_config",message:""}),n.hasRelayPersistence()||(null==r?void 0:r.areKeysExchanged())||(a?yield e.sendMessage({type:exports.MessageType.READY}):null==r||r.start({isOriginator:!1}))):(null==o||o.connect(),b.SocketService(`[SocketService: resume()] after connecting socket --\x3e connected=${null==o?void 0:o.connected}`),null==o||o.emit(exports.EventType.JOIN_CHANNEL,{channelId:i,context:`${s}_resume`,clientType:c?"dapp":"wallet"},((t,n)=>l(this,void 0,void 0,(function*(){try{yield Q(e,t,n)}catch(e){console.warn("Error reconnecting to channel",e)}}))))),t.manualDisconnect=!1,t.resumed=!0}))}(this)}getRPCMethodTracker(){return this.state.rpcMethodTracker}disconnect(e){return function(e,t){var n,o,i,s,r;b.SocketService(`[SocketService: disconnect()] context=${e.state.context}`,t),(null==t?void 0:t.terminate)&&(null===(o=(n=e.state).removeFocusListener)||void 0===o||o.call(n),e.state.channelId=t.channelId,null===(i=e.state.socket)||void 0===i||i.removeAllListeners(),null===(s=e.state.keyExchange)||void 0===s||s.clean(),e.remote.state.ready=!1,e.state.socket=void 0,e.state.rpcMethodTracker={}),e.state.manualDisconnect=!0,null===(r=e.state.socket)||void 0===r||r.disconnect()}(this,e)}}var me,ye;function pe(e){return()=>l(this,void 0,void 0,(function*(){var t,n,o;const{state:i}=e;if(i.authorized)return;yield(()=>l(this,void 0,void 0,(function*(){for(;!i.walletInfo;)yield ee(500)})))();const s="7.3".localeCompare((null===(t=i.walletInfo)||void 0===t?void 0:t.version)||"");if(b.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null===(n=i.walletInfo)||void 0===n?void 0:n.version} compareValue=${s}`),1!==s)return;const r=i.platformType===exports.PlatformType.MobileWeb||i.platformType===exports.PlatformType.ReactNative||i.platformType===exports.PlatformType.MetaMaskMobileWebview;b.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i.platformType} secure=${r} channel=${i.channelId} walletVersion=${null===(o=i.walletInfo)||void 0===o?void 0:o.version}`),r&&(i.authorized=!0,e.emit(exports.EventType.AUTHORIZED))}))}function ge(e){return t=>{const{state:n}=e;b.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n.context} on 'channel_created' channelId=${t}`),e.emit(exports.EventType.CHANNEL_CREATED,t)}}function ve(e,t){return()=>{var n,o,i,s;const{state:r}=e;if(b.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${r.channelId} keysExchanged=${null===(o=null===(n=r.communicationLayer)||void 0===n?void 0:n.getKeyInfo())||void 0===o?void 0:o.keysExchanged}`),r.analytics){const e=r.isOriginator?exports.TrackingEvents.REQUEST:exports.TrackingEvents.REQUEST_MOBILE;L(Object.assign(Object.assign({id:null!==(i=r.channelId)&&void 0!==i?i:"",event:r.reconnection?exports.TrackingEvents.RECONNECT:e},r.originatorInfo),{commLayer:t,sdkVersion:r.sdkVersion,walletVersion:null===(s=r.walletInfo)||void 0===s?void 0:s.version,commLayerVersion:H.version}),r.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}))}r.clientsConnected=!0,r.originatorInfoSent=!1,e.emit(exports.EventType.CLIENTS_CONNECTED)}}function Ee(e){return t=>{const{state:n}=e;b.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n.context} on 'clients_disconnected' channelId=${t}`),n.relayPersistence||(n.clientsConnected=!1,n.ready=!1,n.authorized=!1),e.emit(exports.EventType.CLIENTS_DISCONNECTED,n.channelId),e.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED)}}function Ce(e){return t=>{var n;const{state:o}=e;if(b.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${o.context} on 'clients_waiting' numberUsers=${t} ready=${o.ready} autoStarted=${o.originatorConnectStarted}`),e.setConnectionStatus(exports.ConnectionStatus.WAITING),e.emit(exports.EventType.CLIENTS_WAITING,t),o.originatorConnectStarted){b.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${o.originatorConnectStarted} timeout`,o.autoConnectOptions);const t=(null===(n=o.autoConnectOptions)||void 0===n?void 0:n.timeout)||3e3,i=setTimeout((()=>{b.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t}) terminate channelConfig`,o.autoConnectOptions),o.originatorConnectStarted=!1,o.ready||e.setConnectionStatus(exports.ConnectionStatus.TIMEOUT),clearTimeout(i)}),t)}}}function Se(e,t){return n=>{var o,i,s,r,a,c,l,d;const{state:u}=e;if(b.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u.context} on commLayer.'keys_exchanged' channel=${u.channelId}`,n),null===(i=null===(o=u.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===i?void 0:i.keysExchanged){const t=Object.assign(Object.assign({},u.channelConfig),{channelId:null!==(s=u.channelId)&&void 0!==s?s:"",validUntil:(null===(r=u.channelConfig)||void 0===r?void 0:r.validUntil)||U,localKey:u.communicationLayer.getKeyInfo().ecies.private,otherKey:u.communicationLayer.getKeyInfo().ecies.otherPubKey});null===(a=u.storageManager)||void 0===a||a.persistChannelConfig(t).catch((e=>{console.error("Error persisting channel config",e)})),e.setConnectionStatus(exports.ConnectionStatus.LINKED)}!function(e,t){var n,o,i,s,r,a,c,l;const{state:d}=e;b.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d.channelId}`,t);const u=Object.assign(Object.assign({},d.channelConfig),{channelId:null!==(n=d.channelId)&&void 0!==n?n:"",validUntil:null!==(i=null===(o=d.channelConfig)||void 0===o?void 0:o.validUntil)&&void 0!==i?i:0,relayPersistence:d.relayPersistence,localKey:null===(r=null===(s=d.communicationLayer)||void 0===s?void 0:s.state.keyExchange)||void 0===r?void 0:r.getKeyInfo().ecies.private,otherKey:null===(c=null===(a=d.communicationLayer)||void 0===a?void 0:a.state.keyExchange)||void 0===c?void 0:c.getKeyInfo().ecies.otherPubKey,lastActive:t.getTime()});null===(l=d.storageManager)||void 0===l||l.persistChannelConfig(u)}(e,new Date),u.analytics&&u.channelId&&L(Object.assign(Object.assign({id:u.channelId,event:n.isOriginator?exports.TrackingEvents.CONNECTED:exports.TrackingEvents.CONNECTED_MOBILE},u.originatorInfo),{sdkVersion:u.sdkVersion,commLayer:t,commLayerVersion:H.version,walletVersion:null===(c=u.walletInfo)||void 0===c?void 0:c.version}),u.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)})),u.isOriginator=n.isOriginator,n.isOriginator||(null===(l=u.communicationLayer)||void 0===l||l.sendMessage({type:exports.MessageType.READY}),u.ready=!0,u.paused=!1),n.isOriginator&&!u.originatorInfoSent&&(null===(d=u.communicationLayer)||void 0===d||d.sendMessage({type:exports.MessageType.ORIGINATOR_INFO,originatorInfo:u.originatorInfo,originator:u.originatorInfo}),u.originatorInfoSent=!0)}}function xe(e,t){const{state:n}=t;if(b.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n.context} on 'message' typeof=${typeof e}`,e),t.state.ready=!0,n.isOriginator||e.type!==exports.MessageType.ORIGINATOR_INFO)if(n.isOriginator&&e.type===exports.MessageType.WALLET_INFO)!function(e,t){const{state:n}=e;n.walletInfo=t.walletInfo,n.paused=!1}(t,e);else{if(n.isOriginator&&e.type===exports.MessageType.WALLET_INIT)(function(e,t){var n,o,i;return l(this,void 0,void 0,(function*(){const{state:s}=e;if(s.isOriginator){const s=t.data||{};if("object"==typeof s&&"accounts"in s&&"chainId"in s&&"walletKey"in s)try{const{channelConfig:t}=e.state;if(b.RemoteCommunication("WALLET_INIT: channelConfig",JSON.stringify(t,null,2)),t){const r=s.accounts,a=s.chainId,c=s.walletKey;let l,d=!1;"deeplinkProtocol"in s&&(d=Boolean(s.deeplinkProtocol),e.state.deeplinkProtocolAvailable=d),"walletVersion"in s&&(l=s.walletVersion),yield null===(n=e.state.storageManager)||void 0===n?void 0:n.persistChannelConfig(Object.assign(Object.assign({},t),{otherKey:c,walletVersion:l,deeplinkProtocolAvailable:d,relayPersistence:!0})),yield null===(o=e.state.storageManager)||void 0===o?void 0:o.persistAccounts(r),yield null===(i=e.state.storageManager)||void 0===i?void 0:i.persistChainId(a)}e.emit(exports.EventType.WALLET_INIT,{accounts:s.accounts,chainId:s.chainId})}catch(e){console.error('RemoteCommunication::on "wallet_init" -- error',e)}else console.error('RemoteCommunication::on "wallet_init" -- invalid data format',s)}}))})(t,e).catch((e=>{b.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`)}));else if(e.type===exports.MessageType.TERMINATE)(function(e){return l(this,void 0,void 0,(function*(){const{state:t}=e;t.isOriginator&&(yield Ae({options:{terminate:!0,sendMessage:!1},instance:e}),e.emit(exports.EventType.TERMINATE))}))})(t).catch((e=>{b.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e}`)}));else if(e.type===exports.MessageType.PAUSE)!function(e){const{state:t}=e;t.paused=!0,e.setConnectionStatus(exports.ConnectionStatus.PAUSED)}(t);else if(e.type===exports.MessageType.READY&&n.isOriginator)!function(e){const{state:t}=e;e.setConnectionStatus(exports.ConnectionStatus.LINKED);const n=t.paused;t.paused=!1,e.emit(exports.EventType.CLIENTS_READY,{isOriginator:t.isOriginator,walletInfo:t.walletInfo}),n&&(t.authorized=!0,e.emit(exports.EventType.AUTHORIZED))}(t);else{if(e.type===exports.MessageType.OTP&&n.isOriginator)return void function(e,t){var n;const{state:o}=e;e.emit(exports.EventType.OTP,t.otpAnswer),1==="6.6".localeCompare((null===(n=o.walletInfo)||void 0===n?void 0:n.version)||"")&&(console.warn("RemoteCommunication::on 'otp' -- backward compatibility <6.6 -- triger eth_requestAccounts"),e.emit(exports.EventType.SDK_RPC_CALL,{method:z.ETH_REQUESTACCOUNTS,params:[]}))}(t,e);e.type===exports.MessageType.AUTHORIZED&&n.isOriginator&&function(e){const{state:t}=e;t.authorized=!0,e.emit(exports.EventType.AUTHORIZED)}(t)}t.emit(exports.EventType.MESSAGE,e)}else!function(e,t){var n;const{state:o}=e;null===(n=o.communicationLayer)||void 0===n||n.sendMessage({type:exports.MessageType.WALLET_INFO,walletInfo:o.walletInfo}),o.originatorInfo=t.originatorInfo||t.originator,e.emit(exports.EventType.CLIENTS_READY,{isOriginator:o.isOriginator,originatorInfo:o.originatorInfo}),o.paused=!1}(t,e)}function fe(e,t){var n,o;return l(this,void 0,void 0,(function*(){const{state:i}=e;b.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context} paused=${i.paused} ready=${i.ready} relayPersistence=${i.relayPersistence} authorized=${i.authorized} socket=${null===(n=i.communicationLayer)||void 0===n?void 0:n.isConnected()} clientsConnected=${i.clientsConnected} status=${i._connectionStatus}`,t),i.relayPersistence||i.ready&&(null===(o=i.communicationLayer)||void 0===o?void 0:o.isConnected())&&i.clientsConnected||(b.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  SKIP message waiting for MM mobile readiness.`),yield new Promise((t=>{e.once(exports.EventType.CLIENTS_READY,t)})),b.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  AFTER SKIP / READY -- sending pending message`));try{const n=yield function(e,t){return l(this,void 0,void 0,(function*(){return new Promise((n=>{var o;const{state:i}=e;b.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i.context} ready=${i.ready} authorized=${i.authorized} method=${t.method}`),!i.isOriginator||i.authorized||i.relayPersistence?null===(o=i.communicationLayer)||void 0===o||o.sendMessage(t).then((e=>{n(e)})).catch((e=>{console.error(`[RemoteCommunication: handleAuthorization()] context=${i.context}  ERROR`,e),n(!1)})):e.once(exports.EventType.AUTHORIZED,(()=>{var e;b.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i.context}  AFTER SKIP / AUTHORIZED -- sending pending message`),null===(e=i.communicationLayer)||void 0===e||e.sendMessage(t).then((e=>{n(e)})).catch((e=>{console.error(`[RemoteCommunication: handleAuthorization()] context=${i.context}  ERROR`,e),n(!1)}))}))}))}))}(e,t);return n}catch(e){throw console.error(`[RemoteCommunication: sendMessage()] context=${i.context}  ERROR`,e),e}}))}function ke(e){return t=>{let n=t;t.message&&(n=n.message),xe(n,e)}}function Te(e){return()=>{const{state:t}=e;b.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"),t.ready=!1,t.authorized=!1,G(t),e.emitServiceStatusEvent({context:"socket_reconnect"})}}function Ke(e){return()=>{const{state:t}=e;b.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"),t.ready=!1}}function Ie(e){return()=>l(this,void 0,void 0,(function*(){var t,n,o,i,s,r,a;const{state:c}=e;b.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c.context}`),e.state.ready=!0,e.state.clientsConnected=!0,e.state.authorized=!0,e.state.relayPersistence=!0,null===(t=e.state.communicationLayer)||void 0===t||t.getKeyExchange().setKeysExchanged(!0),e.emit(exports.EventType.KEYS_EXCHANGED,{keysExchanged:!0,isOriginator:!0}),e.emit(exports.EventType.AUTHORIZED),e.emit(exports.EventType.CLIENTS_READY),e.emit(exports.EventType.CHANNEL_PERSISTENCE);try{c.channelConfig=Object.assign(Object.assign({},c.channelConfig),{localKey:null===(n=c.communicationLayer)||void 0===n?void 0:n.getKeyExchange().getKeyInfo().ecies.private,otherKey:null===(o=c.communicationLayer)||void 0===o?void 0:o.getKeyExchange().getOtherPublicKey(),channelId:null!==(i=c.channelId)&&void 0!==i?i:"",validUntil:null!==(r=null===(s=c.channelConfig)||void 0===s?void 0:s.validUntil)&&void 0!==r?r:U,relayPersistence:!0}),yield null===(a=c.storageManager)||void 0===a?void 0:a.persistChannelConfig(c.channelConfig)}catch(e){console.error("Error persisting channel config",e)}}))}function _e({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:i=j,instance:s}){var r,a,c,l,d,u,h,m,y,p,g;const{state:v}=s;if(b.RemoteCommunication("[initCommunicationLayer()] ",JSON.stringify(v,null,2)),e!==exports.CommunicationLayerPreference.SOCKET)throw new Error("Invalid communication protocol");v.communicationLayer=new he({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,transports:v.transports,communicationServerUrl:i,context:v.context,ecies:o,logging:v.logging,remote:s});let E="undefined"!=typeof document&&document.URL||"",C="undefined"!=typeof document&&document.title||"";(null===(r=v.dappMetadata)||void 0===r?void 0:r.url)&&(E=v.dappMetadata.url),(null===(a=v.dappMetadata)||void 0===a?void 0:a.name)&&(C=v.dappMetadata.name);const S=null!==(u=null!==(l=null===(c=v.dappMetadata)||void 0===c?void 0:c.name)&&void 0!==l?l:null===(d=v.dappMetadata)||void 0===d?void 0:d.url)&&void 0!==u?u:"N/A",x="undefined"!=typeof window&&void 0!==window.location&&null!==(h=window.location.hostname)&&void 0!==h?h:S,f={url:E,title:C,source:null===(m=v.dappMetadata)||void 0===m?void 0:m.source,dappId:x,icon:(null===(y=v.dappMetadata)||void 0===y?void 0:y.iconUrl)||(null===(p=v.dappMetadata)||void 0===p?void 0:p.base64Icon),platform:v.platformType,apiVersion:H.version,connector:null===(g=v.dappMetadata)||void 0===g?void 0:g.connector};v.originatorInfo=f;const k={[exports.EventType.AUTHORIZED]:pe(s),[exports.EventType.MESSAGE]:ke(s),[exports.EventType.CHANNEL_PERSISTENCE]:Ie(s),[exports.EventType.CLIENTS_CONNECTED]:ve(s,e),[exports.EventType.KEYS_EXCHANGED]:Se(s,e),[exports.EventType.SOCKET_DISCONNECTED]:Ke(s),[exports.EventType.SOCKET_RECONNECT]:Te(s),[exports.EventType.CLIENTS_DISCONNECTED]:Ee(s),[exports.EventType.KEY_INFO]:()=>{},[exports.EventType.CHANNEL_CREATED]:ge(s),[exports.EventType.CLIENTS_WAITING]:Ce(s),[exports.EventType.RPC_UPDATE]:e=>{s.emit(exports.EventType.RPC_UPDATE,e)}};for(const[e,t]of Object.entries(k))try{v.communicationLayer.on(e,t)}catch(t){console.error(`Error registering handler for ${e}:`,t)}}function Ae({options:e,instance:t}){return l(this,void 0,void 0,(function*(){const{state:n}=t;return b.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n.channelId}`,e),new Promise(((o,i)=>{var s,r,c,l,d,u;(null==e?void 0:e.terminate)?(t.state.ready&&L({id:null!==(s=t.state.channelId)&&void 0!==s?s:"",event:exports.TrackingEvents.TERMINATED},t.state.communicationServerUrl).catch((e=>{console.error("[handleSendMessage] Cannot send analytics",e)})),n.ready=!1,n.paused=!1,null===(r=n.storageManager)||void 0===r||r.terminate(null!==(c=n.channelId)&&void 0!==c?c:""),t.state.terminated=!0,e.sendMessage?(null===(l=n.communicationLayer)||void 0===l?void 0:l.getKeyInfo().keysExchanged)&&t.state.communicationLayer&&ie(t.state.communicationLayer,{type:exports.MessageType.TERMINATE}).then((()=>{console.warn("[disconnect] Terminate message sent to the other peer"),o(!0)})).catch((e=>{i(e)})):o(!0),n.authorized=!1,n.relayPersistence=!1,n.channelId=a.v4(),e.channelId=n.channelId,n.channelConfig=void 0,n.originatorConnectStarted=!1,null===(d=n.communicationLayer)||void 0===d||d.disconnect(e),t.setConnectionStatus(exports.ConnectionStatus.TERMINATED)):(null===(u=n.communicationLayer)||void 0===u||u.disconnect(e),t.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED),o(!0))}))}))}exports.CommunicationLayerPreference=void 0,(exports.CommunicationLayerPreference||(exports.CommunicationLayerPreference={})).SOCKET="socket",exports.PlatformType=void 0,(me=exports.PlatformType||(exports.PlatformType={})).NonBrowser="nodejs",me.MetaMaskMobileWebview="in-app-browser",me.DesktopWeb="web-desktop",me.MobileWeb="web-mobile",me.ReactNative="react-native";class Oe extends r.EventEmitter2{constructor(e){super(),this.state={ready:!1,authorized:!1,isOriginator:!1,terminated:!1,protocolVersion:1,paused:!1,deeplinkProtocolAvailable:!1,platformType:"metamask-mobile",analytics:!1,reconnection:!1,originatorInfoSent:!1,communicationServerUrl:j,context:"",persist:!1,clientsConnected:!1,sessionDuration:U,originatorConnectStarted:!1,debug:!1,_connectionStatus:exports.ConnectionStatus.DISCONNECTED},this._options=e;const{platformType:t,communicationLayerPreference:n,otherPublicKey:o,reconnect:i,walletInfo:s,dappMetadata:r,protocolVersion:a,transports:c,context:l,relayPersistence:d,ecies:u,analytics:h=!1,storage:m,sdkVersion:y,communicationServerUrl:p=j,logging:g,autoConnect:v={timeout:Y}}=e;this.state.otherPublicKey=o,this.state.dappMetadata=r,this.state.walletInfo=s,this.state.transports=c,this.state.platformType=t,this.state.analytics=h,this.state.protocolVersion=null!=a?a:1,this.state.isOriginator=!o,this.state.relayPersistence=d,this.state.communicationServerUrl=p,this.state.context=l,this.state.terminated=!1,this.state.sdkVersion=y,this.setMaxListeners(50),this.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED),(null==m?void 0:m.duration)&&(this.state.sessionDuration=U),this.state.storageOptions=m,this.state.autoConnectOptions=v,this.state.debug=!0===(null==g?void 0:g.remoteLayer),!0===(null==g?void 0:g.remoteLayer)&&_.enable("RemoteCommunication:Layer"),!0===(null==g?void 0:g.serviceLayer)&&_.enable("SocketService:Layer"),!0===(null==g?void 0:g.eciesLayer)&&_.enable("ECIES:Layer"),!0===(null==g?void 0:g.keyExchangeLayer)&&_.enable("KeyExchange:Layer"),this.state.logging=g,(null==m?void 0:m.storageManager)&&(this.state.storageManager=m.storageManager),b.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${a} relayPersistence=${d} isOriginator=${this.state.isOriginator} communicationLayerPreference=${n} otherPublicKey=${o} reconnect=${i}`),this.state.isOriginator||_e({communicationLayerPreference:n,otherPublicKey:o,reconnect:i,ecies:u,communicationServerUrl:p,instance:this}),this.emitServiceStatusEvent({context:"constructor"})}initFromDappStorage(){var e;return l(this,void 0,void 0,(function*(){if(this.state.storageManager){const t=yield this.state.storageManager.getPersistedChannelConfig({});t&&(this.state.channelConfig=t,this.state.channelId=t.channelId,this.state.deeplinkProtocolAvailable=null!==(e=t.deeplinkProtocolAvailable)&&void 0!==e&&e,t.relayPersistence&&(this.state.authorized=!0,this.state.ready=!0,this.setConnectionStatus(exports.ConnectionStatus.LINKED),yield this.connectToChannel({channelId:t.channelId})))}_e({communicationLayerPreference:exports.CommunicationLayerPreference.SOCKET,otherPublicKey:this.state.otherPublicKey,reconnect:this._options.reconnect,ecies:this._options.ecies,communicationServerUrl:this.state.communicationServerUrl,instance:this})}))}originatorSessionConnect(){return l(this,void 0,void 0,(function*(){return yield function(e){var t;return l(this,void 0,void 0,(function*(){const{state:n}=e;if(!n.storageManager)return void b.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");const o=yield n.storageManager.getPersistedChannelConfig({});if(b.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n.originatorConnectStarted} channelConfig`,o),null===(t=n.communicationLayer)||void 0===t?void 0:t.isConnected())return b.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"),o;if(o){if(o.validUntil>Date.now())return n.channelConfig=o,n.originatorConnectStarted=!0,n.channelId=null==o?void 0:o.channelId,n.reconnection=!0,o;b.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired")}n.originatorConnectStarted=!1}))}(this)}))}generateChannelIdConnect(){return l(this,void 0,void 0,(function*(){return function(e){var t,n,o,i,s,r;return l(this,void 0,void 0,(function*(){if(!e.communicationLayer)throw new Error("communication layer not initialized");if(e.ready)throw new Error("Channel already connected");if(e.channelId&&(null===(t=e.communicationLayer)||void 0===t?void 0:t.isConnected()))return e.channelConfig=Object.assign(Object.assign({},e.channelConfig),{channelId:e.channelId,validUntil:Date.now()+e.sessionDuration}),null===(n=e.storageManager)||void 0===n||n.persistChannelConfig(e.channelConfig),{channelId:e.channelId,privKey:null===(i=null===(o=e.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===i?void 0:i.ecies.private,pubKey:null===(r=null===(s=e.communicationLayer)||void 0===s?void 0:s.getKeyInfo())||void 0===r?void 0:r.ecies.public};b.RemoteCommunication("[RemoteCommunication: generateChannelId()]");const a=yield e.communicationLayer.createChannel();b.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created",a);const c=Object.assign(Object.assign({},e.channelConfig),{channelId:a.channelId,localKey:a.privKey,validUntil:Date.now()+e.sessionDuration});return e.channelId=a.channelId,e.channelConfig=c,{channelId:e.channelId,pubKey:a.pubKey,privKey:a.privKey}}))}(this.state)}))}clean(){return G(this.state)}connectToChannel({channelId:e,withKeyExchange:t,authorized:n}){return function({channelId:e,withKeyExchange:t,authorized:n,state:o}){var i,s,r;return l(this,void 0,void 0,(function*(){if(!a.validate(e))throw b.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${o.context} invalid channel channelId=${e}`),new Error(`Invalid channel ${e}`);if(b.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${o.context} channelId=${e} withKeyExchange=${t}`),null===(i=o.communicationLayer)||void 0===i?void 0:i.isConnected())return void b.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${o.context} already connected - interrupt connection.`);o.channelId=e,yield null===(s=o.communicationLayer)||void 0===s?void 0:s.connectToChannel({channelId:e,authorized:n,withKeyExchange:t});const c=Object.assign(Object.assign({},o.channelConfig),{channelId:e,validUntil:Date.now()+o.sessionDuration});o.channelConfig=c,null===(r=o.storageManager)||void 0===r||r.persistChannelConfig(c)}))}({channelId:e,authorized:n,withKeyExchange:t,state:this.state})}sendMessage(e){return fe(this,e)}testStorage(){return l(this,void 0,void 0,(function*(){return function(e){var t;return l(this,void 0,void 0,(function*(){const n=yield null===(t=e.storageManager)||void 0===t?void 0:t.getPersistedChannelConfig();b.RemoteCommunication("[RemoteCommunication: testStorage()] res",n)}))}(this.state)}))}hasDeeplinkProtocol(){return this.state.deeplinkProtocolAvailable}getChannelConfig(){return this.state.channelConfig}isReady(){return this.state.ready}isConnected(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.isConnected()}isAuthorized(){return this.state.authorized}isPaused(){return this.state.paused}getCommunicationLayer(){return this.state.communicationLayer}ping(){var e;return l(this,void 0,void 0,(function*(){b.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`),yield null===(e=this.state.communicationLayer)||void 0===e?void 0:e.ping()}))}testLogger(){b.RemoteCommunication(`testLogger() channel=${this.state.channelId}`),b.SocketService(`testLogger() channel=${this.state.channelId}`),b.Ecies(`testLogger() channel=${this.state.channelId}`),b.KeyExchange(`testLogger() channel=${this.state.channelId}`)}keyCheck(){var e;b.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.keyCheck()}setConnectionStatus(e){this.state._connectionStatus!==e&&(this.state._connectionStatus=e,this.emit(exports.EventType.CONNECTION_STATUS,e),this.emitServiceStatusEvent({context:"setConnectionStatus"}))}emitServiceStatusEvent(e={}){this.emit(exports.EventType.SERVICE_STATUS,this.getServiceStatus())}getConnectionStatus(){return this.state._connectionStatus}getServiceStatus(){return{originatorInfo:this.state.originatorInfo,keyInfo:this.getKeyInfo(),connectionStatus:this.state._connectionStatus,channelConfig:this.state.channelConfig,channelId:this.state.channelId}}getKeyInfo(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getKeyInfo()}resetKeys(){var e;null===(e=this.state.communicationLayer)||void 0===e||e.resetKeys()}setOtherPublicKey(e){var t;const n=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange();if(!n)throw new Error("KeyExchange is not initialized.");n.getOtherPublicKey()!==e&&n.setOtherPublicKey(e)}pause(){var e;return l(this,void 0,void 0,(function*(){b.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`),yield null===(e=this.state.communicationLayer)||void 0===e?void 0:e.pause(),this.setConnectionStatus(exports.ConnectionStatus.PAUSED)}))}getVersion(){return H.version}hasRelayPersistence(){var e;return null!==(e=this.state.relayPersistence)&&void 0!==e&&e}resume(){return l(this,void 0,void 0,(function*(){return function(e){var t;return l(this,void 0,void 0,(function*(){const{state:n}=e;b.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n.channelId}`),yield null===(t=n.communicationLayer)||void 0===t?void 0:t.resume(),e.setConnectionStatus(exports.ConnectionStatus.LINKED)}))}(this)}))}encrypt(e){var t,n,o;const i=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange(),s=null==i?void 0:i.getOtherPublicKey();if(!s)throw new Error("KeyExchange not completed");return null===(o=null===(n=this.state.communicationLayer)||void 0===n?void 0:n.state.eciesInstance)||void 0===o?void 0:o.encrypt(e,s)}decrypt(e){var t,n,o;if(!(null===(t=this.state.communicationLayer)||void 0===t?void 0:t.state.eciesInstance))throw new Error("ECIES instance is not initialized");return null===(o=null===(n=this.state.communicationLayer)||void 0===n?void 0:n.state.eciesInstance)||void 0===o?void 0:o.decrypt(e)}getChannelId(){return this.state.channelId}getRPCMethodTracker(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getRPCMethodTracker()}reject({channelId:e}){return function({channelId:e,state:t}){var n,o,i;return l(this,void 0,void 0,(function*(){if(!a.validate(e))throw b.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t.context} invalid channel channelId=${e}`),new Error(`Invalid channel ${e}`);if(t.isOriginator)return void b.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} isOriginator=${t.isOriginator} channelId=${e}`);const{socket:s}=null!==(o=null===(n=t.communicationLayer)||void 0===n?void 0:n.state)&&void 0!==o?o:{};(null==s?void 0:s.connected)||(b.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} socket already connected`),null==s||s.connect()),L(Object.assign(Object.assign({id:e,event:exports.TrackingEvents.REJECTED},t.originatorInfo),{sdkVersion:t.sdkVersion,commLayerVersion:H.version,walletVersion:null===(i=t.walletInfo)||void 0===i?void 0:i.version}),t.communicationServerUrl).catch((e=>{console.error("rejectChannel:: Error emitting analytics event",e)})),yield new Promise(((n,o)=>{null==s||s.emit(exports.EventType.REJECTED,{channelId:e},((e,i)=>{b.RemoteCommunication(`[RemoteCommunication: reject()] context=${t.context} socket=${null==s?void 0:s.id}`,{error:e,response:i}),e?o(e):n(i)}))}))}))}({channelId:e,state:this.state})}disconnect(e){return l(this,void 0,void 0,(function*(){return Ae({options:e,instance:this})}))}}exports.AutoConnectType=void 0,(ye=exports.AutoConnectType||(exports.AutoConnectType={})).RENEW="renew",ye.LINK="link",exports.DEFAULT_SERVER_URL=j,exports.DEFAULT_SESSION_TIMEOUT_MS=U,exports.ECIES=$,exports.RemoteCommunication=Oe,exports.SendAnalytics=L,exports.SocketService=he;
//# sourceMappingURL=metamask-sdk-communication-layer.js.map
