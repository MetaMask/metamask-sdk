{"version":3,"sources":["../src/BaseProvider.ts"],"sourcesContent":["import type { JsonRpcMiddleware } from '@metamask/json-rpc-engine';\nimport { JsonRpcEngine } from '@metamask/json-rpc-engine';\nimport { rpcErrors, JsonRpcError } from '@metamask/rpc-errors';\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport type {\n  JsonRpcRequest,\n  JsonRpcId,\n  JsonRpcVersion2,\n  JsonRpcSuccess,\n  JsonRpcParams,\n  Json,\n} from '@metamask/utils';\nimport dequal from 'fast-deep-equal';\n\nimport messages from './messages';\nimport type { ConsoleLike, Maybe } from './utils';\nimport { getRpcPromiseCallback, isValidChainId } from './utils';\n\nexport type UnvalidatedJsonRpcRequest = {\n  id?: JsonRpcId;\n  jsonrpc?: JsonRpcVersion2;\n  method: string;\n  params?: unknown;\n};\n\nexport type BaseProviderOptions = {\n  /**\n   * The logging API to use.\n   */\n  logger?: ConsoleLike;\n\n  /**\n   * The maximum number of event listeners.\n   */\n  maxEventListeners?: number;\n\n  /**\n   * `@metamask/json-rpc-engine` middleware. The middleware will be inserted in the given\n   * order immediately after engine initialization.\n   */\n  rpcMiddleware?: JsonRpcMiddleware<JsonRpcParams, Json>[];\n};\n\nexport type RequestArguments = {\n  /** The RPC method to request. */\n  method: string;\n\n  /** The params of the RPC method, if any. */\n  params?: unknown[] | Record<string, unknown>;\n};\n\nexport type BaseProviderState = {\n  accounts: null | string[];\n  isConnected: boolean;\n  isUnlocked: boolean;\n  initialized: boolean;\n  isPermanentlyDisconnected: boolean;\n};\n\n/**\n * An abstract class implementing the EIP-1193 interface. Implementers must:\n *\n * 1. At initialization, push a middleware to the internal `_rpcEngine` that\n * hands off requests to the server and receives responses in return.\n * 2. At initialization, retrieve initial state and call\n * {@link BaseProvider._initializeState} **once**.\n * 3. Ensure that the provider's state is synchronized with the wallet.\n * 4. Ensure that notifications are received and emitted as appropriate.\n */\nexport abstract class BaseProvider extends SafeEventEmitter {\n  protected readonly _log: ConsoleLike;\n\n  protected _state: BaseProviderState;\n\n  protected _rpcEngine: JsonRpcEngine;\n\n  protected static _defaultState: BaseProviderState = {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n  };\n\n  /**\n   * The chain ID of the currently connected Ethereum chain.\n   * See [chainId.network]{@link https://chainid.network} for more information.\n   */\n  #chainId: string | null;\n\n  /**\n   * The user's currently selected Ethereum address.\n   * If null, MetaMask is either locked or the user has not permitted any\n   * addresses to be viewed.\n   */\n  #selectedAddress: string | null;\n\n  /**\n   * Create a new instance of the provider.\n   *\n   * @param options - An options bag.\n   * @param options.logger - The logging API to use. Default: `console`.\n   * @param options.maxEventListeners - The maximum number of event\n   * listeners. Default: 100.\n   * @param options.rpcMiddleware - The RPC middleware stack. Default: [].\n   */\n  constructor({\n    logger = console,\n    maxEventListeners = 100,\n    rpcMiddleware = [],\n  }: BaseProviderOptions = {}) {\n    super();\n\n    this._log = logger;\n\n    this.setMaxListeners(maxEventListeners);\n\n    // Private state\n    this._state = {\n      ...BaseProvider._defaultState,\n    };\n\n    // Public state\n    this.#selectedAddress = null;\n    this.#chainId = null;\n\n    // Bind functions to prevent consumers from making unbound calls\n    this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n    this._handleConnect = this._handleConnect.bind(this);\n    this._handleChainChanged = this._handleChainChanged.bind(this);\n    this._handleDisconnect = this._handleDisconnect.bind(this);\n    this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n    this._rpcRequest = this._rpcRequest.bind(this);\n    this.request = this.request.bind(this);\n\n    // Handle RPC requests via dapp-side RPC engine.\n    //\n    // ATTN: Implementers must push a middleware that hands off requests to\n    // the server.\n    const rpcEngine = new JsonRpcEngine();\n    rpcMiddleware.forEach((middleware) => rpcEngine.push(middleware));\n    this._rpcEngine = rpcEngine;\n  }\n\n  //====================\n  // Public Properties\n  //====================\n\n  get chainId(): string | null {\n    return this.#chainId;\n  }\n\n  get selectedAddress(): string | null {\n    return this.#selectedAddress;\n  }\n\n  //====================\n  // Public Methods\n  //====================\n\n  /**\n   * Returns whether the provider can process RPC requests.\n   *\n   * @returns Whether the provider can process RPC requests.\n   */\n  isConnected(): boolean {\n    return this._state.isConnected;\n  }\n\n  /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   *\n   * @param args - The RPC request arguments.\n   * @param args.method - The RPC method name.\n   * @param args.params - The parameters for the RPC method.\n   * @returns A Promise that resolves with the result of the RPC method,\n   * or rejects if an error is encountered.\n   */\n  async request<Type>(args: RequestArguments): Promise<Maybe<Type>> {\n    if (!args || typeof args !== 'object' || Array.isArray(args)) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestArgs(),\n        data: args,\n      });\n    }\n\n    const { method, params } = args;\n\n    if (typeof method !== 'string' || method.length === 0) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestMethod(),\n        data: args,\n      });\n    }\n\n    if (\n      params !== undefined &&\n      !Array.isArray(params) &&\n      (typeof params !== 'object' || params === null)\n    ) {\n      throw rpcErrors.invalidRequest({\n        message: messages.errors.invalidRequestParams(),\n        data: args,\n      });\n    }\n\n    const payload =\n      params === undefined || params === null\n        ? {\n            method,\n          }\n        : {\n            method,\n            params,\n          };\n\n    return new Promise<Type>((resolve, reject) => {\n      this._rpcRequest(payload, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  //====================\n  // Private Methods\n  //====================\n\n  /**\n   * MUST be called by child classes.\n   *\n   * Sets initial state if provided and marks this provider as initialized.\n   * Throws if called more than once.\n   *\n   * Permits the `networkVersion` field in the parameter object for\n   * compatibility with child classes that use this value.\n   *\n   * @param initialState - The provider's initial state.\n   * @param initialState.accounts - The user's accounts.\n   * @param initialState.chainId - The chain ID.\n   * @param initialState.isUnlocked - Whether the user has unlocked MetaMask.\n   * @param initialState.networkVersion - The network version.\n   * @fires BaseProvider#_initialized - If `initialState` is defined.\n   * @fires BaseProvider#connect - If `initialState` is defined.\n   */\n  protected _initializeState(initialState?: {\n    accounts: string[];\n    chainId: string;\n    isUnlocked: boolean;\n    networkVersion?: string;\n  }) {\n    if (this._state.initialized) {\n      throw new Error('Provider already initialized.');\n    }\n\n    if (initialState) {\n      const { accounts, chainId, isUnlocked, networkVersion } = initialState;\n\n      // EIP-1193 connect\n      this._handleConnect(chainId);\n      this._handleChainChanged({ chainId, networkVersion });\n      this._handleUnlockStateChanged({ accounts, isUnlocked });\n      this._handleAccountsChanged(accounts);\n    }\n\n    // Mark provider as initialized regardless of whether initial state was\n    // retrieved.\n    this._state.initialized = true;\n    this.emit('_initialized');\n  }\n\n  /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound.\n   *\n   * @param payload - The RPC request object.\n   * @param callback - The consumer's callback.\n   * @returns The result of the RPC request.\n   */\n  protected _rpcRequest(\n    payload: UnvalidatedJsonRpcRequest | UnvalidatedJsonRpcRequest[],\n    callback: (...args: any[]) => void,\n  ) {\n    let callbackWrapper = callback;\n\n    if (!Array.isArray(payload)) {\n      if (!payload.jsonrpc) {\n        payload.jsonrpc = '2.0';\n      }\n\n      if (\n        payload.method === 'eth_accounts' ||\n        payload.method === 'eth_requestAccounts'\n      ) {\n        // handle accounts changing\n        callbackWrapper = (\n          error: Error,\n          response: JsonRpcSuccess<string[]>,\n        ) => {\n          this._handleAccountsChanged(\n            response.result ?? [],\n            payload.method === 'eth_accounts',\n          );\n          callback(error, response);\n        };\n      }\n      return this._rpcEngine.handle(payload as JsonRpcRequest, callbackWrapper);\n    }\n    return this._rpcEngine.handle(payload as JsonRpcRequest[], callbackWrapper);\n  }\n\n  /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * @fires MetaMaskInpageProvider#connect\n   */\n  protected _handleConnect(chainId: string) {\n    if (!this._state.isConnected) {\n      this._state.isConnected = true;\n      this.emit('connect', { chainId });\n      this._log.debug(messages.info.connected(chainId));\n    }\n  }\n\n  /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes.\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * @fires BaseProvider#disconnect - If the disconnection is not recoverable.\n   */\n  protected _handleDisconnect(isRecoverable: boolean, errorMessage?: string) {\n    if (\n      this._state.isConnected ||\n      (!this._state.isPermanentlyDisconnected && !isRecoverable)\n    ) {\n      this._state.isConnected = false;\n\n      let error;\n      if (isRecoverable) {\n        error = new JsonRpcError(\n          1013, // Try again later\n          errorMessage ?? messages.errors.disconnected(),\n        );\n        this._log.debug(error);\n      } else {\n        error = new JsonRpcError(\n          1011, // Internal error\n          errorMessage ?? messages.errors.permanentlyDisconnected(),\n        );\n        this._log.error(error);\n        this.#chainId = null;\n        this._state.accounts = null;\n        this.#selectedAddress = null;\n        this._state.isUnlocked = false;\n        this._state.isPermanentlyDisconnected = true;\n      }\n\n      this.emit('disconnect', error);\n    }\n  }\n\n  /**\n   * Upon receipt of a new `chainId`, emits the corresponding event and sets\n   * and sets relevant public state. Does nothing if the given `chainId` is\n   * equivalent to the existing value.\n   *\n   * Permits the `networkVersion` field in the parameter object for\n   * compatibility with child classes that use this value.\n   *\n   * @fires BaseProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   * @param networkInfo.chainId - The latest chain ID.\n   */\n  protected _handleChainChanged({\n    chainId,\n  }:\n    | { chainId?: string | undefined; networkVersion?: string | undefined }\n    | undefined = {}) {\n    if (!isValidChainId(chainId)) {\n      this._log.error(messages.errors.invalidNetworkParams(), { chainId });\n      return;\n    }\n\n    this._handleConnect(chainId);\n\n    if (chainId !== this.#chainId) {\n      this.#chainId = chainId;\n      if (this._state.initialized) {\n        this.emit('chainChanged', this.#chainId);\n      }\n    }\n  }\n\n  /**\n   * Called when accounts may have changed. Diffs the new accounts value with\n   * the current one, updates all state as necessary, and emits the\n   * accountsChanged event.\n   *\n   * @param accounts - The new accounts value.\n   * @param isEthAccounts - Whether the accounts value was returned by\n   * a call to eth_accounts.\n   */\n  protected _handleAccountsChanged(\n    accounts: unknown[],\n    isEthAccounts = false,\n  ): void {\n    let _accounts = accounts;\n\n    if (!Array.isArray(accounts)) {\n      this._log.error(\n        'MetaMask: Received invalid accounts parameter. Please report this bug.',\n        accounts,\n      );\n      _accounts = [];\n    }\n\n    for (const account of accounts) {\n      if (typeof account !== 'string') {\n        this._log.error(\n          'MetaMask: Received non-string account. Please report this bug.',\n          accounts,\n        );\n        _accounts = [];\n        break;\n      }\n    }\n\n    // emit accountsChanged if anything about the accounts array has changed\n    if (!dequal(this._state.accounts, _accounts)) {\n      // we should always have the correct accounts even before eth_accounts\n      // returns\n      if (isEthAccounts && this._state.accounts !== null) {\n        this._log.error(\n          `MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.`,\n          _accounts,\n        );\n      }\n\n      this._state.accounts = _accounts as string[];\n\n      // handle selectedAddress\n      if (this.#selectedAddress !== _accounts[0]) {\n        this.#selectedAddress = (_accounts[0] as string) || null;\n      }\n\n      // finally, after all state has been updated, emit the event\n      if (this._state.initialized) {\n        const _nextAccounts = [..._accounts];\n        this.emit('accountsChanged', _nextAccounts);\n      }\n    }\n  }\n\n  /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   * @param opts.accounts - The exposed accounts, if any.\n   * @param opts.isUnlocked - The latest isUnlocked value.\n   */\n  protected _handleUnlockStateChanged({\n    accounts,\n    isUnlocked,\n  }: { accounts?: string[]; isUnlocked?: boolean } = {}) {\n    if (typeof isUnlocked !== 'boolean') {\n      this._log.error(\n        'MetaMask: Received invalid isUnlocked parameter. Please report this bug.',\n      );\n      return;\n    }\n\n    if (isUnlocked !== this._state.isUnlocked) {\n      this._state.isUnlocked = isUnlocked;\n      this._handleAccountsChanged(accounts ?? []);\n    }\n  }\n}\n"],"mappings":"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","names":[]}