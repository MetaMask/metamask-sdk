{"version":3,"sources":["../src/fs.ts"],"sourcesContent":["// This file is intended to be used only in a Node.js context.\n/* eslint-disable import/no-nodejs-modules */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport { isErrorWithCode, wrapError } from './errors';\nimport type { Json } from './json';\n\n/**\n * Information about the file sandbox provided to tests that need temporary\n * access to the filesystem.\n */\nexport type FileSandbox = {\n  directoryPath: string;\n  withinSandbox: (\n    test: (args: { directoryPath: string }) => Promise<void>,\n  ) => Promise<void>;\n};\n\n/**\n * Read the file at the given path, assuming its content is encoded as UTF-8.\n *\n * @param filePath - The path to the file.\n * @returns The content of the file.\n * @throws An error with a stack trace if reading fails in any way.\n */\nexport async function readFile(filePath: string): Promise<string> {\n  try {\n    return await fs.promises.readFile(filePath, 'utf8');\n  } catch (error) {\n    throw wrapError(error, `Could not read file '${filePath}'`);\n  }\n}\n\n/**\n * Write content to the file at the given path, creating the directory structure\n * for the file automatically if necessary.\n *\n * @param filePath - The path to the file.\n * @param content - The new content of the file.\n * @throws An error with a stack trace if writing fails in any way.\n */\nexport async function writeFile(\n  filePath: string,\n  content: string,\n): Promise<void> {\n  try {\n    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n    await fs.promises.writeFile(filePath, content);\n  } catch (error) {\n    throw wrapError(error, `Could not write file '${filePath}'`);\n  }\n}\n\n/**\n * Read the assumed JSON file at the given path, attempts to parse it, and\n * get the resulting object. Supports a custom parser (in case you want to\n * use the [JSON5](https://www.npmjs.com/package/json5) package instead).\n *\n * @param filePath - The path segments pointing to the JSON file. Will be passed\n * to path.join().\n * @param options - Options to this function.\n * @param options.parser - The parser object to use. Defaults to `JSON`.\n * @param options.parser.parse - A function that parses JSON data.\n * @returns The object corresponding to the parsed JSON file, typed against the\n * struct.\n * @throws An error with a stack trace if reading fails in any way, or if the\n * parsed value is not a plain object.\n */\nexport async function readJsonFile<Value extends Json>(\n  filePath: string,\n  {\n    parser = JSON,\n  }: {\n    parser?: {\n      parse: (\n        text: Parameters<typeof JSON.parse>[0],\n      ) => ReturnType<typeof JSON.parse>;\n    };\n  } = {},\n): Promise<Value> {\n  try {\n    const content = await fs.promises.readFile(filePath, 'utf8');\n    return parser.parse(content);\n  } catch (error) {\n    throw wrapError(error, `Could not read JSON file '${filePath}'`);\n  }\n}\n\n/**\n * Attempt to write the given JSON-like value to the file at the given path,\n * creating the directory structure for the file automatically if necessary.\n * Adds a newline to the end of the file. Supports a custom parser (in case you\n * want to use the [JSON5](https://www.npmjs.com/package/json5) package\n * instead).\n *\n * @param filePath - The path to write the JSON file to, including the file\n * itself.\n * @param jsonValue - The JSON-like value to write to the file. Make sure that\n * JSON.stringify can handle it.\n * @param options - The options to this function.\n * @param options.prettify - Whether to format the JSON as it is turned into a\n * string such that it is broken up into separate lines (using 2 spaces as\n * indentation).\n * @param options.stringifier - The stringifier to use. Defaults to `JSON`.\n * @param options.stringifier.stringify - A function that stringifies JSON.\n * @returns The object corresponding to the parsed JSON file, typed against the\n * struct.\n * @throws An error with a stack trace if writing fails in any way.\n */\nexport async function writeJsonFile(\n  filePath: string,\n  jsonValue: Json,\n  {\n    stringifier = JSON,\n    prettify = false,\n  }: {\n    stringifier?: {\n      stringify: typeof JSON.stringify;\n    };\n    prettify?: boolean;\n  } = {},\n): Promise<void> {\n  try {\n    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n    const json = prettify\n      ? stringifier.stringify(jsonValue, null, '  ')\n      : stringifier.stringify(jsonValue);\n    await fs.promises.writeFile(filePath, json);\n  } catch (error) {\n    throw wrapError(error, `Could not write JSON file '${filePath}'`);\n  }\n}\n\n/**\n * Test the given path to determine whether it represents a file.\n *\n * @param filePath - The path to a (supposed) file on the filesystem.\n * @returns A promise for true if the file exists or false otherwise.\n * @throws An error with a stack trace if reading fails in any way.\n */\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    const stats = await fs.promises.stat(filePath);\n    return stats.isFile();\n  } catch (error) {\n    if (isErrorWithCode(error) && error.code === 'ENOENT') {\n      return false;\n    }\n\n    throw wrapError(error, `Could not determine if file exists '${filePath}'`);\n  }\n}\n\n/**\n * Test the given path to determine whether it represents a directory.\n *\n * @param directoryPath - The path to a (supposed) directory on the filesystem.\n * @returns A promise for true if the file exists or false otherwise.\n * @throws An error with a stack trace if reading fails in any way.\n */\nexport async function directoryExists(directoryPath: string): Promise<boolean> {\n  try {\n    const stats = await fs.promises.stat(directoryPath);\n    return stats.isDirectory();\n  } catch (error) {\n    if (isErrorWithCode(error) && error.code === 'ENOENT') {\n      return false;\n    }\n\n    throw wrapError(\n      error,\n      `Could not determine if directory exists '${directoryPath}'`,\n    );\n  }\n}\n\n/**\n * Create the given directory along with any directories leading up to the\n * directory, or do nothing if the directory already exists.\n *\n * @param directoryPath - The path to the desired directory.\n * @throws An error with a stack trace if reading fails in any way.\n */\nexport async function ensureDirectoryStructureExists(\n  directoryPath: string,\n): Promise<void> {\n  try {\n    await fs.promises.mkdir(directoryPath, { recursive: true });\n  } catch (error) {\n    throw wrapError(\n      error,\n      `Could not create directory structure '${directoryPath}'`,\n    );\n  }\n}\n\n/**\n * Remove the given file or directory if it exists, or do nothing if it does\n * not.\n *\n * @param entryPath - The path to the file or directory.\n * @throws An error with a stack trace if removal fails in any way.\n */\nexport async function forceRemove(entryPath: string): Promise<void> {\n  try {\n    return await fs.promises.rm(entryPath, {\n      recursive: true,\n      force: true,\n    });\n  } catch (error) {\n    throw wrapError(error, `Could not remove file or directory '${entryPath}'`);\n  }\n}\n\n/**\n * Construct a sandbox object which can be used in tests that need temporary\n * access to the filesystem.\n *\n * @param projectName - The name of the project.\n * @returns The sandbox object. This contains a `withinSandbox` function which\n * can be used in tests (see example).\n * @example\n * ```typescript\n * const { withinSandbox } = createSandbox('utils');\n *\n * // ... later ...\n *\n * it('does something with the filesystem', async () => {\n *   await withinSandbox(async ({ directoryPath }) => {\n *     await fs.promises.writeFile(\n *       path.join(directoryPath, 'some-file'),\n *       'some content',\n *       'utf8'\n *     );\n *   })\n * });\n * ```\n */\nexport function createSandbox(projectName: string): FileSandbox {\n  const timestamp = new Date().getTime();\n  const directoryPath = path.join(os.tmpdir(), `${projectName}--${timestamp}`);\n\n  return {\n    directoryPath,\n    async withinSandbox(\n      test: (args: { directoryPath: string }) => Promise<void>,\n    ) {\n      if (await directoryExists(directoryPath)) {\n        throw new Error(`${directoryPath} already exists. Cannot continue.`);\n      }\n\n      await ensureDirectoryStructureExists(directoryPath);\n\n      try {\n        await test({ directoryPath });\n      } finally {\n        await forceRemove(directoryPath);\n      }\n    },\n  };\n}\n"],"mappings":"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","names":[]}