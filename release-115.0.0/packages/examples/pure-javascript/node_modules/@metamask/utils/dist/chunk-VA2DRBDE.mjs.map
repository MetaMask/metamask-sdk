{"version":3,"sources":["../src/hex.ts","../src/bytes.ts"],"sourcesContent":["import { keccak_256 as keccak256 } from '@noble/hashes/sha3';\nimport type { Struct } from 'superstruct';\nimport { is, pattern, string } from 'superstruct';\n\nimport { assert } from './assert';\nimport { bytesToHex } from './bytes';\n\nexport type Hex = `0x${string}`;\n\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu) as Struct<\n  Hex,\n  null\n>;\nexport const HexAddressStruct = pattern(\n  string(),\n  /^0x[0-9a-f]{40}$/u,\n) as Struct<Hex, null>;\nexport const HexChecksumAddressStruct = pattern(\n  string(),\n  /^0x[0-9a-fA-F]{40}$/u,\n) as Struct<Hex, null>;\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return is(value, HexStruct);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return is(value, StrictHexStruct);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddress(possibleAddress: Hex) {\n  return (\n    is(possibleAddress, HexAddressStruct) ||\n    isValidChecksumAddress(possibleAddress)\n  );\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddress(address: Hex) {\n  assert(is(address, HexChecksumAddressStruct), 'Invalid hex address.');\n  const unPrefixed = remove0x(address.toLowerCase());\n  const unPrefixedHash = remove0x(bytesToHex(keccak256(unPrefixed)));\n  return `0x${unPrefixed\n    .split('')\n    .map((character, nibbleIndex) => {\n      const hashCharacter = unPrefixedHash[nibbleIndex];\n      assert(is(hashCharacter, string()), 'Hash shorter than address.');\n      return parseInt(hashCharacter, 16) > 7\n        ? character.toUpperCase()\n        : character;\n    })\n    .join('')}`;\n}\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddress(possibleChecksum: Hex) {\n  if (!is(possibleChecksum, HexChecksumAddressStruct)) {\n    return false;\n  }\n\n  return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n","import { base64 } from '@scure/base';\n\nimport { assert } from './assert';\nimport type { Hex } from './hex';\nimport { add0x, assertIsHexString, remove0x } from './hex';\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n\nexport type Bytes = bigint | number | string | Uint8Array;\n\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder(): () => string[] {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable: string[] = [];\n\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n\n    return lookupTable;\n  };\n}\n\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nexport function isBytes(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nexport function assertIsBytes(value: unknown): asserts value is Uint8Array {\n  assert(isBytes(value), 'Value must be a Uint8Array.');\n}\n\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  assertIsBytes(bytes);\n\n  if (bytes.length === 0) {\n    return '0x';\n  }\n\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]!];\n  }\n\n  return add0x(hexadecimal.join(''));\n}\n\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\n\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nexport function bytesToSignedBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bytes.length * 8, value);\n}\n\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nexport function bytesToNumber(bytes: Uint8Array): number {\n  assertIsBytes(bytes);\n\n  const bigint = bytesToBigInt(bytes);\n\n  assert(\n    bigint <= BigInt(Number.MAX_SAFE_INTEGER),\n    'Number is not a safe integer. Use `bytesToBigInt` instead.',\n  );\n\n  return Number(bigint);\n}\n\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nexport function bytesToString(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nexport function bytesToBase64(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return base64.encode(bytes);\n}\n\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function hexToBytes(value: string): Uint8Array {\n  // \"0x\" is often used as empty byte array.\n  if (value?.toLowerCase?.() === '0x') {\n    return new Uint8Array();\n  }\n\n  assertIsHexString(value);\n\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = remove0x(value).toLowerCase();\n  const normalizedValue =\n    strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 =\n      c1 -\n      (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n    const n2 =\n      c2 -\n      (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function bigIntToBytes(value: bigint): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= BigInt(0), 'Value must be a non-negative bigint.');\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value: bigint, bytes: number): boolean {\n  assert(bytes > 0);\n\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nexport function signedBigIntToBytes(\n  value: bigint,\n  byteLength: number,\n): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(typeof byteLength === 'number', 'Byte length must be a number.');\n  assert(byteLength > 0, 'Byte length must be greater than 0.');\n  assert(\n    bigIntFits(value, byteLength),\n    'Byte length is too small to represent the given value.',\n  );\n\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n\n  return bytes.reverse();\n}\n\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nexport function numberToBytes(value: number): Uint8Array {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToBytes` instead.',\n  );\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function stringToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function base64ToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return base64.decode(value);\n}\n\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function valueToBytes(value: Bytes): Uint8Array {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n\n    return stringToBytes(value);\n  }\n\n  if (isBytes(value)) {\n    return value;\n  }\n\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nexport function concatBytes(values: Bytes[]): Uint8Array {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]!);\n\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n\n  return bytes;\n}\n\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nexport function createDataView(bytes: Uint8Array): DataView {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(\n      bytes.byteOffset,\n      bytes.byteOffset + bytes.byteLength,\n    );\n\n    return new DataView(buffer);\n  }\n\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n"],"mappings":"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","names":[]}