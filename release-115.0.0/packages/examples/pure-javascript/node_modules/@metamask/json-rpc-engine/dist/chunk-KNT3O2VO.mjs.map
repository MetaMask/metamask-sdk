{"version":3,"sources":["../src/createAsyncMiddleware.ts"],"sourcesContent":["import type {\n  Json,\n  JsonRpcParams,\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\n\nimport type {\n  JsonRpcEngineReturnHandler,\n  JsonRpcMiddleware,\n} from './JsonRpcEngine';\n\nexport type AsyncJsonRpcEngineNextCallback = () => Promise<void>;\n\nexport type AsyncJsonrpcMiddleware<\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = (\n  request: JsonRpcRequest<Params>,\n  response: PendingJsonRpcResponse<Result>,\n  next: AsyncJsonRpcEngineNextCallback,\n) => Promise<void>;\n\ntype ReturnHandlerCallback = Parameters<JsonRpcEngineReturnHandler>[0];\n\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n *\n * @param asyncMiddleware - The asynchronous middleware function to wrap.\n * @returns The wrapped asynchronous middleware function, ready to be consumed\n * by JsonRpcEngine.\n */\nexport function createAsyncMiddleware<\n  Params extends JsonRpcParams,\n  Result extends Json,\n>(\n  asyncMiddleware: AsyncJsonrpcMiddleware<Params, Result>,\n): JsonRpcMiddleware<Params, Result> {\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return async (request, response, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise: () => void;\n    const nextPromise = new Promise<void>((resolve) => {\n      resolveNextPromise = resolve;\n    });\n\n    let returnHandlerCallback: unknown = null;\n    let nextWasCalled = false;\n\n    // This will be called by the consumer's async middleware.\n    const asyncNext = async () => {\n      nextWasCalled = true;\n\n      // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n      next((runReturnHandlersCallback) => {\n        // This callback comes from JsonRpcEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      return nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(request, response, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        (returnHandlerCallback as ReturnHandlerCallback)(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        (returnHandlerCallback as ReturnHandlerCallback)(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n"],"mappings":";AA8CO,SAAS,sBAId,iBACmC;AAEnC,SAAO,OAAO,SAAS,UAAU,MAAM,QAAQ;AAI7C,QAAI;AACJ,UAAM,cAAc,IAAI,QAAc,CAAC,YAAY;AACjD,2BAAqB;AAAA,IACvB,CAAC;AAED,QAAI,wBAAiC;AACrC,QAAI,gBAAgB;AAGpB,UAAM,YAAY,YAAY;AAC5B,sBAAgB;AAIhB,WAAK,CAAC,8BAA8B;AAElC,gCAAwB;AACxB,2BAAmB;AAAA,MACrB,CAAC;AACD,aAAO;AAAA,IACT;AAEA,QAAI;AACF,YAAM,gBAAgB,SAAS,UAAU,SAAS;AAElD,UAAI,eAAe;AACjB,cAAM;AACN,QAAC,sBAAgD,IAAI;AAAA,MACvD,OAAO;AACL,YAAI,IAAI;AAAA,MACV;AAAA,IACF,SAAS,OAAO;AACd,UAAI,uBAAuB;AACzB,QAAC,sBAAgD,KAAK;AAAA,MACxD,OAAO;AACL,YAAI,KAAK;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;","names":[]}