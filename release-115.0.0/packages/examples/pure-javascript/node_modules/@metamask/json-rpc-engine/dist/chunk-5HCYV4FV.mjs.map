{"version":3,"sources":["../src/JsonRpcEngine.ts"],"sourcesContent":["import { errorCodes, JsonRpcError, serializeError } from '@metamask/rpc-errors';\nimport SafeEventEmitter from '@metamask/safe-event-emitter';\nimport type {\n  JsonRpcError as SerializedJsonRpcError,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcNotification,\n  Json,\n  JsonRpcParams,\n  PendingJsonRpcResponse,\n} from '@metamask/utils';\nimport {\n  hasProperty,\n  isJsonRpcNotification,\n  isJsonRpcRequest,\n} from '@metamask/utils';\n\nexport type JsonRpcEngineCallbackError = Error | SerializedJsonRpcError | null;\n\nexport type JsonRpcEngineReturnHandler = (\n  done: (error?: unknown) => void,\n) => void;\n\nexport type JsonRpcEngineNextCallback = (\n  returnHandlerCallback?: JsonRpcEngineReturnHandler,\n) => void;\n\nexport type JsonRpcEngineEndCallback = (error?: unknown) => void;\n\nexport type JsonRpcMiddleware<\n  Params extends JsonRpcParams,\n  Result extends Json,\n> = {\n  (\n    req: JsonRpcRequest<Params>,\n    res: PendingJsonRpcResponse<Result>,\n    next: JsonRpcEngineNextCallback,\n    end: JsonRpcEngineEndCallback,\n  ): void;\n  destroy?: () => void | Promise<void>;\n};\n\nconst DESTROYED_ERROR_MESSAGE =\n  'This engine is destroyed and can no longer be used.';\n\nexport type JsonRpcNotificationHandler<Params extends JsonRpcParams> = (\n  notification: JsonRpcNotification<Params>,\n) => void | Promise<void>;\n\ntype JsonRpcEngineArgs = {\n  /**\n   * A function for handling JSON-RPC notifications. A JSON-RPC notification is\n   * defined as a JSON-RPC request without an `id` property. If this option is\n   * _not_ provided, notifications will be treated the same as requests. If this\n   * option _is_ provided, notifications will be passed to the handler\n   * function without touching the engine's middleware stack.\n   *\n   * This function should not throw or reject.\n   */\n  notificationHandler?: JsonRpcNotificationHandler<JsonRpcParams>;\n};\n\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nexport class JsonRpcEngine extends SafeEventEmitter {\n  /**\n   * Indicating whether this engine is destroyed or not.\n   */\n  #isDestroyed = false;\n\n  #middleware: JsonRpcMiddleware<JsonRpcParams, Json>[];\n\n  readonly #notificationHandler?:\n    | JsonRpcNotificationHandler<JsonRpcParams>\n    | undefined;\n\n  /**\n   * Constructs a {@link JsonRpcEngine} instance.\n   *\n   * @param options - Options bag.\n   * @param options.notificationHandler - A function for handling JSON-RPC\n   * notifications. A JSON-RPC notification is defined as a JSON-RPC request\n   * without an `id` property. If this option is _not_ provided, notifications\n   * will be treated the same as requests. If this option _is_ provided,\n   * notifications will be passed to the handler function without touching\n   * the engine's middleware stack. This function should not throw or reject.\n   */\n  constructor({ notificationHandler }: JsonRpcEngineArgs = {}) {\n    super();\n    this.#middleware = [];\n    this.#notificationHandler = notificationHandler;\n  }\n\n  /**\n   * Throws an error if this engine is destroyed.\n   */\n  #assertIsNotDestroyed() {\n    if (this.#isDestroyed) {\n      throw new Error(DESTROYED_ERROR_MESSAGE);\n    }\n  }\n\n  /**\n   * Calls the `destroy()` function of any middleware with that property, clears\n   * the middleware array, and marks this engine as destroyed. A destroyed\n   * engine cannot be used.\n   */\n  destroy(): void {\n    this.#middleware.forEach(\n      (middleware: JsonRpcMiddleware<JsonRpcParams, Json>) => {\n        if (\n          // `in` walks the prototype chain, which is probably the desired\n          // behavior here.\n          'destroy' in middleware &&\n          typeof middleware.destroy === 'function'\n        ) {\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          middleware.destroy();\n        }\n      },\n    );\n    this.#middleware = [];\n    this.#isDestroyed = true;\n  }\n\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push<Params extends JsonRpcParams, Result extends Json>(\n    middleware: JsonRpcMiddleware<Params, Result>,\n  ): void {\n    this.#assertIsNotDestroyed();\n    this.#middleware.push(middleware as JsonRpcMiddleware<JsonRpcParams, Json>);\n  }\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    request: JsonRpcRequest<Params>,\n    callback: (error: unknown, response: JsonRpcResponse<Result>) => void,\n  ): void;\n\n  /**\n   * Handle a JSON-RPC notification.\n   *\n   * @param notification - The notification to handle.\n   * @param callback - An error-first callback that will receive a `void` response.\n   */\n  handle<Params extends JsonRpcParams>(\n    notification: JsonRpcNotification<Params>,\n    callback: (error: unknown, response: void) => void,\n  ): void;\n\n  /**\n   * Handle an array of JSON-RPC requests and/or notifications, and return an\n   * array of responses to any included requests.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    requests: (JsonRpcRequest<Params> | JsonRpcNotification<Params>)[],\n    callback: (error: unknown, responses: JsonRpcResponse<Result>[]) => void,\n  ): void;\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The JSON-RPC request to handle.\n   * @returns The JSON-RPC response.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    request: JsonRpcRequest<Params>,\n  ): Promise<JsonRpcResponse<Result>>;\n\n  /**\n   * Handle a JSON-RPC notification.\n   *\n   * @param notification - The notification to handle.\n   */\n  handle<Params extends JsonRpcParams>(\n    notification: JsonRpcNotification<Params>,\n  ): Promise<void>;\n\n  /**\n   * Handle an array of JSON-RPC requests and/or notifications, and return an\n   * array of responses to any included requests.\n   *\n   * @param request - The JSON-RPC requests to handle.\n   * @returns An array of JSON-RPC responses.\n   */\n  handle<Params extends JsonRpcParams, Result extends Json>(\n    requests: (JsonRpcRequest<Params> | JsonRpcNotification<Params>)[],\n  ): Promise<JsonRpcResponse<Result>[]>;\n\n  handle(\n    req:\n      | (JsonRpcRequest | JsonRpcNotification)[]\n      | JsonRpcRequest\n      | JsonRpcNotification,\n    callback?: (error: unknown, response: never) => void,\n  ) {\n    this.#assertIsNotDestroyed();\n\n    if (callback && typeof callback !== 'function') {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (callback) {\n        return this.#handleBatch(\n          req,\n          // This assertion is safe because of the runtime checks validating that `req` is an array and `callback` is defined.\n          // There is only one overload signature that satisfies both conditions, and its `callback` type is the one that's being asserted.\n          callback as (\n            error: unknown,\n            responses?: JsonRpcResponse<Json>[],\n          ) => void,\n        );\n      }\n      return this.#handleBatch(req);\n    }\n\n    if (callback) {\n      return this.#handle(\n        req,\n        callback as (error: unknown, response?: JsonRpcResponse<Json>) => void,\n      );\n    }\n    return this._promiseHandle(req);\n  }\n\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware(): JsonRpcMiddleware<JsonRpcParams, Json> {\n    this.#assertIsNotDestroyed();\n\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] =\n          await JsonRpcEngine.#runAllMiddleware(req, res, this.#middleware);\n\n        if (isComplete) {\n          await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return next(async (handlerCallback) => {\n          try {\n            await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  #handleBatch(\n    reqs: (JsonRpcRequest | JsonRpcNotification)[],\n  ): Promise<JsonRpcResponse<Json>[]>;\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n  #handleBatch(\n    reqs: (JsonRpcRequest | JsonRpcNotification)[],\n    callback: (error: unknown, responses?: JsonRpcResponse<Json>[]) => void,\n  ): Promise<void>;\n\n  /**\n   * Handles a batch of JSON-RPC requests, either in `async` or callback\n   * fashion.\n   *\n   * @param requests - The request objects to process.\n   * @param callback - The completion callback.\n   * @returns The array of responses, or nothing if a callback was specified.\n   */\n  async #handleBatch(\n    requests: (JsonRpcRequest | JsonRpcNotification)[],\n    callback?: (error: unknown, responses?: JsonRpcResponse<Json>[]) => void,\n  ): Promise<JsonRpcResponse<Json>[] | void> {\n    // The order here is important\n    try {\n      // If the batch is an empty array, the response array must contain a single object\n      if (requests.length === 0) {\n        const response: JsonRpcResponse<Json>[] = [\n          {\n            id: null,\n            jsonrpc: '2.0',\n            error: new JsonRpcError(\n              errorCodes.rpc.invalidRequest,\n              'Request batch must contain plain objects. Received an empty array',\n            ),\n          },\n        ];\n        if (callback) {\n          return callback(null, response);\n        }\n        return response;\n      }\n\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = (\n        await Promise.all(\n          // 1. Begin executing each request in the order received\n          requests.map(this._promiseHandle.bind(this)),\n        )\n      ).filter(\n        // Filter out any notification responses.\n        (response): response is JsonRpcResponse<Json> => response !== undefined,\n      );\n\n      // 3. Return batch response\n      if (callback) {\n        return callback(null, responses);\n      }\n      return responses;\n    } catch (error) {\n      if (callback) {\n        return callback(error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * A promise-wrapped _handle.\n   *\n   * @param request - The JSON-RPC request.\n   * @returns The JSON-RPC response.\n   */\n  // This function is used in tests, so we cannot easily change it to use the\n  // hash syntax.\n  // eslint-disable-next-line no-restricted-syntax\n  private async _promiseHandle(\n    request: JsonRpcRequest | JsonRpcNotification,\n  ): Promise<JsonRpcResponse<Json> | void> {\n    return new Promise((resolve, reject) => {\n      this.#handle(request, (error, res) => {\n        // For notifications, the response will be `undefined`, and any caught\n        // errors are unexpected and should be surfaced to the caller.\n        if (error && res === undefined) {\n          reject(error);\n        } else {\n          // Excepting notifications, there will always be a response, and it will\n          // always have any error that is caught and propagated.\n          resolve(res);\n        }\n      }).catch(reject);\n    });\n  }\n\n  /**\n   * Ensures that the request / notification object is valid, processes it, and\n   * passes any error and response object to the given callback.\n   *\n   * Does not reject.\n   *\n   * @param callerReq - The request object from the caller.\n   * @param callback - The callback function.\n   * @returns Nothing.\n   */\n  async #handle(\n    callerReq: JsonRpcRequest | JsonRpcNotification,\n    callback: (error: unknown, response?: JsonRpcResponse<Json>) => void,\n  ): Promise<void> {\n    if (\n      !callerReq ||\n      Array.isArray(callerReq) ||\n      typeof callerReq !== 'object'\n    ) {\n      const error = new JsonRpcError(\n        errorCodes.rpc.invalidRequest,\n        `Requests must be plain objects. Received: ${typeof callerReq}`,\n        { request: callerReq },\n      );\n      return callback(error, { id: null, jsonrpc: '2.0', error });\n    }\n\n    if (typeof callerReq.method !== 'string') {\n      const error = new JsonRpcError(\n        errorCodes.rpc.invalidRequest,\n        `Must specify a string method. Received: ${typeof callerReq.method}`,\n        { request: callerReq },\n      );\n\n      if (this.#notificationHandler && !isJsonRpcRequest(callerReq)) {\n        // Do not reply to notifications, even if they are malformed.\n        return callback(null);\n      }\n\n      return callback(error, {\n        // Typecast: This could be a notification, but we want to access the\n        // `id` even if it doesn't exist.\n        id: (callerReq as JsonRpcRequest).id ?? null,\n        jsonrpc: '2.0',\n        error,\n      });\n    } else if (\n      this.#notificationHandler &&\n      isJsonRpcNotification(callerReq) &&\n      !isJsonRpcRequest(callerReq)\n    ) {\n      try {\n        await this.#notificationHandler(callerReq);\n      } catch (error) {\n        return callback(error);\n      }\n      return callback(null);\n    }\n    let error = null;\n\n    // Handle requests.\n    // Typecast: Permit missing id's for backwards compatibility.\n    const req = { ...(callerReq as JsonRpcRequest) };\n    const res: PendingJsonRpcResponse<Json> = {\n      id: req.id,\n      jsonrpc: req.jsonrpc,\n    };\n\n    try {\n      await JsonRpcEngine.#processRequest(req, res, this.#middleware);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n\n    return callback(error, res as JsonRpcResponse<Json>);\n  }\n\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   *\n   * @param req - The request object.\n   * @param res - The response object.\n   * @param middlewares - The stack of middleware functions.\n   */\n  static async #processRequest(\n    req: JsonRpcRequest,\n    res: PendingJsonRpcResponse<Json>,\n    middlewares: JsonRpcMiddleware<JsonRpcParams, Json>[],\n  ): Promise<void> {\n    const [error, isComplete, returnHandlers] =\n      await JsonRpcEngine.#runAllMiddleware(req, res, middlewares);\n\n    // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n    JsonRpcEngine.#checkForCompletion(req, res, isComplete);\n\n    // The return handlers should run even if an error was encountered during\n    // middleware processing.\n    await JsonRpcEngine.#runReturnHandlers(returnHandlers);\n\n    // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n    if (error) {\n      // eslint-disable-next-line @typescript-eslint/no-throw-literal\n      throw error;\n    }\n  }\n\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @param req - The request object.\n   * @param res - The response object.\n   * @param middlewares - The stack of middleware functions to execute.\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static async #runAllMiddleware(\n    req: JsonRpcRequest,\n    res: PendingJsonRpcResponse<Json>,\n    middlewares: JsonRpcMiddleware<JsonRpcParams, Json>[],\n  ): Promise<\n    [\n      unknown, // error\n      boolean, // isComplete\n      JsonRpcEngineReturnHandler[],\n    ]\n  > {\n    const returnHandlers: JsonRpcEngineReturnHandler[] = [];\n    let error = null;\n    let isComplete = false;\n\n    // Go down stack of middleware, call and collect optional returnHandlers\n    for (const middleware of middlewares) {\n      [error, isComplete] = await JsonRpcEngine.#runMiddleware(\n        req,\n        res,\n        middleware,\n        returnHandlers,\n      );\n\n      if (isComplete) {\n        break;\n      }\n    }\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n\n  /**\n   * Runs an individual middleware function.\n   *\n   * @param request - The request object.\n   * @param response - The response object.\n   * @param middleware - The middleware function to execute.\n   * @param returnHandlers - The return handlers array for the current request.\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n  static async #runMiddleware(\n    request: JsonRpcRequest,\n    response: PendingJsonRpcResponse<Json>,\n    middleware: JsonRpcMiddleware<JsonRpcParams, Json>,\n    returnHandlers: JsonRpcEngineReturnHandler[],\n  ): Promise<[unknown, boolean]> {\n    return new Promise((resolve) => {\n      const end: JsonRpcEngineEndCallback = (error) => {\n        const parsedError = error || response.error;\n        if (parsedError) {\n          response.error = serializeError(parsedError);\n        }\n        // True indicates that the request should end\n        resolve([parsedError, true]);\n      };\n\n      const next: JsonRpcEngineNextCallback = (\n        returnHandler?: JsonRpcEngineReturnHandler,\n      ) => {\n        if (response.error) {\n          end(response.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== 'function') {\n              end(\n                new JsonRpcError(\n                  errorCodes.rpc.internal,\n                  `JsonRpcEngine: \"next\" return handlers must be functions. ` +\n                    `Received \"${typeof returnHandler}\" for request:\\n${jsonify(\n                      request,\n                    )}`,\n                  { request },\n                ),\n              );\n            }\n            returnHandlers.push(returnHandler);\n          }\n\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(request, response, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   *\n   * @param handlers - The return handlers to execute.\n   */\n  static async #runReturnHandlers(\n    handlers: JsonRpcEngineReturnHandler[],\n  ): Promise<void> {\n    for (const handler of handlers) {\n      await new Promise<void>((resolve, reject) => {\n        handler((error) => (error ? reject(error) : resolve()));\n      });\n    }\n  }\n\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   *\n   * @param request - The request object.\n   * @param response - The response object.\n   * @param isComplete - Boolean from {@link JsonRpcEngine.#runAllMiddleware}\n   * indicating whether a middleware ended the request.\n   */\n  static #checkForCompletion(\n    request: JsonRpcRequest,\n    response: PendingJsonRpcResponse<Json>,\n    isComplete: boolean,\n  ): void {\n    if (!hasProperty(response, 'result') && !hasProperty(response, 'error')) {\n      throw new JsonRpcError(\n        errorCodes.rpc.internal,\n        `JsonRpcEngine: Response has no error or result for request:\\n${jsonify(\n          request,\n        )}`,\n        { request },\n      );\n    }\n\n    if (!isComplete) {\n      throw new JsonRpcError(\n        errorCodes.rpc.internal,\n        `JsonRpcEngine: Nothing ended request:\\n${jsonify(request)}`,\n        { request },\n      );\n    }\n  }\n}\n\n/**\n * JSON-stringifies a request object.\n *\n * @param request - The request object to JSON-stringify.\n * @returns The JSON-stringified request object.\n */\nfunction jsonify(request: JsonRpcRequest): string {\n  return JSON.stringify(request, null, 2);\n}\n"],"mappings":"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","names":["_a","error"]}