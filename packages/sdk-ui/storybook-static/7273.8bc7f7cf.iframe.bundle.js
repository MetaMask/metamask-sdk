(self.webpackChunk_metamask_sdk_ui=self.webpackChunk_metamask_sdk_ui||[]).push([[7273,3416],{"./src/utils/address/index.test.ts":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{var _asyncToGenerator2=__webpack_require__("./node_modules/@babel/runtime/helpers/interopRequireDefault.js")(__webpack_require__("./node_modules/@babel/runtime/helpers/asyncToGenerator.js")),_=__webpack_require__("./src/utils/address/index.ts");describe("isENS",(function(){it("should return false by default",(function(){expect((0,_.isENS)()).toBe(!1)})),it("should return true for normal domain",(function(){expect((0,_.isENS)("ricky.codes")).toBe(!0)})),it("should return true for ens",(function(){expect((0,_.isENS)("rickycodes.eth")).toBe(!0)})),it("should return true for eth ens",(function(){expect((0,_.isENS)("ricky.eth.eth")).toBe(!0)})),it("should return true for metamask ens",(function(){expect((0,_.isENS)("ricky.metamask.eth")).toBe(!0)}))})),describe("renderSlightlyLongAddress",(function(){var mockAddress="0xC4955C0d639D99699Bfd7Ec54d9FaFEe40e4D272";it("should return the address when the address do not exist",(function(){expect((0,_.renderSlightlyLongAddress)(null)).toBeNull()})),it("should return 5 characters before ellipsis and 4 final characters of the address after the ellipsis",(function(){expect((0,_.renderSlightlyLongAddress)(mockAddress).split(".")[0].length).toBe(24),expect((0,_.renderSlightlyLongAddress)(mockAddress).split(".")[3].length).toBe(4)})),it("should return 0xC4955 before ellipsis and 4D272 after the ellipsis",(function(){expect((0,_.renderSlightlyLongAddress)(mockAddress,5,2).split(".")[0]).toBe("0xC4955"),expect((0,_.renderSlightlyLongAddress)(mockAddress,5,0).split(".")[3]).toBe("4D272")}))})),describe("formatAddress",(function(){var mockAddress="0xC4955C0d639D99699Bfd7Ec54d9FaFEe40e4D272";it("should return address formatted for short type",(function(){expect((0,_.formatAddress)(mockAddress,"short")).toBe("0xC495...D272")})),it("should return address formatted for mid type",(function(){expect((0,_.formatAddress)(mockAddress,"mid")).toBe("0xC4955C0d639D99699Bfd7E...D272")}))})),describe("isValidHexAddress",(function(){it("should return true if all characters are lower case",(function(){expect((0,_.isValidHexAddress)("0x87187657b35f461d0ceec338d9b8e944a193afe2",{mixedCaseUseChecksum:!0})).toBe(!0)})),it("should return true if all characters are upper case",(function(){expect((0,_.isValidHexAddress)("0x87187657B35F461D0CEEC338D9B8E944A193AFE2",{mixedCaseUseChecksum:!0})).toBe(!0)})),it("should return false if the characters are mixed case and the checksum is invalid",(function(){expect((0,_.isValidHexAddress)("0x87187657b35f461d0ceEc338d9B8e944A193afe2",{mixedCaseUseChecksum:!0})).toBe(!1)})),it("should return true if the characters are mixed case and the checksum is valid",(function(){expect((0,_.isValidHexAddress)("0x87187657b35F461D0Ceec338d9b8E944a193aFE2",{mixedCaseUseChecksum:!0})).toBe(!0)})),it("should return false if the address is an  empty string",(function(){expect((0,_.isValidHexAddress)("",{mixedCaseUseChecksum:!0})).toBe(!1)}))})),describe("isValidAddressInputViaQRCode",(function(){it("should be valid to use the ethereum keyword followed by an address and chain id",(function(){expect((0,_.isValidAddressInputViaQRCode)("ethereum:0x2990079bcdEe240329a520d2444386FC119da21a@1")).toBe(!0)})),it("should be valid to use the ethereum keyword followed by an address",(function(){expect((0,_.isValidAddressInputViaQRCode)("ethereum:0x2990079bcdEe240329a520d2444386FC119da21a")).toBe(!0)})),it("should be invalid to use the ethereum keyword followed by an wrong address",(function(){expect((0,_.isValidAddressInputViaQRCode)("ethereum:0x2990079bcdEe240329a520d2444386FC119d")).toBe(!1)})),it("should be invalid to only have the ethereum keyword",(function(){expect((0,_.isValidAddressInputViaQRCode)("ethereum:")).toBe(!1)})),it("should be valid to only have the address",(function(){expect((0,_.isValidAddressInputViaQRCode)("0x2990079bcdEe240329a520d2444386FC119da21a")).toBe(!0)})),it("should be invalid to have an URL",(function(){expect((0,_.isValidAddressInputViaQRCode)("https://www.metamask.io")).toBe(!1)}))})),describe("stripHexPrefix",(function(){var stripped="4cfd3e90fc78b0f86bf7524722150bb8da9c60cd532564d7ff43f5716514f553";it("returns a string without a hex prefix",(function(){expect((0,_.stripHexPrefix)("0x4cfd3e90fc78b0f86bf7524722150bb8da9c60cd532564d7ff43f5716514f553")).toBe(stripped)})),it("returns the same string since there is no hex prefix",(function(){expect((0,_.stripHexPrefix)(stripped)).toBe(stripped)}))})),describe("getAddress",(function(){var validAddress="0x87187657B35F461D0CEEC338D9B8E944A193AFE2";it("should resolve ENS if ENS is valid",(0,_asyncToGenerator2.default)((function*(){var doENSLookup=jest.fn();yield doENSLookup("test.eth","1"),expect(doENSLookup).toHaveBeenCalledWith("test.eth","1")}))),it("should return address if address is valid",(0,_asyncToGenerator2.default)((function*(){var response=yield(0,_.getAddress)(validAddress,"1");expect(response).toBe(validAddress)}))),it("should return null if address is invalid",(0,_asyncToGenerator2.default)((function*(){var response=yield(0,_.getAddress)("0x87187657B35F461D0CEEC338D9B8E944A193AFE","1");expect(response).toBe(null)})))})),describe("shouldShowBlockExplorer",(function(){var networkConfigurations={networkId1:{chainId:"1",nickname:"Main Ethereum Network",rpcUrl:"https://mainnet.infura.io/v3/123",rpcPrefs:{}}};it("returns true if provider type is not rpc",(function(){var providerRpcTarget=networkConfigurations.networkId1.rpcUrl,result=(0,_.shouldShowBlockExplorer)({providerType:"mainnet",providerRpcTarget,networkConfigurations});expect(result).toBe(!0)})),it("returns block explorer URL if defined",(function(){var providerRpcTarget=networkConfigurations.networkId1.rpcUrl;networkConfigurations.networkId1.rpcPrefs={blockExplorerUrl:"https://rpc.testnet.fantom.network"};var result=(0,_.shouldShowBlockExplorer)({providerType:"rpc",providerRpcTarget,networkConfigurations});expect(result).toBe("https://rpc.testnet.fantom.network")})),it("returns undefined if block explorer URL is not defined",(function(){var providerRpcTarget=networkConfigurations.networkId1.rpcUrl;networkConfigurations.networkId1.rpcPrefs={};var result=(0,_.shouldShowBlockExplorer)({providerType:"rpc",providerRpcTarget,networkConfigurations});expect(result).toBe(void 0)}))})),describe("isQRHardwareAccount",(function(){it("should return false if argument address is undefined",(function(){expect((0,_.isQRHardwareAccount)(void 0)).toBeFalsy()})),it("should return false if address does not exist on keyring",(function(){expect((0,_.isQRHardwareAccount)("address-stub")).toBeFalsy()})),it("should return false if address is from keyring type simple",(function(){expect((0,_.isQRHardwareAccount)("0xd018538C87232FF95acbCe4870629b75640a78E7")).toBeFalsy()})),it("should return false if address is from keyring type hd",(function(){expect((0,_.isQRHardwareAccount)("0x71C7656EC7ab88b098defB751B7401B5f6d8976F")).toBeFalsy()})),it("should return true if address is from keyring type qr",(function(){expect((0,_.isQRHardwareAccount)("0xB374Ca013934e498e5baD3409147F34E6c462389")).toBeTruthy()}))})),describe("getKeyringByAddress",(function(){it("should throw an error if argument address is undefined",(function(){expect((function(){return(0,_.getKeyringByAddress)(void 0)})).toThrow("Invalid address: undefined")})),it("should return address if found",(function(){expect((0,_.getKeyringByAddress)("0xB374Ca013934e498e5baD3409147F34E6c462389")).not.toBe(void 0)})),it("should return null if address not found",(function(){expect((0,_.getKeyringByAddress)("0xB374Ca013934e498e5baD3409147F34E6c462387")).toBe(void 0)}))})),describe("isHardwareAccount,",(function(){it("should return true if account is a QR keyring",(function(){expect((0,_.isHardwareAccount)("0xB374Ca013934e498e5baD3409147F34E6c462389")).toBeTruthy()})),it("should return false if account is not a hardware keyring",(function(){expect((0,_.isHardwareAccount)("0xD5955C0d639D99699Bfd7Ec54d9FaFEe40e4D278")).toBeFalsy()}))})),describe("getLabelTextByAddress,",(function(){it("should return accounts.qr_hardware if account is a QR keyring",(function(){expect((0,_.getLabelTextByAddress)("0xB374Ca013934e498e5baD3409147F34E6c462389")).toBe("accounts.qr_hardware")})),it("should return KeyringTypes.simple if address is a imported account",(function(){expect((0,_.getLabelTextByAddress)("0xd018538C87232FF95acbCe4870629b75640a78E7")).toBe("accounts.imported")})),it("should return null if address is empty",(function(){expect((0,_.getLabelTextByAddress)("")).toBe(null)})),it("should return null if account not found",(function(){expect((0,_.getLabelTextByAddress)("0xD5955C0d639D99699Bfd7Ec54d9FaFEe40e4D278")).toBe(null)}))})),describe("getAddressAccountType",(function(){it("should throw an error if argument address is undefined",(function(){expect((function(){return(0,_.getAddressAccountType)(void 0)})).toThrow("Invalid address: undefined")})),it("should return QR if address is from a keyring type qr",(function(){expect((0,_.getAddressAccountType)("0xB374Ca013934e498e5baD3409147F34E6c462389")).toBe("QR")})),it("should return imported if address is from a keyring type simple",(function(){expect((0,_.getAddressAccountType)("0xd018538C87232FF95acbCe4870629b75640a78E7")).toBe("Imported")})),it("should return MetaMask if address is not qr or simple",(function(){expect((0,_.getAddressAccountType)("0x71C7656EC7ab88b098defB751B7401B5f6d8976F")).toBe("MetaMask")}))})),describe("resemblesAddress",(function(){it("should return false if argument address is undefined",(function(){expect((0,_.resemblesAddress)(void 0)).toBeFalsy()})),it("should return false if address does not resemble an eth address",(function(){expect((0,_.resemblesAddress)("address-stub-1")).toBeFalsy()})),it("should return true if address resemble an eth address",(function(){expect((0,_.resemblesAddress)("0x71C7656EC7ab88b098defB751B7401B5f6d8976F")).toBeTruthy()}))}))},"./src/utils/address/index.ts":(__unused_webpack_module,exports,__webpack_require__)=>{Object.defineProperty(exports,"__esModule",{value:!0}),exports.formatAddress=void 0,exports.renderFullAddress=renderFullAddress,exports.renderShortAddress=renderShortAddress,exports.renderSlightlyLongAddress=renderSlightlyLongAddress;var _ethereumjsUtil=__webpack_require__("./node_modules/ethereumjs-util/dist.browser/index.js"),strings=function strings(key){return`String for ${key}`};function renderFullAddress(address){return address?(0,_ethereumjsUtil.toChecksumAddress)(address):strings("transactions.tx_details_not_available")}exports.formatAddress=function formatAddress(rawAddress,type){if(!(0,_ethereumjsUtil.isValidAddress)(rawAddress))return rawAddress;switch(type){case"short":return renderShortAddress(rawAddress);case"mid":return renderSlightlyLongAddress(rawAddress);default:return renderFullAddress(rawAddress)}};function renderShortAddress(address){var chars=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4;if(!address)return address;var checksummedAddress=(0,_ethereumjsUtil.toChecksumAddress)(address);return`${checksummedAddress.substr(0,chars+2)}...${checksummedAddress.substr(-chars)}`}function renderSlightlyLongAddress(address){var chars=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,initialChars=arguments.length>2&&void 0!==arguments[2]?arguments[2]:20;if(!address)return address;var checksummedAddress=(0,_ethereumjsUtil.toChecksumAddress)(address);return`${checksummedAddress.slice(0,chars+initialChars)}...${checksummedAddress.slice(-chars)}`}},"?8131":()=>{},"?3fc0":()=>{},"?cd53":()=>{},"?7bec":()=>{},"?802b":()=>{},"?1e44":()=>{},"?ef3d":()=>{},"?fa7e":()=>{}}]);